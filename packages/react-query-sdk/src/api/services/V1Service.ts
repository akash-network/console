/**
 * This file was auto-generated by @openapi-qraft/cli.
 * Do not make direct changes to the file.
 */

import type {
  DeepReadonly,
  InvalidateQueryFilters,
  MutationFiltersByMutationKey,
  MutationFiltersByParameters,
  MutationVariables,
  OperationInfiniteData,
  PartialParameters,
  QraftServiceOperationsToken,
  QueryFiltersByParameters,
  QueryFiltersByQueryKey,
  QueryFnOptionsByParameters,
  QueryFnOptionsByQueryKey,
  RequestFnResponse,
  ServiceOperationEnsureInfiniteQueryDataOptions,
  ServiceOperationEnsureQueryDataOptions,
  ServiceOperationFetchInfiniteQueryOptions,
  ServiceOperationFetchQueryOptions,
  ServiceOperationInfiniteQueryKey,
  ServiceOperationMutationFnOptions,
  ServiceOperationMutationKey,
  ServiceOperationQueryKey,
  ServiceOperationUseMutationOptions,
  UseQueryOptionsForUseQueries,
  UseQueryOptionsForUseSuspenseQuery,
  WithOptional
} from "@openapi-qraft/tanstack-query-react-types";
import type {
  CancelOptions,
  InfiniteQueryPageParamsOptions,
  InvalidateOptions,
  Mutation,
  MutationState,
  NoInfer,
  QueryState,
  RefetchOptions,
  ResetOptions,
  SetDataOptions,
  Updater
} from "@tanstack/query-core";
import type {
  DefinedInitialDataInfiniteOptions,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  UndefinedInitialDataInfiniteOptions,
  UndefinedInitialDataOptions,
  UseInfiniteQueryResult,
  UseMutationResult,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from "@tanstack/react-query";

import type { paths } from "../schema";
export interface V1Service {
  /**
   * @summary Start a trial period for a user
   * @description Creates a managed wallet for a user and initiates a trial period. This endpoint handles payment method validation and may require 3D Secure authentication for certain payment methods. Returns wallet information and trial status.
   */
  postStartTrial: {
    /**
     * @summary Start a trial period for a user
     * @description Creates a managed wallet for a user and initiates a trial period. This endpoint handles payment method validation and may require 3D Secure authentication for certain payment methods. Returns wallet information and trial status.
     */
    getMutationKey(parameters: DeepReadonly<PostStartTrialParameters> | void): ServiceOperationMutationKey<PostStartTrialSchema, PostStartTrialParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Start a trial period for a user
     * @description Creates a managed wallet for a user and initiates a trial period. This endpoint handles payment method validation and may require 3D Secure authentication for certain payment methods. Returns wallet information and trial status.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStartTrial.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStartTrial.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends PostStartTrialBody, TContext = unknown>(
      parameters: DeepReadonly<PostStartTrialParameters>,
      options?: ServiceOperationUseMutationOptions<
        PostStartTrialSchema,
        PostStartTrialData,
        PostStartTrialParameters,
        TVariables,
        PostStartTrialError | Error,
        TContext
      >
    ): UseMutationResult<PostStartTrialData, PostStartTrialError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Start a trial period for a user
     * @description Creates a managed wallet for a user and initiates a trial period. This endpoint handles payment method validation and may require 3D Secure authentication for certain payment methods. Returns wallet information and trial status.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStartTrial.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStartTrial.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PostStartTrialBody, PostStartTrialParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PostStartTrialSchema,
        PostStartTrialData,
        PostStartTrialParameters,
        TVariables,
        PostStartTrialError | Error,
        TContext
      >
    ): UseMutationResult<PostStartTrialData, PostStartTrialError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Start a trial period for a user
     * @description Creates a managed wallet for a user and initiates a trial period. This endpoint handles payment method validation and may require 3D Secure authentication for certain payment methods. Returns wallet information and trial status.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const postStartTrialTotal = qraft.v1Service.postStartTrial.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const postStartTrialTotal = qraft.v1Service.postStartTrial.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<PostStartTrialBody, PostStartTrialData, PostStartTrialParameters, PostStartTrialError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostStartTrialSchema,
            PostStartTrialBody,
            PostStartTrialData,
            PostStartTrialParameters,
            PostStartTrialError | Error,
            TContext
          >
    ): number;
    /**
     * @summary Start a trial period for a user
     * @description Creates a managed wallet for a user and initiates a trial period. This endpoint handles payment method validation and may require 3D Secure authentication for certain payment methods. Returns wallet information and trial status.
     */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<PostStartTrialBody, PostStartTrialData, PostStartTrialParameters, PostStartTrialError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostStartTrialSchema,
            PostStartTrialBody,
            PostStartTrialData,
            PostStartTrialParameters,
            PostStartTrialError | Error,
            TContext
          >
    ): number;
    /**
     * @summary Start a trial period for a user
     * @description Creates a managed wallet for a user and initiates a trial period. This endpoint handles payment method validation and may require 3D Secure authentication for certain payment methods. Returns wallet information and trial status.
     */
    (
      options: ServiceOperationMutationFnOptions<PostStartTrialBody, PostStartTrialParameters>,
      client?: (
        schema: PostStartTrialSchema,
        options: ServiceOperationMutationFnOptions<PostStartTrialBody, PostStartTrialParameters>
      ) => Promise<RequestFnResponse<PostStartTrialData, PostStartTrialError>>
    ): Promise<RequestFnResponse<PostStartTrialData, PostStartTrialError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Start a trial period for a user
     * @description Creates a managed wallet for a user and initiates a trial period. This endpoint handles payment method validation and may require 3D Secure authentication for certain payment methods. Returns wallet information and trial status.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const postStartTrialPendingMutationVariables = qraft.v1Service.postStartTrial.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const postStartTrialMutationData = qraft.v1Service.postStartTrial.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<PostStartTrialData, PostStartTrialError | Error, MutationVariables<PostStartTrialBody, PostStartTrialParameters>, TContext>
    >(options?: {
      filters?:
        | MutationFiltersByParameters<PostStartTrialBody, PostStartTrialData, PostStartTrialParameters, PostStartTrialError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostStartTrialSchema,
            PostStartTrialBody,
            PostStartTrialData,
            PostStartTrialParameters,
            PostStartTrialError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<PostStartTrialData, PostStartTrialError | Error, MutationVariables<PostStartTrialBody, PostStartTrialParameters>, TContext>
      ) => TResult;
    }): Array<TResult>;
    schema: PostStartTrialSchema;
    types: {
      parameters: PostStartTrialParameters;
      data: PostStartTrialData;
      error: PostStartTrialError;
      body: PostStartTrialBody;
    };
  };
  /** @summary Get a list of wallets */
  getWallets: {
    /** @summary Get a list of wallets */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetWalletsSchema, GetWalletsData, TInfinite, GetWalletsParameters, GetWalletsError>
        | QueryFiltersByQueryKey<GetWalletsSchema, GetWalletsData, TInfinite, GetWalletsParameters, GetWalletsError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get a list of wallets */
    getQueryKey(parameters: DeepReadonly<GetWalletsParameters>): ServiceOperationQueryKey<GetWalletsSchema, GetWalletsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of wallets
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getWallets.useQuery({
     *     query: {
     *         userId: userId
     *     }
     * })
     * ```
     */
    useQuery<TData = GetWalletsData>(
      parameters: ServiceOperationQueryKey<GetWalletsSchema, GetWalletsParameters> | DeepReadonly<GetWalletsParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<GetWalletsData, GetWalletsError, TData, ServiceOperationQueryKey<GetWalletsSchema, GetWalletsParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetWalletsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of wallets
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getWallets.useQuery({
     *     query: {
     *         userId: userId
     *     }
     * })
     * ```
     */
    useQuery<TData = GetWalletsData>(
      parameters: ServiceOperationQueryKey<GetWalletsSchema, GetWalletsParameters> | DeepReadonly<GetWalletsParameters>,
      options: Omit<
        DefinedInitialDataOptions<GetWalletsData, GetWalletsError, TData, ServiceOperationQueryKey<GetWalletsSchema, GetWalletsParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetWalletsError | Error>;
    /** @summary Get a list of wallets */
    fetchInfiniteQuery<TPageParam extends GetWalletsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<GetWalletsSchema, GetWalletsData, GetWalletsParameters, DeepReadonly<TPageParam>, GetWalletsError>
    ): Promise<OperationInfiniteData<GetWalletsData, GetWalletsParameters>>;
    /** @summary Get a list of wallets */
    prefetchInfiniteQuery<TPageParam extends GetWalletsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<GetWalletsSchema, GetWalletsData, GetWalletsParameters, DeepReadonly<TPageParam>, GetWalletsError>
    ): Promise<void>;
    /** @summary Get a list of wallets */
    ensureInfiniteQueryData<TPageParam extends GetWalletsParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<GetWalletsSchema, GetWalletsData, GetWalletsParameters, DeepReadonly<TPageParam>, GetWalletsError>
    ): Promise<OperationInfiniteData<GetWalletsData, GetWalletsParameters>>;
    /** @summary Get a list of wallets */
    fetchQuery(options: ServiceOperationFetchQueryOptions<GetWalletsSchema, GetWalletsData, GetWalletsParameters, GetWalletsError>): Promise<GetWalletsData>;
    /** @summary Get a list of wallets */
    prefetchQuery(options: ServiceOperationFetchQueryOptions<GetWalletsSchema, GetWalletsData, GetWalletsParameters, GetWalletsError>): Promise<void>;
    /** @summary Get a list of wallets */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetWalletsSchema, GetWalletsData, GetWalletsParameters, GetWalletsError>
    ): Promise<GetWalletsData>;
    /** @summary Get a list of wallets */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetWalletsSchema, GetWalletsParameters> | DeepReadonly<GetWalletsParameters>
    ): OperationInfiniteData<GetWalletsData, GetWalletsParameters> | undefined;
    /** @summary Get a list of wallets */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetWalletsSchema, GetWalletsData, TInfinite, GetWalletsParameters, GetWalletsError>
        | QueryFiltersByQueryKey<GetWalletsSchema, GetWalletsData, TInfinite, GetWalletsParameters, GetWalletsError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetWalletsSchema, GetWalletsParameters>,
            data: NoInfer<OperationInfiniteData<GetWalletsData, GetWalletsParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetWalletsSchema, GetWalletsParameters>, data: GetWalletsData | undefined]>;
    /** @summary Get a list of wallets */
    getQueryData(parameters: ServiceOperationQueryKey<GetWalletsSchema, GetWalletsParameters> | DeepReadonly<GetWalletsParameters>): GetWalletsData | undefined;
    /** @summary Get a list of wallets */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetWalletsSchema, GetWalletsParameters> | DeepReadonly<GetWalletsParameters>
    ): QueryState<GetWalletsData, GetWalletsError> | undefined;
    /** @summary Get a list of wallets */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetWalletsParameters> | ServiceOperationInfiniteQueryKey<GetWalletsSchema, GetWalletsParameters>
    ): QueryState<OperationInfiniteData<GetWalletsData, GetWalletsParameters>, GetWalletsError> | undefined;
    /** @summary Get a list of wallets */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetWalletsSchema, GetWalletsData, TInfinite, GetWalletsParameters, GetWalletsError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get a list of wallets */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetWalletsSchema, GetWalletsData, TInfinite, GetWalletsParameters, GetWalletsError>
        | QueryFiltersByQueryKey<GetWalletsSchema, GetWalletsData, TInfinite, GetWalletsParameters, GetWalletsError>
    ): number;
    /** @summary Get a list of wallets */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetWalletsSchema, GetWalletsParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetWalletsParameters, TMeta, TSignal>,
      client?: (
        schema: GetWalletsSchema,
        options: {
          parameters: GetWalletsParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetWalletsData, GetWalletsError>>
    ): Promise<RequestFnResponse<GetWalletsData, GetWalletsError>>;
    /** @summary Get a list of wallets */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetWalletsSchema, GetWalletsData, TInfinite, GetWalletsParameters, GetWalletsError>
        | QueryFiltersByQueryKey<GetWalletsSchema, GetWalletsData, TInfinite, GetWalletsParameters, GetWalletsError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get a list of wallets */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetWalletsSchema, GetWalletsData, TInfinite, GetWalletsParameters, GetWalletsError>
        | QueryFiltersByQueryKey<GetWalletsSchema, GetWalletsData, TInfinite, GetWalletsParameters, GetWalletsError>
    ): void;
    /** @summary Get a list of wallets */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetWalletsSchema, GetWalletsData, TInfinite, GetWalletsParameters, GetWalletsError>
        | QueryFiltersByQueryKey<GetWalletsSchema, GetWalletsData, TInfinite, GetWalletsParameters, GetWalletsError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get a list of wallets */
    setInfiniteQueryData(
      parameters: DeepReadonly<GetWalletsParameters> | ServiceOperationInfiniteQueryKey<GetWalletsSchema, GetWalletsParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetWalletsData, GetWalletsParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetWalletsData, GetWalletsParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetWalletsData, GetWalletsParameters> | undefined;
    /** @summary Get a list of wallets */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetWalletsSchema, GetWalletsData, TInfinite, GetWalletsParameters, GetWalletsError>
        | QueryFiltersByQueryKey<GetWalletsSchema, GetWalletsData, TInfinite, GetWalletsParameters, GetWalletsError>,
      updater: Updater<NoInfer<GetWalletsData> | undefined, NoInfer<GetWalletsData> | undefined>,
      options?: SetDataOptions
    ): Array<GetWalletsData | undefined>;
    /** @summary Get a list of wallets */
    setQueryData(
      parameters: DeepReadonly<GetWalletsParameters> | ServiceOperationQueryKey<GetWalletsSchema, GetWalletsParameters>,
      updater: Updater<NoInfer<GetWalletsData> | undefined, NoInfer<DeepReadonly<GetWalletsData>> | undefined>,
      options?: SetDataOptions
    ): GetWalletsData | undefined;
    /** @summary Get a list of wallets */
    getInfiniteQueryKey(parameters: DeepReadonly<GetWalletsParameters>): ServiceOperationInfiniteQueryKey<GetWalletsSchema, GetWalletsParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of wallets
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getWallets.useInfiniteQuery({
     *     query: {
     *         userId: userId
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             userId: initialUserId
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<TPageParam extends GetWalletsParameters, TQueryFnData = GetWalletsData, TData = OperationInfiniteData<TQueryFnData, GetWalletsParameters>>(
      parameters: ServiceOperationInfiniteQueryKey<GetWalletsSchema, GetWalletsParameters> | DeepReadonly<GetWalletsParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetWalletsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetWalletsSchema, GetWalletsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetWalletsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of wallets
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getWallets.useInfiniteQuery({
     *     query: {
     *         userId: userId
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             userId: initialUserId
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<TPageParam extends GetWalletsParameters, TQueryFnData = GetWalletsData, TData = OperationInfiniteData<TQueryFnData, GetWalletsParameters>>(
      parameters: ServiceOperationInfiniteQueryKey<GetWalletsSchema, GetWalletsParameters> | DeepReadonly<GetWalletsParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetWalletsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetWalletsSchema, GetWalletsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetWalletsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetWalletsError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get a list of wallets
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getWalletsTotal = qraft.v1Service.getWallets.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getWalletsByParametersTotal = qraft.v1Service.getWallets.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         query: {
     *             userId: userId
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetWalletsSchema, GetWalletsData, TInfinite, GetWalletsParameters, GetWalletsError>
        | QueryFiltersByQueryKey<GetWalletsSchema, GetWalletsData, TInfinite, GetWalletsParameters, GetWalletsError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get a list of wallets
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getWalletsResults = qraft.v1Service.getWallets.useQueries({
     *     queries: [
     *         {
     *             query: {
     *                 userId: userId1
     *             }
     *         },
     *         {
     *             query: {
     *                 userId: userId2
     *             }
     *         }
     *     ]
     * });
     * getWalletsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getWalletsCombinedResults = qraft.v1Service.getWallets.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 userId: userId1
     *             }
     *         },
     *         {
     *             query: {
     *                 userId: userId2
     *             }
     *         }
     *     ]
     * });
     * getWalletsCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetWalletsSchema, GetWalletsParameters, GetWalletsData, GetWalletsError>>,
      TCombinedResult = Array<UseQueryResult<GetWalletsData, GetWalletsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetWalletsData, GetWalletsError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get a list of wallets */
    getQueryKey(parameters: DeepReadonly<GetWalletsParameters>): ServiceOperationQueryKey<GetWalletsSchema, GetWalletsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of wallets
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getWallets.useQuery({
     *     query: {
     *         userId: userId
     *     }
     * })
     * ```
     */
    useQuery<TData = GetWalletsData>(
      parameters: ServiceOperationQueryKey<GetWalletsSchema, GetWalletsParameters> | DeepReadonly<GetWalletsParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<GetWalletsData, GetWalletsError, TData, ServiceOperationQueryKey<GetWalletsSchema, GetWalletsParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetWalletsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of wallets
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getWallets.useQuery({
     *     query: {
     *         userId: userId
     *     }
     * })
     * ```
     */
    useQuery<TData = GetWalletsData>(
      parameters: ServiceOperationQueryKey<GetWalletsSchema, GetWalletsParameters> | DeepReadonly<GetWalletsParameters>,
      options: Omit<
        DefinedInitialDataOptions<GetWalletsData, GetWalletsError, TData, ServiceOperationQueryKey<GetWalletsSchema, GetWalletsParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetWalletsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get a list of wallets
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getWallets.useSuspenseInfiniteQuery({
     *     query: {
     *         userId: userId
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             userId: initialUserId
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetWalletsParameters, TData = GetWalletsData>(
      parameters: ServiceOperationInfiniteQueryKey<GetWalletsSchema, GetWalletsParameters> | DeepReadonly<GetWalletsParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetWalletsData,
          GetWalletsError,
          OperationInfiniteData<TData, GetWalletsParameters>,
          GetWalletsData,
          ServiceOperationInfiniteQueryKey<GetWalletsSchema, GetWalletsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetWalletsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetWalletsParameters>, GetWalletsError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get a list of wallets
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getWalletsData = qraft.v1Service.getWallets.useSuspenseQueries({
     *     queries: [
     *         {
     *             query: {
     *                 userId: userId1
     *             }
     *         },
     *         {
     *             query: {
     *                 userId: userId2
     *             }
     *         }
     *     ]
     * });
     * getWalletsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getWalletsCombinedData = qraft.v1Service.getWallets.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 userId: userId1
     *             }
     *         },
     *         {
     *             query: {
     *                 userId: userId2
     *             }
     *         }
     *     ]
     * });
     * getWalletsCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetWalletsSchema, GetWalletsParameters, GetWalletsData, GetWalletsError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetWalletsData, GetWalletsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetWalletsData, GetWalletsError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get a list of wallets
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getWallets.useSuspenseQuery({
     *     query: {
     *         userId: userId
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetWalletsData>(
      parameters: ServiceOperationQueryKey<GetWalletsSchema, GetWalletsParameters> | DeepReadonly<GetWalletsParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<GetWalletsData, GetWalletsError, TData, ServiceOperationQueryKey<GetWalletsSchema, GetWalletsParameters>>,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetWalletsError | Error>;
    schema: GetWalletsSchema;
    types: {
      parameters: GetWalletsParameters;
      data: GetWalletsData;
      error: GetWalletsError;
    };
  };
  /**
   * @summary Get wallet settings
   * @description Retrieves the wallet settings for the current user's wallet
   */
  getWalletSettings: {
    /**
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetWalletSettingsSchema, GetWalletSettingsData, TInfinite, GetWalletSettingsParameters, GetWalletSettingsError>
        | QueryFiltersByQueryKey<GetWalletSettingsSchema, GetWalletSettingsData, TInfinite, GetWalletSettingsParameters, GetWalletSettingsError>,
      options?: CancelOptions
    ): Promise<void>;
    /**
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     */
    getQueryKey(parameters: DeepReadonly<GetWalletSettingsParameters> | void): ServiceOperationQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getWalletSettings.useQuery()
     * ```
     */
    useQuery<TData = GetWalletSettingsData>(
      parameters: ServiceOperationQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters> | (DeepReadonly<GetWalletSettingsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetWalletSettingsData,
          GetWalletSettingsError,
          TData,
          ServiceOperationQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetWalletSettingsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getWalletSettings.useQuery()
     * ```
     */
    useQuery<TData = GetWalletSettingsData>(
      parameters: ServiceOperationQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters> | (DeepReadonly<GetWalletSettingsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetWalletSettingsData,
          GetWalletSettingsError,
          TData,
          ServiceOperationQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetWalletSettingsError | Error>;
    /**
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     */
    fetchInfiniteQuery<TPageParam extends GetWalletSettingsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetWalletSettingsSchema,
        GetWalletSettingsData,
        GetWalletSettingsParameters,
        DeepReadonly<TPageParam>,
        GetWalletSettingsError
      > | void
    ): Promise<OperationInfiniteData<GetWalletSettingsData, GetWalletSettingsParameters>>;
    /**
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     */
    prefetchInfiniteQuery<TPageParam extends GetWalletSettingsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetWalletSettingsSchema,
        GetWalletSettingsData,
        GetWalletSettingsParameters,
        DeepReadonly<TPageParam>,
        GetWalletSettingsError
      > | void
    ): Promise<void>;
    /**
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     */
    ensureInfiniteQueryData<TPageParam extends GetWalletSettingsParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetWalletSettingsSchema,
        GetWalletSettingsData,
        GetWalletSettingsParameters,
        DeepReadonly<TPageParam>,
        GetWalletSettingsError
      > | void
    ): Promise<OperationInfiniteData<GetWalletSettingsData, GetWalletSettingsParameters>>;
    /**
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetWalletSettingsSchema, GetWalletSettingsData, GetWalletSettingsParameters, GetWalletSettingsError> | void
    ): Promise<GetWalletSettingsData>;
    /**
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetWalletSettingsSchema, GetWalletSettingsData, GetWalletSettingsParameters, GetWalletSettingsError> | void
    ): Promise<void>;
    /**
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetWalletSettingsSchema,
        GetWalletSettingsData,
        GetWalletSettingsParameters,
        GetWalletSettingsError
      > | void
    ): Promise<GetWalletSettingsData>;
    /**
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters> | (DeepReadonly<GetWalletSettingsParameters> | void)
    ): OperationInfiniteData<GetWalletSettingsData, GetWalletSettingsParameters> | undefined;
    /**
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetWalletSettingsSchema, GetWalletSettingsData, TInfinite, GetWalletSettingsParameters, GetWalletSettingsError>
        | QueryFiltersByQueryKey<GetWalletSettingsSchema, GetWalletSettingsData, TInfinite, GetWalletSettingsParameters, GetWalletSettingsError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters>,
            data: NoInfer<OperationInfiniteData<GetWalletSettingsData, GetWalletSettingsParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters>, data: GetWalletSettingsData | undefined]>;
    /**
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters> | (DeepReadonly<GetWalletSettingsParameters> | void)
    ): GetWalletSettingsData | undefined;
    /**
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters> | (DeepReadonly<GetWalletSettingsParameters> | void)
    ): QueryState<GetWalletSettingsData, GetWalletSettingsError> | undefined;
    /**
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetWalletSettingsParameters> | ServiceOperationInfiniteQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters> | void
    ): QueryState<OperationInfiniteData<GetWalletSettingsData, GetWalletSettingsParameters>, GetWalletSettingsError> | undefined;
    /**
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetWalletSettingsSchema, GetWalletSettingsData, TInfinite, GetWalletSettingsParameters, GetWalletSettingsError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /**
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetWalletSettingsSchema, GetWalletSettingsData, TInfinite, GetWalletSettingsParameters, GetWalletSettingsError>
        | QueryFiltersByQueryKey<GetWalletSettingsSchema, GetWalletSettingsData, TInfinite, GetWalletSettingsParameters, GetWalletSettingsError>
    ): number;
    /**
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetWalletSettingsParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetWalletSettingsSchema,
        options: {
          parameters: GetWalletSettingsParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetWalletSettingsData, GetWalletSettingsError>>
    ): Promise<RequestFnResponse<GetWalletSettingsData, GetWalletSettingsError>>;
    /**
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetWalletSettingsSchema, GetWalletSettingsData, TInfinite, GetWalletSettingsParameters, GetWalletSettingsError>
        | QueryFiltersByQueryKey<GetWalletSettingsSchema, GetWalletSettingsData, TInfinite, GetWalletSettingsParameters, GetWalletSettingsError>,
      options?: RefetchOptions
    ): Promise<void>;
    /**
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetWalletSettingsSchema, GetWalletSettingsData, TInfinite, GetWalletSettingsParameters, GetWalletSettingsError>
        | QueryFiltersByQueryKey<GetWalletSettingsSchema, GetWalletSettingsData, TInfinite, GetWalletSettingsParameters, GetWalletSettingsError>
    ): void;
    /**
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetWalletSettingsSchema, GetWalletSettingsData, TInfinite, GetWalletSettingsParameters, GetWalletSettingsError>
        | QueryFiltersByQueryKey<GetWalletSettingsSchema, GetWalletSettingsData, TInfinite, GetWalletSettingsParameters, GetWalletSettingsError>,
      options?: ResetOptions
    ): Promise<void>;
    /**
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     */
    setInfiniteQueryData(
      parameters:
        | (DeepReadonly<GetWalletSettingsParameters> | undefined)
        | ServiceOperationInfiniteQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetWalletSettingsData, GetWalletSettingsParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetWalletSettingsData, GetWalletSettingsParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetWalletSettingsData, GetWalletSettingsParameters> | undefined;
    /**
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetWalletSettingsSchema, GetWalletSettingsData, TInfinite, GetWalletSettingsParameters, GetWalletSettingsError>
        | QueryFiltersByQueryKey<GetWalletSettingsSchema, GetWalletSettingsData, TInfinite, GetWalletSettingsParameters, GetWalletSettingsError>,
      updater: Updater<NoInfer<GetWalletSettingsData> | undefined, NoInfer<GetWalletSettingsData> | undefined>,
      options?: SetDataOptions
    ): Array<GetWalletSettingsData | undefined>;
    /**
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     */
    setQueryData(
      parameters: (DeepReadonly<GetWalletSettingsParameters> | undefined) | ServiceOperationQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters>,
      updater: Updater<NoInfer<GetWalletSettingsData> | undefined, NoInfer<DeepReadonly<GetWalletSettingsData>> | undefined>,
      options?: SetDataOptions
    ): GetWalletSettingsData | undefined;
    /**
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetWalletSettingsParameters> | void
    ): ServiceOperationInfiniteQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getWalletSettings.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetWalletSettingsParameters,
      TQueryFnData = GetWalletSettingsData,
      TData = OperationInfiniteData<TQueryFnData, GetWalletSettingsParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters> | (DeepReadonly<GetWalletSettingsParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetWalletSettingsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetWalletSettingsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getWalletSettings.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetWalletSettingsParameters,
      TQueryFnData = GetWalletSettingsData,
      TData = OperationInfiniteData<TQueryFnData, GetWalletSettingsParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters> | (DeepReadonly<GetWalletSettingsParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetWalletSettingsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetWalletSettingsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetWalletSettingsError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getWalletSettingsTotal = qraft.v1Service.getWalletSettings.useIsFetching()
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetWalletSettingsSchema, GetWalletSettingsData, TInfinite, GetWalletSettingsParameters, GetWalletSettingsError>
        | QueryFiltersByQueryKey<GetWalletSettingsSchema, GetWalletSettingsData, TInfinite, GetWalletSettingsParameters, GetWalletSettingsError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getWalletSettingsResults = qraft.v1Service.getWalletSettings.useQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getWalletSettingsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getWalletSettingsCombinedResults = qraft.v1Service.getWalletSettings.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getWalletSettingsCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetWalletSettingsSchema, GetWalletSettingsParameters, GetWalletSettingsData, GetWalletSettingsError>>,
      TCombinedResult = Array<UseQueryResult<GetWalletSettingsData, GetWalletSettingsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetWalletSettingsData, GetWalletSettingsError>>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     */
    getQueryKey(parameters: DeepReadonly<GetWalletSettingsParameters> | void): ServiceOperationQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getWalletSettings.useQuery()
     * ```
     */
    useQuery<TData = GetWalletSettingsData>(
      parameters: ServiceOperationQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters> | (DeepReadonly<GetWalletSettingsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetWalletSettingsData,
          GetWalletSettingsError,
          TData,
          ServiceOperationQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetWalletSettingsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getWalletSettings.useQuery()
     * ```
     */
    useQuery<TData = GetWalletSettingsData>(
      parameters: ServiceOperationQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters> | (DeepReadonly<GetWalletSettingsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetWalletSettingsData,
          GetWalletSettingsError,
          TData,
          ServiceOperationQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetWalletSettingsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getWalletSettings.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetWalletSettingsParameters, TData = GetWalletSettingsData>(
      parameters: ServiceOperationInfiniteQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters> | (DeepReadonly<GetWalletSettingsParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetWalletSettingsData,
          GetWalletSettingsError,
          OperationInfiniteData<TData, GetWalletSettingsParameters>,
          GetWalletSettingsData,
          ServiceOperationInfiniteQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetWalletSettingsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetWalletSettingsParameters>, GetWalletSettingsError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getWalletSettingsData = qraft.v1Service.getWalletSettings.useSuspenseQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getWalletSettingsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getWalletSettingsCombinedData = qraft.v1Service.getWalletSettings.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getWalletSettingsCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetWalletSettingsSchema, GetWalletSettingsParameters, GetWalletSettingsData, GetWalletSettingsError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetWalletSettingsData, GetWalletSettingsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetWalletSettingsData, GetWalletSettingsError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get wallet settings
     * @description Retrieves the wallet settings for the current user's wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getWalletSettings.useSuspenseQuery()
     * ```
     */
    useSuspenseQuery<TData = GetWalletSettingsData>(
      parameters: ServiceOperationQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters> | (DeepReadonly<GetWalletSettingsParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<
          GetWalletSettingsData,
          GetWalletSettingsError,
          TData,
          ServiceOperationQueryKey<GetWalletSettingsSchema, GetWalletSettingsParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetWalletSettingsError | Error>;
    schema: GetWalletSettingsSchema;
    types: {
      parameters: GetWalletSettingsParameters;
      data: GetWalletSettingsData;
      error: GetWalletSettingsError;
    };
  };
  /**
   * @summary Create wallet settings
   * @description Creates wallet settings for a user wallet
   */
  postWalletSettings: {
    /**
     * @summary Create wallet settings
     * @description Creates wallet settings for a user wallet
     */
    getMutationKey(
      parameters: DeepReadonly<PostWalletSettingsParameters> | void
    ): ServiceOperationMutationKey<PostWalletSettingsSchema, PostWalletSettingsParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Create wallet settings
     * @description Creates wallet settings for a user wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postWalletSettings.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postWalletSettings.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends PostWalletSettingsBody, TContext = unknown>(
      parameters: DeepReadonly<PostWalletSettingsParameters>,
      options?: ServiceOperationUseMutationOptions<
        PostWalletSettingsSchema,
        PostWalletSettingsData,
        PostWalletSettingsParameters,
        TVariables,
        PostWalletSettingsError | Error,
        TContext
      >
    ): UseMutationResult<PostWalletSettingsData, PostWalletSettingsError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Create wallet settings
     * @description Creates wallet settings for a user wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postWalletSettings.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postWalletSettings.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PostWalletSettingsBody, PostWalletSettingsParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PostWalletSettingsSchema,
        PostWalletSettingsData,
        PostWalletSettingsParameters,
        TVariables,
        PostWalletSettingsError | Error,
        TContext
      >
    ): UseMutationResult<PostWalletSettingsData, PostWalletSettingsError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Create wallet settings
     * @description Creates wallet settings for a user wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const postWalletSettingsTotal = qraft.v1Service.postWalletSettings.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const postWalletSettingsTotal = qraft.v1Service.postWalletSettings.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<PostWalletSettingsBody, PostWalletSettingsData, PostWalletSettingsParameters, PostWalletSettingsError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostWalletSettingsSchema,
            PostWalletSettingsBody,
            PostWalletSettingsData,
            PostWalletSettingsParameters,
            PostWalletSettingsError | Error,
            TContext
          >
    ): number;
    /**
     * @summary Create wallet settings
     * @description Creates wallet settings for a user wallet
     */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<PostWalletSettingsBody, PostWalletSettingsData, PostWalletSettingsParameters, PostWalletSettingsError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostWalletSettingsSchema,
            PostWalletSettingsBody,
            PostWalletSettingsData,
            PostWalletSettingsParameters,
            PostWalletSettingsError | Error,
            TContext
          >
    ): number;
    /**
     * @summary Create wallet settings
     * @description Creates wallet settings for a user wallet
     */
    (
      options: ServiceOperationMutationFnOptions<PostWalletSettingsBody, PostWalletSettingsParameters>,
      client?: (
        schema: PostWalletSettingsSchema,
        options: ServiceOperationMutationFnOptions<PostWalletSettingsBody, PostWalletSettingsParameters>
      ) => Promise<RequestFnResponse<PostWalletSettingsData, PostWalletSettingsError>>
    ): Promise<RequestFnResponse<PostWalletSettingsData, PostWalletSettingsError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Create wallet settings
     * @description Creates wallet settings for a user wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const postWalletSettingsPendingMutationVariables = qraft.v1Service.postWalletSettings.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const postWalletSettingsMutationData = qraft.v1Service.postWalletSettings.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        PostWalletSettingsData,
        PostWalletSettingsError | Error,
        MutationVariables<PostWalletSettingsBody, PostWalletSettingsParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<PostWalletSettingsBody, PostWalletSettingsData, PostWalletSettingsParameters, PostWalletSettingsError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostWalletSettingsSchema,
            PostWalletSettingsBody,
            PostWalletSettingsData,
            PostWalletSettingsParameters,
            PostWalletSettingsError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          PostWalletSettingsData,
          PostWalletSettingsError | Error,
          MutationVariables<PostWalletSettingsBody, PostWalletSettingsParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: PostWalletSettingsSchema;
    types: {
      parameters: PostWalletSettingsParameters;
      data: PostWalletSettingsData;
      error: PostWalletSettingsError;
      body: PostWalletSettingsBody;
    };
  };
  /**
   * @summary Update wallet settings
   * @description Updates wallet settings for a user wallet
   */
  putWalletSettings: {
    /**
     * @summary Update wallet settings
     * @description Updates wallet settings for a user wallet
     */
    getMutationKey(
      parameters: DeepReadonly<PutWalletSettingsParameters> | void
    ): ServiceOperationMutationKey<PutWalletSettingsSchema, PutWalletSettingsParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Update wallet settings
     * @description Updates wallet settings for a user wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.putWalletSettings.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.putWalletSettings.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends PutWalletSettingsBody, TContext = unknown>(
      parameters: DeepReadonly<PutWalletSettingsParameters>,
      options?: ServiceOperationUseMutationOptions<
        PutWalletSettingsSchema,
        PutWalletSettingsData,
        PutWalletSettingsParameters,
        TVariables,
        PutWalletSettingsError | Error,
        TContext
      >
    ): UseMutationResult<PutWalletSettingsData, PutWalletSettingsError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Update wallet settings
     * @description Updates wallet settings for a user wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.putWalletSettings.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.putWalletSettings.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PutWalletSettingsBody, PutWalletSettingsParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PutWalletSettingsSchema,
        PutWalletSettingsData,
        PutWalletSettingsParameters,
        TVariables,
        PutWalletSettingsError | Error,
        TContext
      >
    ): UseMutationResult<PutWalletSettingsData, PutWalletSettingsError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Update wallet settings
     * @description Updates wallet settings for a user wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const putWalletSettingsTotal = qraft.v1Service.putWalletSettings.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const putWalletSettingsTotal = qraft.v1Service.putWalletSettings.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<PutWalletSettingsBody, PutWalletSettingsData, PutWalletSettingsParameters, PutWalletSettingsError | Error, TContext>
        | MutationFiltersByMutationKey<
            PutWalletSettingsSchema,
            PutWalletSettingsBody,
            PutWalletSettingsData,
            PutWalletSettingsParameters,
            PutWalletSettingsError | Error,
            TContext
          >
    ): number;
    /**
     * @summary Update wallet settings
     * @description Updates wallet settings for a user wallet
     */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<PutWalletSettingsBody, PutWalletSettingsData, PutWalletSettingsParameters, PutWalletSettingsError | Error, TContext>
        | MutationFiltersByMutationKey<
            PutWalletSettingsSchema,
            PutWalletSettingsBody,
            PutWalletSettingsData,
            PutWalletSettingsParameters,
            PutWalletSettingsError | Error,
            TContext
          >
    ): number;
    /**
     * @summary Update wallet settings
     * @description Updates wallet settings for a user wallet
     */
    (
      options: ServiceOperationMutationFnOptions<PutWalletSettingsBody, PutWalletSettingsParameters>,
      client?: (
        schema: PutWalletSettingsSchema,
        options: ServiceOperationMutationFnOptions<PutWalletSettingsBody, PutWalletSettingsParameters>
      ) => Promise<RequestFnResponse<PutWalletSettingsData, PutWalletSettingsError>>
    ): Promise<RequestFnResponse<PutWalletSettingsData, PutWalletSettingsError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Update wallet settings
     * @description Updates wallet settings for a user wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const putWalletSettingsPendingMutationVariables = qraft.v1Service.putWalletSettings.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const putWalletSettingsMutationData = qraft.v1Service.putWalletSettings.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        PutWalletSettingsData,
        PutWalletSettingsError | Error,
        MutationVariables<PutWalletSettingsBody, PutWalletSettingsParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<PutWalletSettingsBody, PutWalletSettingsData, PutWalletSettingsParameters, PutWalletSettingsError | Error, TContext>
        | MutationFiltersByMutationKey<
            PutWalletSettingsSchema,
            PutWalletSettingsBody,
            PutWalletSettingsData,
            PutWalletSettingsParameters,
            PutWalletSettingsError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          PutWalletSettingsData,
          PutWalletSettingsError | Error,
          MutationVariables<PutWalletSettingsBody, PutWalletSettingsParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: PutWalletSettingsSchema;
    types: {
      parameters: PutWalletSettingsParameters;
      data: PutWalletSettingsData;
      error: PutWalletSettingsError;
      body: PutWalletSettingsBody;
    };
  };
  /**
   * @summary Delete wallet settings
   * @description Deletes wallet settings for a user wallet
   */
  deleteWalletSettings: {
    /**
     * @summary Delete wallet settings
     * @description Deletes wallet settings for a user wallet
     */
    getMutationKey(
      parameters: DeepReadonly<DeleteWalletSettingsParameters> | void
    ): ServiceOperationMutationKey<DeleteWalletSettingsSchema, DeleteWalletSettingsParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Delete wallet settings
     * @description Deletes wallet settings for a user wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteWalletSettings.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteWalletSettings.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends DeleteWalletSettingsBody, TContext = unknown>(
      parameters: DeepReadonly<DeleteWalletSettingsParameters>,
      options?: ServiceOperationUseMutationOptions<
        DeleteWalletSettingsSchema,
        DeleteWalletSettingsData,
        DeleteWalletSettingsParameters,
        TVariables,
        DeleteWalletSettingsError | Error,
        TContext
      >
    ): UseMutationResult<DeleteWalletSettingsData, DeleteWalletSettingsError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Delete wallet settings
     * @description Deletes wallet settings for a user wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteWalletSettings.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteWalletSettings.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<DeleteWalletSettingsBody, DeleteWalletSettingsParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        DeleteWalletSettingsSchema,
        DeleteWalletSettingsData,
        DeleteWalletSettingsParameters,
        TVariables,
        DeleteWalletSettingsError | Error,
        TContext
      >
    ): UseMutationResult<DeleteWalletSettingsData, DeleteWalletSettingsError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Delete wallet settings
     * @description Deletes wallet settings for a user wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const deleteWalletSettingsTotal = qraft.v1Service.deleteWalletSettings.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const deleteWalletSettingsTotal = qraft.v1Service.deleteWalletSettings.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<
            DeleteWalletSettingsBody,
            DeleteWalletSettingsData,
            DeleteWalletSettingsParameters,
            DeleteWalletSettingsError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            DeleteWalletSettingsSchema,
            DeleteWalletSettingsBody,
            DeleteWalletSettingsData,
            DeleteWalletSettingsParameters,
            DeleteWalletSettingsError | Error,
            TContext
          >
    ): number;
    /**
     * @summary Delete wallet settings
     * @description Deletes wallet settings for a user wallet
     */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<
            DeleteWalletSettingsBody,
            DeleteWalletSettingsData,
            DeleteWalletSettingsParameters,
            DeleteWalletSettingsError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            DeleteWalletSettingsSchema,
            DeleteWalletSettingsBody,
            DeleteWalletSettingsData,
            DeleteWalletSettingsParameters,
            DeleteWalletSettingsError | Error,
            TContext
          >
    ): number;
    /**
     * @summary Delete wallet settings
     * @description Deletes wallet settings for a user wallet
     */
    (
      options: ServiceOperationMutationFnOptions<DeleteWalletSettingsBody, DeleteWalletSettingsParameters>,
      client?: (
        schema: DeleteWalletSettingsSchema,
        options: ServiceOperationMutationFnOptions<DeleteWalletSettingsBody, DeleteWalletSettingsParameters>
      ) => Promise<RequestFnResponse<DeleteWalletSettingsData, DeleteWalletSettingsError>>
    ): Promise<RequestFnResponse<DeleteWalletSettingsData, DeleteWalletSettingsError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Delete wallet settings
     * @description Deletes wallet settings for a user wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const deleteWalletSettingsPendingMutationVariables = qraft.v1Service.deleteWalletSettings.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const deleteWalletSettingsMutationData = qraft.v1Service.deleteWalletSettings.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        DeleteWalletSettingsData,
        DeleteWalletSettingsError | Error,
        MutationVariables<DeleteWalletSettingsBody, DeleteWalletSettingsParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<
            DeleteWalletSettingsBody,
            DeleteWalletSettingsData,
            DeleteWalletSettingsParameters,
            DeleteWalletSettingsError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            DeleteWalletSettingsSchema,
            DeleteWalletSettingsBody,
            DeleteWalletSettingsData,
            DeleteWalletSettingsParameters,
            DeleteWalletSettingsError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          DeleteWalletSettingsData,
          DeleteWalletSettingsError | Error,
          MutationVariables<DeleteWalletSettingsBody, DeleteWalletSettingsParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: DeleteWalletSettingsSchema;
    types: {
      parameters: DeleteWalletSettingsParameters;
      data: DeleteWalletSettingsData;
      error: DeleteWalletSettingsError;
      body: DeleteWalletSettingsBody;
    };
  };
  /** @summary Signs a transaction via a user managed wallet */
  postTx: {
    /** @summary Signs a transaction via a user managed wallet */
    getMutationKey(parameters: DeepReadonly<PostTxParameters> | void): ServiceOperationMutationKey<PostTxSchema, PostTxParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Signs a transaction via a user managed wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postTx.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postTx.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends PostTxBody, TContext = unknown>(
      parameters: DeepReadonly<PostTxParameters>,
      options?: ServiceOperationUseMutationOptions<PostTxSchema, PostTxData, PostTxParameters, TVariables, PostTxError | Error, TContext>
    ): UseMutationResult<PostTxData, PostTxError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Signs a transaction via a user managed wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postTx.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postTx.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PostTxBody, PostTxParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<PostTxSchema, PostTxData, PostTxParameters, TVariables, PostTxError | Error, TContext>
    ): UseMutationResult<PostTxData, PostTxError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Signs a transaction via a user managed wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const postTxTotal = qraft.v1Service.postTx.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const postTxTotal = qraft.v1Service.postTx.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<PostTxBody, PostTxData, PostTxParameters, PostTxError | Error, TContext>
        | MutationFiltersByMutationKey<PostTxSchema, PostTxBody, PostTxData, PostTxParameters, PostTxError | Error, TContext>
    ): number;
    /** @summary Signs a transaction via a user managed wallet */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<PostTxBody, PostTxData, PostTxParameters, PostTxError | Error, TContext>
        | MutationFiltersByMutationKey<PostTxSchema, PostTxBody, PostTxData, PostTxParameters, PostTxError | Error, TContext>
    ): number;
    /** @summary Signs a transaction via a user managed wallet */
    (
      options: ServiceOperationMutationFnOptions<PostTxBody, PostTxParameters>,
      client?: (
        schema: PostTxSchema,
        options: ServiceOperationMutationFnOptions<PostTxBody, PostTxParameters>
      ) => Promise<RequestFnResponse<PostTxData, PostTxError>>
    ): Promise<RequestFnResponse<PostTxData, PostTxError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Signs a transaction via a user managed wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const postTxPendingMutationVariables = qraft.v1Service.postTx.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const postTxMutationData = qraft.v1Service.postTx.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<PostTxData, PostTxError | Error, MutationVariables<PostTxBody, PostTxParameters>, TContext>
    >(options?: {
      filters?:
        | MutationFiltersByParameters<PostTxBody, PostTxData, PostTxParameters, PostTxError | Error, TContext>
        | MutationFiltersByMutationKey<PostTxSchema, PostTxBody, PostTxData, PostTxParameters, PostTxError | Error, TContext>;
      select?: (mutation: Mutation<PostTxData, PostTxError | Error, MutationVariables<PostTxBody, PostTxParameters>, TContext>) => TResult;
    }): Array<TResult>;
    schema: PostTxSchema;
    types: {
      parameters: PostTxParameters;
      data: PostTxData;
      error: PostTxError;
      body: PostTxBody;
    };
  };
  /** @summary Creates a stripe checkout session and redirects to checkout */
  getCheckout: {
    /** @summary Creates a stripe checkout session and redirects to checkout */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetCheckoutSchema, GetCheckoutData, TInfinite, GetCheckoutParameters, GetCheckoutError>
        | QueryFiltersByQueryKey<GetCheckoutSchema, GetCheckoutData, TInfinite, GetCheckoutParameters, GetCheckoutError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Creates a stripe checkout session and redirects to checkout */
    getQueryKey(parameters: DeepReadonly<GetCheckoutParameters> | void): ServiceOperationQueryKey<GetCheckoutSchema, GetCheckoutParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Creates a stripe checkout session and redirects to checkout
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getCheckout.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getCheckout.useQuery({
     *     query: {
     *         amount: amount
     *     }
     * })
     * ```
     */
    useQuery<TData = GetCheckoutData>(
      parameters: ServiceOperationQueryKey<GetCheckoutSchema, GetCheckoutParameters> | (DeepReadonly<GetCheckoutParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetCheckoutData, GetCheckoutError, TData, ServiceOperationQueryKey<GetCheckoutSchema, GetCheckoutParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetCheckoutError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Creates a stripe checkout session and redirects to checkout
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getCheckout.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getCheckout.useQuery({
     *     query: {
     *         amount: amount
     *     }
     * })
     * ```
     */
    useQuery<TData = GetCheckoutData>(
      parameters: ServiceOperationQueryKey<GetCheckoutSchema, GetCheckoutParameters> | (DeepReadonly<GetCheckoutParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetCheckoutData, GetCheckoutError, TData, ServiceOperationQueryKey<GetCheckoutSchema, GetCheckoutParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetCheckoutError | Error>;
    /** @summary Creates a stripe checkout session and redirects to checkout */
    fetchInfiniteQuery<TPageParam extends GetCheckoutParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetCheckoutSchema,
        GetCheckoutData,
        GetCheckoutParameters,
        DeepReadonly<TPageParam>,
        GetCheckoutError
      > | void
    ): Promise<OperationInfiniteData<GetCheckoutData, GetCheckoutParameters>>;
    /** @summary Creates a stripe checkout session and redirects to checkout */
    prefetchInfiniteQuery<TPageParam extends GetCheckoutParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetCheckoutSchema,
        GetCheckoutData,
        GetCheckoutParameters,
        DeepReadonly<TPageParam>,
        GetCheckoutError
      > | void
    ): Promise<void>;
    /** @summary Creates a stripe checkout session and redirects to checkout */
    ensureInfiniteQueryData<TPageParam extends GetCheckoutParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetCheckoutSchema,
        GetCheckoutData,
        GetCheckoutParameters,
        DeepReadonly<TPageParam>,
        GetCheckoutError
      > | void
    ): Promise<OperationInfiniteData<GetCheckoutData, GetCheckoutParameters>>;
    /** @summary Creates a stripe checkout session and redirects to checkout */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetCheckoutSchema, GetCheckoutData, GetCheckoutParameters, GetCheckoutError> | void
    ): Promise<GetCheckoutData>;
    /** @summary Creates a stripe checkout session and redirects to checkout */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetCheckoutSchema, GetCheckoutData, GetCheckoutParameters, GetCheckoutError> | void
    ): Promise<void>;
    /** @summary Creates a stripe checkout session and redirects to checkout */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetCheckoutSchema, GetCheckoutData, GetCheckoutParameters, GetCheckoutError> | void
    ): Promise<GetCheckoutData>;
    /** @summary Creates a stripe checkout session and redirects to checkout */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetCheckoutSchema, GetCheckoutParameters> | (DeepReadonly<GetCheckoutParameters> | void)
    ): OperationInfiniteData<GetCheckoutData, GetCheckoutParameters> | undefined;
    /** @summary Creates a stripe checkout session and redirects to checkout */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetCheckoutSchema, GetCheckoutData, TInfinite, GetCheckoutParameters, GetCheckoutError>
        | QueryFiltersByQueryKey<GetCheckoutSchema, GetCheckoutData, TInfinite, GetCheckoutParameters, GetCheckoutError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetCheckoutSchema, GetCheckoutParameters>,
            data: NoInfer<OperationInfiniteData<GetCheckoutData, GetCheckoutParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetCheckoutSchema, GetCheckoutParameters>, data: GetCheckoutData | undefined]>;
    /** @summary Creates a stripe checkout session and redirects to checkout */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetCheckoutSchema, GetCheckoutParameters> | (DeepReadonly<GetCheckoutParameters> | void)
    ): GetCheckoutData | undefined;
    /** @summary Creates a stripe checkout session and redirects to checkout */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetCheckoutSchema, GetCheckoutParameters> | (DeepReadonly<GetCheckoutParameters> | void)
    ): QueryState<GetCheckoutData, GetCheckoutError> | undefined;
    /** @summary Creates a stripe checkout session and redirects to checkout */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetCheckoutParameters> | ServiceOperationInfiniteQueryKey<GetCheckoutSchema, GetCheckoutParameters> | void
    ): QueryState<OperationInfiniteData<GetCheckoutData, GetCheckoutParameters>, GetCheckoutError> | undefined;
    /** @summary Creates a stripe checkout session and redirects to checkout */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetCheckoutSchema, GetCheckoutData, TInfinite, GetCheckoutParameters, GetCheckoutError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Creates a stripe checkout session and redirects to checkout */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetCheckoutSchema, GetCheckoutData, TInfinite, GetCheckoutParameters, GetCheckoutError>
        | QueryFiltersByQueryKey<GetCheckoutSchema, GetCheckoutData, TInfinite, GetCheckoutParameters, GetCheckoutError>
    ): number;
    /** @summary Creates a stripe checkout session and redirects to checkout */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetCheckoutSchema, GetCheckoutParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetCheckoutParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetCheckoutSchema,
        options: {
          parameters: GetCheckoutParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetCheckoutData, GetCheckoutError>>
    ): Promise<RequestFnResponse<GetCheckoutData, GetCheckoutError>>;
    /** @summary Creates a stripe checkout session and redirects to checkout */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetCheckoutSchema, GetCheckoutData, TInfinite, GetCheckoutParameters, GetCheckoutError>
        | QueryFiltersByQueryKey<GetCheckoutSchema, GetCheckoutData, TInfinite, GetCheckoutParameters, GetCheckoutError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Creates a stripe checkout session and redirects to checkout */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetCheckoutSchema, GetCheckoutData, TInfinite, GetCheckoutParameters, GetCheckoutError>
        | QueryFiltersByQueryKey<GetCheckoutSchema, GetCheckoutData, TInfinite, GetCheckoutParameters, GetCheckoutError>
    ): void;
    /** @summary Creates a stripe checkout session and redirects to checkout */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetCheckoutSchema, GetCheckoutData, TInfinite, GetCheckoutParameters, GetCheckoutError>
        | QueryFiltersByQueryKey<GetCheckoutSchema, GetCheckoutData, TInfinite, GetCheckoutParameters, GetCheckoutError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Creates a stripe checkout session and redirects to checkout */
    setInfiniteQueryData(
      parameters: (DeepReadonly<GetCheckoutParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetCheckoutSchema, GetCheckoutParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetCheckoutData, GetCheckoutParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetCheckoutData, GetCheckoutParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetCheckoutData, GetCheckoutParameters> | undefined;
    /** @summary Creates a stripe checkout session and redirects to checkout */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetCheckoutSchema, GetCheckoutData, TInfinite, GetCheckoutParameters, GetCheckoutError>
        | QueryFiltersByQueryKey<GetCheckoutSchema, GetCheckoutData, TInfinite, GetCheckoutParameters, GetCheckoutError>,
      updater: Updater<NoInfer<GetCheckoutData> | undefined, NoInfer<GetCheckoutData> | undefined>,
      options?: SetDataOptions
    ): Array<GetCheckoutData | undefined>;
    /** @summary Creates a stripe checkout session and redirects to checkout */
    setQueryData(
      parameters: (DeepReadonly<GetCheckoutParameters> | undefined) | ServiceOperationQueryKey<GetCheckoutSchema, GetCheckoutParameters>,
      updater: Updater<NoInfer<GetCheckoutData> | undefined, NoInfer<DeepReadonly<GetCheckoutData>> | undefined>,
      options?: SetDataOptions
    ): GetCheckoutData | undefined;
    /** @summary Creates a stripe checkout session and redirects to checkout */
    getInfiniteQueryKey(parameters: DeepReadonly<GetCheckoutParameters> | void): ServiceOperationInfiniteQueryKey<GetCheckoutSchema, GetCheckoutParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Creates a stripe checkout session and redirects to checkout
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getCheckout.useInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             amount: initialAmount
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetCheckoutParameters,
      TQueryFnData = GetCheckoutData,
      TData = OperationInfiniteData<TQueryFnData, GetCheckoutParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetCheckoutSchema, GetCheckoutParameters> | (DeepReadonly<GetCheckoutParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetCheckoutError,
          TData,
          ServiceOperationInfiniteQueryKey<GetCheckoutSchema, GetCheckoutParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetCheckoutError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Creates a stripe checkout session and redirects to checkout
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getCheckout.useInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             amount: initialAmount
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetCheckoutParameters,
      TQueryFnData = GetCheckoutData,
      TData = OperationInfiniteData<TQueryFnData, GetCheckoutParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetCheckoutSchema, GetCheckoutParameters> | (DeepReadonly<GetCheckoutParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetCheckoutError,
          TData,
          ServiceOperationInfiniteQueryKey<GetCheckoutSchema, GetCheckoutParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetCheckoutData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetCheckoutError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Creates a stripe checkout session and redirects to checkout
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getCheckoutTotal = qraft.v1Service.getCheckout.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getCheckoutByParametersTotal = qraft.v1Service.getCheckout.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         query: {
     *             amount: amount
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetCheckoutSchema, GetCheckoutData, TInfinite, GetCheckoutParameters, GetCheckoutError>
        | QueryFiltersByQueryKey<GetCheckoutSchema, GetCheckoutData, TInfinite, GetCheckoutParameters, GetCheckoutError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Creates a stripe checkout session and redirects to checkout
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getCheckoutResults = qraft.v1Service.getCheckout.useQueries({
     *     queries: [
     *         {
     *             query: {
     *                 amount: amount1
     *             }
     *         },
     *         {
     *             query: {
     *                 amount: amount2
     *             }
     *         }
     *     ]
     * });
     * getCheckoutResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getCheckoutCombinedResults = qraft.v1Service.getCheckout.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 amount: amount1
     *             }
     *         },
     *         {
     *             query: {
     *                 amount: amount2
     *             }
     *         }
     *     ]
     * });
     * getCheckoutCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetCheckoutSchema, GetCheckoutParameters, GetCheckoutData, GetCheckoutError>>,
      TCombinedResult = Array<UseQueryResult<GetCheckoutData, GetCheckoutError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetCheckoutData, GetCheckoutError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Creates a stripe checkout session and redirects to checkout */
    getQueryKey(parameters: DeepReadonly<GetCheckoutParameters> | void): ServiceOperationQueryKey<GetCheckoutSchema, GetCheckoutParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Creates a stripe checkout session and redirects to checkout
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getCheckout.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getCheckout.useQuery({
     *     query: {
     *         amount: amount
     *     }
     * })
     * ```
     */
    useQuery<TData = GetCheckoutData>(
      parameters: ServiceOperationQueryKey<GetCheckoutSchema, GetCheckoutParameters> | (DeepReadonly<GetCheckoutParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetCheckoutData, GetCheckoutError, TData, ServiceOperationQueryKey<GetCheckoutSchema, GetCheckoutParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetCheckoutError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Creates a stripe checkout session and redirects to checkout
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getCheckout.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getCheckout.useQuery({
     *     query: {
     *         amount: amount
     *     }
     * })
     * ```
     */
    useQuery<TData = GetCheckoutData>(
      parameters: ServiceOperationQueryKey<GetCheckoutSchema, GetCheckoutParameters> | (DeepReadonly<GetCheckoutParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetCheckoutData, GetCheckoutError, TData, ServiceOperationQueryKey<GetCheckoutSchema, GetCheckoutParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetCheckoutError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Creates a stripe checkout session and redirects to checkout
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getCheckout.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             amount: initialAmount
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetCheckoutParameters, TData = GetCheckoutData>(
      parameters: ServiceOperationInfiniteQueryKey<GetCheckoutSchema, GetCheckoutParameters> | (DeepReadonly<GetCheckoutParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetCheckoutData,
          GetCheckoutError,
          OperationInfiniteData<TData, GetCheckoutParameters>,
          GetCheckoutData,
          ServiceOperationInfiniteQueryKey<GetCheckoutSchema, GetCheckoutParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetCheckoutData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetCheckoutParameters>, GetCheckoutError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Creates a stripe checkout session and redirects to checkout
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getCheckoutData = qraft.v1Service.getCheckout.useSuspenseQueries({
     *     queries: [
     *         {
     *             query: {
     *                 amount: amount1
     *             }
     *         },
     *         {
     *             query: {
     *                 amount: amount2
     *             }
     *         }
     *     ]
     * });
     * getCheckoutResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getCheckoutCombinedData = qraft.v1Service.getCheckout.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 amount: amount1
     *             }
     *         },
     *         {
     *             query: {
     *                 amount: amount2
     *             }
     *         }
     *     ]
     * });
     * getCheckoutCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetCheckoutSchema, GetCheckoutParameters, GetCheckoutData, GetCheckoutError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetCheckoutData, GetCheckoutError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetCheckoutData, GetCheckoutError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Creates a stripe checkout session and redirects to checkout
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getCheckout.useSuspenseQuery()
     * ```
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getCheckout.useSuspenseQuery({
     *     query: {
     *         amount: amount
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetCheckoutData>(
      parameters: ServiceOperationQueryKey<GetCheckoutSchema, GetCheckoutParameters> | (DeepReadonly<GetCheckoutParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<GetCheckoutData, GetCheckoutError, TData, ServiceOperationQueryKey<GetCheckoutSchema, GetCheckoutParameters>>,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetCheckoutError | Error>;
    schema: GetCheckoutSchema;
    types: {
      parameters: GetCheckoutParameters;
      data: GetCheckoutData;
      error: GetCheckoutError;
    };
  };
  /** @summary Stripe Webhook Handler */
  postStripeWebhook: {
    /** @summary Stripe Webhook Handler */
    getMutationKey(
      parameters: DeepReadonly<PostStripeWebhookParameters> | void
    ): ServiceOperationMutationKey<PostStripeWebhookSchema, PostStripeWebhookParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Stripe Webhook Handler
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStripeWebhook.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStripeWebhook.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends PostStripeWebhookBody, TContext = unknown>(
      parameters: DeepReadonly<PostStripeWebhookParameters>,
      options?: ServiceOperationUseMutationOptions<
        PostStripeWebhookSchema,
        PostStripeWebhookData,
        PostStripeWebhookParameters,
        TVariables,
        PostStripeWebhookError | Error,
        TContext
      >
    ): UseMutationResult<PostStripeWebhookData, PostStripeWebhookError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Stripe Webhook Handler
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStripeWebhook.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStripeWebhook.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PostStripeWebhookBody, PostStripeWebhookParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PostStripeWebhookSchema,
        PostStripeWebhookData,
        PostStripeWebhookParameters,
        TVariables,
        PostStripeWebhookError | Error,
        TContext
      >
    ): UseMutationResult<PostStripeWebhookData, PostStripeWebhookError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Stripe Webhook Handler
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const postStripeWebhookTotal = qraft.v1Service.postStripeWebhook.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const postStripeWebhookTotal = qraft.v1Service.postStripeWebhook.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<PostStripeWebhookBody, PostStripeWebhookData, PostStripeWebhookParameters, PostStripeWebhookError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostStripeWebhookSchema,
            PostStripeWebhookBody,
            PostStripeWebhookData,
            PostStripeWebhookParameters,
            PostStripeWebhookError | Error,
            TContext
          >
    ): number;
    /** @summary Stripe Webhook Handler */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<PostStripeWebhookBody, PostStripeWebhookData, PostStripeWebhookParameters, PostStripeWebhookError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostStripeWebhookSchema,
            PostStripeWebhookBody,
            PostStripeWebhookData,
            PostStripeWebhookParameters,
            PostStripeWebhookError | Error,
            TContext
          >
    ): number;
    /** @summary Stripe Webhook Handler */
    (
      options: ServiceOperationMutationFnOptions<PostStripeWebhookBody, PostStripeWebhookParameters>,
      client?: (
        schema: PostStripeWebhookSchema,
        options: ServiceOperationMutationFnOptions<PostStripeWebhookBody, PostStripeWebhookParameters>
      ) => Promise<RequestFnResponse<PostStripeWebhookData, PostStripeWebhookError>>
    ): Promise<RequestFnResponse<PostStripeWebhookData, PostStripeWebhookError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Stripe Webhook Handler
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const postStripeWebhookPendingMutationVariables = qraft.v1Service.postStripeWebhook.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const postStripeWebhookMutationData = qraft.v1Service.postStripeWebhook.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        PostStripeWebhookData,
        PostStripeWebhookError | Error,
        MutationVariables<PostStripeWebhookBody, PostStripeWebhookParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<PostStripeWebhookBody, PostStripeWebhookData, PostStripeWebhookParameters, PostStripeWebhookError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostStripeWebhookSchema,
            PostStripeWebhookBody,
            PostStripeWebhookData,
            PostStripeWebhookParameters,
            PostStripeWebhookError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          PostStripeWebhookData,
          PostStripeWebhookError | Error,
          MutationVariables<PostStripeWebhookBody, PostStripeWebhookParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: PostStripeWebhookSchema;
    types: {
      parameters: PostStripeWebhookParameters;
      data: PostStripeWebhookData;
      error: PostStripeWebhookError;
      body: PostStripeWebhookBody;
    };
  };
  /**
   * @summary Get available Stripe pricing options
   * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
   */
  getStripePrices: {
    /**
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetStripePricesSchema, GetStripePricesData, TInfinite, GetStripePricesParameters, GetStripePricesError>
        | QueryFiltersByQueryKey<GetStripePricesSchema, GetStripePricesData, TInfinite, GetStripePricesParameters, GetStripePricesError>,
      options?: CancelOptions
    ): Promise<void>;
    /**
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     */
    getQueryKey(parameters: DeepReadonly<GetStripePricesParameters> | void): ServiceOperationQueryKey<GetStripePricesSchema, GetStripePricesParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getStripePrices.useQuery()
     * ```
     */
    useQuery<TData = GetStripePricesData>(
      parameters: ServiceOperationQueryKey<GetStripePricesSchema, GetStripePricesParameters> | (DeepReadonly<GetStripePricesParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetStripePricesData,
          GetStripePricesError,
          TData,
          ServiceOperationQueryKey<GetStripePricesSchema, GetStripePricesParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetStripePricesError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getStripePrices.useQuery()
     * ```
     */
    useQuery<TData = GetStripePricesData>(
      parameters: ServiceOperationQueryKey<GetStripePricesSchema, GetStripePricesParameters> | (DeepReadonly<GetStripePricesParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetStripePricesData, GetStripePricesError, TData, ServiceOperationQueryKey<GetStripePricesSchema, GetStripePricesParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetStripePricesError | Error>;
    /**
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     */
    fetchInfiniteQuery<TPageParam extends GetStripePricesParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetStripePricesSchema,
        GetStripePricesData,
        GetStripePricesParameters,
        DeepReadonly<TPageParam>,
        GetStripePricesError
      > | void
    ): Promise<OperationInfiniteData<GetStripePricesData, GetStripePricesParameters>>;
    /**
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     */
    prefetchInfiniteQuery<TPageParam extends GetStripePricesParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetStripePricesSchema,
        GetStripePricesData,
        GetStripePricesParameters,
        DeepReadonly<TPageParam>,
        GetStripePricesError
      > | void
    ): Promise<void>;
    /**
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     */
    ensureInfiniteQueryData<TPageParam extends GetStripePricesParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetStripePricesSchema,
        GetStripePricesData,
        GetStripePricesParameters,
        DeepReadonly<TPageParam>,
        GetStripePricesError
      > | void
    ): Promise<OperationInfiniteData<GetStripePricesData, GetStripePricesParameters>>;
    /**
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetStripePricesSchema, GetStripePricesData, GetStripePricesParameters, GetStripePricesError> | void
    ): Promise<GetStripePricesData>;
    /**
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetStripePricesSchema, GetStripePricesData, GetStripePricesParameters, GetStripePricesError> | void
    ): Promise<void>;
    /**
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetStripePricesSchema, GetStripePricesData, GetStripePricesParameters, GetStripePricesError> | void
    ): Promise<GetStripePricesData>;
    /**
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetStripePricesSchema, GetStripePricesParameters> | (DeepReadonly<GetStripePricesParameters> | void)
    ): OperationInfiniteData<GetStripePricesData, GetStripePricesParameters> | undefined;
    /**
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetStripePricesSchema, GetStripePricesData, TInfinite, GetStripePricesParameters, GetStripePricesError>
        | QueryFiltersByQueryKey<GetStripePricesSchema, GetStripePricesData, TInfinite, GetStripePricesParameters, GetStripePricesError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetStripePricesSchema, GetStripePricesParameters>,
            data: NoInfer<OperationInfiniteData<GetStripePricesData, GetStripePricesParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetStripePricesSchema, GetStripePricesParameters>, data: GetStripePricesData | undefined]>;
    /**
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetStripePricesSchema, GetStripePricesParameters> | (DeepReadonly<GetStripePricesParameters> | void)
    ): GetStripePricesData | undefined;
    /**
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetStripePricesSchema, GetStripePricesParameters> | (DeepReadonly<GetStripePricesParameters> | void)
    ): QueryState<GetStripePricesData, GetStripePricesError> | undefined;
    /**
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetStripePricesParameters> | ServiceOperationInfiniteQueryKey<GetStripePricesSchema, GetStripePricesParameters> | void
    ): QueryState<OperationInfiniteData<GetStripePricesData, GetStripePricesParameters>, GetStripePricesError> | undefined;
    /**
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetStripePricesSchema, GetStripePricesData, TInfinite, GetStripePricesParameters, GetStripePricesError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /**
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetStripePricesSchema, GetStripePricesData, TInfinite, GetStripePricesParameters, GetStripePricesError>
        | QueryFiltersByQueryKey<GetStripePricesSchema, GetStripePricesData, TInfinite, GetStripePricesParameters, GetStripePricesError>
    ): number;
    /**
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetStripePricesSchema, GetStripePricesParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetStripePricesParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetStripePricesSchema,
        options: {
          parameters: GetStripePricesParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetStripePricesData, GetStripePricesError>>
    ): Promise<RequestFnResponse<GetStripePricesData, GetStripePricesError>>;
    /**
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetStripePricesSchema, GetStripePricesData, TInfinite, GetStripePricesParameters, GetStripePricesError>
        | QueryFiltersByQueryKey<GetStripePricesSchema, GetStripePricesData, TInfinite, GetStripePricesParameters, GetStripePricesError>,
      options?: RefetchOptions
    ): Promise<void>;
    /**
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetStripePricesSchema, GetStripePricesData, TInfinite, GetStripePricesParameters, GetStripePricesError>
        | QueryFiltersByQueryKey<GetStripePricesSchema, GetStripePricesData, TInfinite, GetStripePricesParameters, GetStripePricesError>
    ): void;
    /**
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetStripePricesSchema, GetStripePricesData, TInfinite, GetStripePricesParameters, GetStripePricesError>
        | QueryFiltersByQueryKey<GetStripePricesSchema, GetStripePricesData, TInfinite, GetStripePricesParameters, GetStripePricesError>,
      options?: ResetOptions
    ): Promise<void>;
    /**
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     */
    setInfiniteQueryData(
      parameters: (DeepReadonly<GetStripePricesParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetStripePricesSchema, GetStripePricesParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetStripePricesData, GetStripePricesParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetStripePricesData, GetStripePricesParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetStripePricesData, GetStripePricesParameters> | undefined;
    /**
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetStripePricesSchema, GetStripePricesData, TInfinite, GetStripePricesParameters, GetStripePricesError>
        | QueryFiltersByQueryKey<GetStripePricesSchema, GetStripePricesData, TInfinite, GetStripePricesParameters, GetStripePricesError>,
      updater: Updater<NoInfer<GetStripePricesData> | undefined, NoInfer<GetStripePricesData> | undefined>,
      options?: SetDataOptions
    ): Array<GetStripePricesData | undefined>;
    /**
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     */
    setQueryData(
      parameters: (DeepReadonly<GetStripePricesParameters> | undefined) | ServiceOperationQueryKey<GetStripePricesSchema, GetStripePricesParameters>,
      updater: Updater<NoInfer<GetStripePricesData> | undefined, NoInfer<DeepReadonly<GetStripePricesData>> | undefined>,
      options?: SetDataOptions
    ): GetStripePricesData | undefined;
    /**
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetStripePricesParameters> | void
    ): ServiceOperationInfiniteQueryKey<GetStripePricesSchema, GetStripePricesParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getStripePrices.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetStripePricesParameters,
      TQueryFnData = GetStripePricesData,
      TData = OperationInfiniteData<TQueryFnData, GetStripePricesParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetStripePricesSchema, GetStripePricesParameters> | (DeepReadonly<GetStripePricesParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetStripePricesError,
          TData,
          ServiceOperationInfiniteQueryKey<GetStripePricesSchema, GetStripePricesParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetStripePricesError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getStripePrices.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetStripePricesParameters,
      TQueryFnData = GetStripePricesData,
      TData = OperationInfiniteData<TQueryFnData, GetStripePricesParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetStripePricesSchema, GetStripePricesParameters> | (DeepReadonly<GetStripePricesParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetStripePricesError,
          TData,
          ServiceOperationInfiniteQueryKey<GetStripePricesSchema, GetStripePricesParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetStripePricesData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetStripePricesError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getStripePricesTotal = qraft.v1Service.getStripePrices.useIsFetching()
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetStripePricesSchema, GetStripePricesData, TInfinite, GetStripePricesParameters, GetStripePricesError>
        | QueryFiltersByQueryKey<GetStripePricesSchema, GetStripePricesData, TInfinite, GetStripePricesParameters, GetStripePricesError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getStripePricesResults = qraft.v1Service.getStripePrices.useQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getStripePricesResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getStripePricesCombinedResults = qraft.v1Service.getStripePrices.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getStripePricesCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetStripePricesSchema, GetStripePricesParameters, GetStripePricesData, GetStripePricesError>>,
      TCombinedResult = Array<UseQueryResult<GetStripePricesData, GetStripePricesError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetStripePricesData, GetStripePricesError>>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     */
    getQueryKey(parameters: DeepReadonly<GetStripePricesParameters> | void): ServiceOperationQueryKey<GetStripePricesSchema, GetStripePricesParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getStripePrices.useQuery()
     * ```
     */
    useQuery<TData = GetStripePricesData>(
      parameters: ServiceOperationQueryKey<GetStripePricesSchema, GetStripePricesParameters> | (DeepReadonly<GetStripePricesParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetStripePricesData,
          GetStripePricesError,
          TData,
          ServiceOperationQueryKey<GetStripePricesSchema, GetStripePricesParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetStripePricesError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getStripePrices.useQuery()
     * ```
     */
    useQuery<TData = GetStripePricesData>(
      parameters: ServiceOperationQueryKey<GetStripePricesSchema, GetStripePricesParameters> | (DeepReadonly<GetStripePricesParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetStripePricesData, GetStripePricesError, TData, ServiceOperationQueryKey<GetStripePricesSchema, GetStripePricesParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetStripePricesError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getStripePrices.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetStripePricesParameters, TData = GetStripePricesData>(
      parameters: ServiceOperationInfiniteQueryKey<GetStripePricesSchema, GetStripePricesParameters> | (DeepReadonly<GetStripePricesParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetStripePricesData,
          GetStripePricesError,
          OperationInfiniteData<TData, GetStripePricesParameters>,
          GetStripePricesData,
          ServiceOperationInfiniteQueryKey<GetStripePricesSchema, GetStripePricesParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetStripePricesData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetStripePricesParameters>, GetStripePricesError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getStripePricesData = qraft.v1Service.getStripePrices.useSuspenseQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getStripePricesResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getStripePricesCombinedData = qraft.v1Service.getStripePrices.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getStripePricesCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetStripePricesSchema, GetStripePricesParameters, GetStripePricesData, GetStripePricesError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetStripePricesData, GetStripePricesError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetStripePricesData, GetStripePricesError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get available Stripe pricing options
     * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getStripePrices.useSuspenseQuery()
     * ```
     */
    useSuspenseQuery<TData = GetStripePricesData>(
      parameters: ServiceOperationQueryKey<GetStripePricesSchema, GetStripePricesParameters> | (DeepReadonly<GetStripePricesParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<GetStripePricesData, GetStripePricesError, TData, ServiceOperationQueryKey<GetStripePricesSchema, GetStripePricesParameters>>,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetStripePricesError | Error>;
    schema: GetStripePricesSchema;
    types: {
      parameters: GetStripePricesParameters;
      data: GetStripePricesData;
      error: GetStripePricesError;
    };
  };
  /** @summary Apply a coupon to the current user */
  postStripeCouponsApply: {
    /** @summary Apply a coupon to the current user */
    getMutationKey(
      parameters: DeepReadonly<PostStripeCouponsApplyParameters> | void
    ): ServiceOperationMutationKey<PostStripeCouponsApplySchema, PostStripeCouponsApplyParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Apply a coupon to the current user
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStripeCouponsApply.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStripeCouponsApply.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends PostStripeCouponsApplyBody, TContext = unknown>(
      parameters: DeepReadonly<PostStripeCouponsApplyParameters>,
      options?: ServiceOperationUseMutationOptions<
        PostStripeCouponsApplySchema,
        PostStripeCouponsApplyData,
        PostStripeCouponsApplyParameters,
        TVariables,
        PostStripeCouponsApplyError | Error,
        TContext
      >
    ): UseMutationResult<PostStripeCouponsApplyData, PostStripeCouponsApplyError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Apply a coupon to the current user
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStripeCouponsApply.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStripeCouponsApply.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PostStripeCouponsApplyBody, PostStripeCouponsApplyParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PostStripeCouponsApplySchema,
        PostStripeCouponsApplyData,
        PostStripeCouponsApplyParameters,
        TVariables,
        PostStripeCouponsApplyError | Error,
        TContext
      >
    ): UseMutationResult<PostStripeCouponsApplyData, PostStripeCouponsApplyError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Apply a coupon to the current user
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const postStripeCouponsApplyTotal = qraft.v1Service.postStripeCouponsApply.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const postStripeCouponsApplyTotal = qraft.v1Service.postStripeCouponsApply.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<
            PostStripeCouponsApplyBody,
            PostStripeCouponsApplyData,
            PostStripeCouponsApplyParameters,
            PostStripeCouponsApplyError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PostStripeCouponsApplySchema,
            PostStripeCouponsApplyBody,
            PostStripeCouponsApplyData,
            PostStripeCouponsApplyParameters,
            PostStripeCouponsApplyError | Error,
            TContext
          >
    ): number;
    /** @summary Apply a coupon to the current user */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<
            PostStripeCouponsApplyBody,
            PostStripeCouponsApplyData,
            PostStripeCouponsApplyParameters,
            PostStripeCouponsApplyError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PostStripeCouponsApplySchema,
            PostStripeCouponsApplyBody,
            PostStripeCouponsApplyData,
            PostStripeCouponsApplyParameters,
            PostStripeCouponsApplyError | Error,
            TContext
          >
    ): number;
    /** @summary Apply a coupon to the current user */
    (
      options: ServiceOperationMutationFnOptions<PostStripeCouponsApplyBody, PostStripeCouponsApplyParameters>,
      client?: (
        schema: PostStripeCouponsApplySchema,
        options: ServiceOperationMutationFnOptions<PostStripeCouponsApplyBody, PostStripeCouponsApplyParameters>
      ) => Promise<RequestFnResponse<PostStripeCouponsApplyData, PostStripeCouponsApplyError>>
    ): Promise<RequestFnResponse<PostStripeCouponsApplyData, PostStripeCouponsApplyError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Apply a coupon to the current user
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const postStripeCouponsApplyPendingMutationVariables = qraft.v1Service.postStripeCouponsApply.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const postStripeCouponsApplyMutationData = qraft.v1Service.postStripeCouponsApply.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        PostStripeCouponsApplyData,
        PostStripeCouponsApplyError | Error,
        MutationVariables<PostStripeCouponsApplyBody, PostStripeCouponsApplyParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<
            PostStripeCouponsApplyBody,
            PostStripeCouponsApplyData,
            PostStripeCouponsApplyParameters,
            PostStripeCouponsApplyError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PostStripeCouponsApplySchema,
            PostStripeCouponsApplyBody,
            PostStripeCouponsApplyData,
            PostStripeCouponsApplyParameters,
            PostStripeCouponsApplyError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          PostStripeCouponsApplyData,
          PostStripeCouponsApplyError | Error,
          MutationVariables<PostStripeCouponsApplyBody, PostStripeCouponsApplyParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: PostStripeCouponsApplySchema;
    types: {
      parameters: PostStripeCouponsApplyParameters;
      data: PostStripeCouponsApplyData;
      error: PostStripeCouponsApplyError;
      body: PostStripeCouponsApplyBody;
    };
  };
  /**
   * @summary Update customer organization
   * @description Updates the organization/business name for the current user's Stripe customer account
   */
  putStripeCustomersOrganization: {
    /**
     * @summary Update customer organization
     * @description Updates the organization/business name for the current user's Stripe customer account
     */
    getMutationKey(
      parameters: DeepReadonly<PutStripeCustomersOrganizationParameters> | void
    ): ServiceOperationMutationKey<PutStripeCustomersOrganizationSchema, PutStripeCustomersOrganizationParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Update customer organization
     * @description Updates the organization/business name for the current user's Stripe customer account
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.putStripeCustomersOrganization.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.putStripeCustomersOrganization.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends PutStripeCustomersOrganizationBody, TContext = unknown>(
      parameters: DeepReadonly<PutStripeCustomersOrganizationParameters>,
      options?: ServiceOperationUseMutationOptions<
        PutStripeCustomersOrganizationSchema,
        PutStripeCustomersOrganizationData,
        PutStripeCustomersOrganizationParameters,
        TVariables,
        PutStripeCustomersOrganizationError | Error,
        TContext
      >
    ): UseMutationResult<PutStripeCustomersOrganizationData, PutStripeCustomersOrganizationError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Update customer organization
     * @description Updates the organization/business name for the current user's Stripe customer account
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.putStripeCustomersOrganization.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.putStripeCustomersOrganization.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PutStripeCustomersOrganizationBody, PutStripeCustomersOrganizationParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PutStripeCustomersOrganizationSchema,
        PutStripeCustomersOrganizationData,
        PutStripeCustomersOrganizationParameters,
        TVariables,
        PutStripeCustomersOrganizationError | Error,
        TContext
      >
    ): UseMutationResult<PutStripeCustomersOrganizationData, PutStripeCustomersOrganizationError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Update customer organization
     * @description Updates the organization/business name for the current user's Stripe customer account
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const putStripeCustomersOrganizationTotal = qraft.v1Service.putStripeCustomersOrganization.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const putStripeCustomersOrganizationTotal = qraft.v1Service.putStripeCustomersOrganization.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<
            PutStripeCustomersOrganizationBody,
            PutStripeCustomersOrganizationData,
            PutStripeCustomersOrganizationParameters,
            PutStripeCustomersOrganizationError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PutStripeCustomersOrganizationSchema,
            PutStripeCustomersOrganizationBody,
            PutStripeCustomersOrganizationData,
            PutStripeCustomersOrganizationParameters,
            PutStripeCustomersOrganizationError | Error,
            TContext
          >
    ): number;
    /**
     * @summary Update customer organization
     * @description Updates the organization/business name for the current user's Stripe customer account
     */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<
            PutStripeCustomersOrganizationBody,
            PutStripeCustomersOrganizationData,
            PutStripeCustomersOrganizationParameters,
            PutStripeCustomersOrganizationError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PutStripeCustomersOrganizationSchema,
            PutStripeCustomersOrganizationBody,
            PutStripeCustomersOrganizationData,
            PutStripeCustomersOrganizationParameters,
            PutStripeCustomersOrganizationError | Error,
            TContext
          >
    ): number;
    /**
     * @summary Update customer organization
     * @description Updates the organization/business name for the current user's Stripe customer account
     */
    (
      options: ServiceOperationMutationFnOptions<PutStripeCustomersOrganizationBody, PutStripeCustomersOrganizationParameters>,
      client?: (
        schema: PutStripeCustomersOrganizationSchema,
        options: ServiceOperationMutationFnOptions<PutStripeCustomersOrganizationBody, PutStripeCustomersOrganizationParameters>
      ) => Promise<RequestFnResponse<PutStripeCustomersOrganizationData, PutStripeCustomersOrganizationError>>
    ): Promise<RequestFnResponse<PutStripeCustomersOrganizationData, PutStripeCustomersOrganizationError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Update customer organization
     * @description Updates the organization/business name for the current user's Stripe customer account
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const putStripeCustomersOrganizationPendingMutationVariables = qraft.v1Service.putStripeCustomersOrganization.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const putStripeCustomersOrganizationMutationData = qraft.v1Service.putStripeCustomersOrganization.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        PutStripeCustomersOrganizationData,
        PutStripeCustomersOrganizationError | Error,
        MutationVariables<PutStripeCustomersOrganizationBody, PutStripeCustomersOrganizationParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<
            PutStripeCustomersOrganizationBody,
            PutStripeCustomersOrganizationData,
            PutStripeCustomersOrganizationParameters,
            PutStripeCustomersOrganizationError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PutStripeCustomersOrganizationSchema,
            PutStripeCustomersOrganizationBody,
            PutStripeCustomersOrganizationData,
            PutStripeCustomersOrganizationParameters,
            PutStripeCustomersOrganizationError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          PutStripeCustomersOrganizationData,
          PutStripeCustomersOrganizationError | Error,
          MutationVariables<PutStripeCustomersOrganizationBody, PutStripeCustomersOrganizationParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: PutStripeCustomersOrganizationSchema;
    types: {
      parameters: PutStripeCustomersOrganizationParameters;
      data: PutStripeCustomersOrganizationData;
      error: PutStripeCustomersOrganizationError;
      body: PutStripeCustomersOrganizationBody;
    };
  };
  /**
   * @summary Create a Stripe SetupIntent for adding a payment method
   * @description Creates a Stripe SetupIntent that allows users to securely add payment methods to their account. The SetupIntent provides a client secret that can be used with Stripe's frontend SDKs to collect payment method details.
   */
  postStripePaymentMethodsSetup: {
    /**
     * @summary Create a Stripe SetupIntent for adding a payment method
     * @description Creates a Stripe SetupIntent that allows users to securely add payment methods to their account. The SetupIntent provides a client secret that can be used with Stripe's frontend SDKs to collect payment method details.
     */
    getMutationKey(
      parameters: DeepReadonly<PostStripePaymentMethodsSetupParameters> | void
    ): ServiceOperationMutationKey<PostStripePaymentMethodsSetupSchema, PostStripePaymentMethodsSetupParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Create a Stripe SetupIntent for adding a payment method
     * @description Creates a Stripe SetupIntent that allows users to securely add payment methods to their account. The SetupIntent provides a client secret that can be used with Stripe's frontend SDKs to collect payment method details.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStripePaymentMethodsSetup.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStripePaymentMethodsSetup.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends PostStripePaymentMethodsSetupBody, TContext = unknown>(
      parameters: DeepReadonly<PostStripePaymentMethodsSetupParameters>,
      options?: ServiceOperationUseMutationOptions<
        PostStripePaymentMethodsSetupSchema,
        PostStripePaymentMethodsSetupData,
        PostStripePaymentMethodsSetupParameters,
        TVariables,
        PostStripePaymentMethodsSetupError | Error,
        TContext
      >
    ): UseMutationResult<PostStripePaymentMethodsSetupData, PostStripePaymentMethodsSetupError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Create a Stripe SetupIntent for adding a payment method
     * @description Creates a Stripe SetupIntent that allows users to securely add payment methods to their account. The SetupIntent provides a client secret that can be used with Stripe's frontend SDKs to collect payment method details.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStripePaymentMethodsSetup.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStripePaymentMethodsSetup.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PostStripePaymentMethodsSetupBody, PostStripePaymentMethodsSetupParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PostStripePaymentMethodsSetupSchema,
        PostStripePaymentMethodsSetupData,
        PostStripePaymentMethodsSetupParameters,
        TVariables,
        PostStripePaymentMethodsSetupError | Error,
        TContext
      >
    ): UseMutationResult<PostStripePaymentMethodsSetupData, PostStripePaymentMethodsSetupError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Create a Stripe SetupIntent for adding a payment method
     * @description Creates a Stripe SetupIntent that allows users to securely add payment methods to their account. The SetupIntent provides a client secret that can be used with Stripe's frontend SDKs to collect payment method details.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const postStripePaymentMethodsSetupTotal = qraft.v1Service.postStripePaymentMethodsSetup.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const postStripePaymentMethodsSetupTotal = qraft.v1Service.postStripePaymentMethodsSetup.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<
            PostStripePaymentMethodsSetupBody,
            PostStripePaymentMethodsSetupData,
            PostStripePaymentMethodsSetupParameters,
            PostStripePaymentMethodsSetupError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PostStripePaymentMethodsSetupSchema,
            PostStripePaymentMethodsSetupBody,
            PostStripePaymentMethodsSetupData,
            PostStripePaymentMethodsSetupParameters,
            PostStripePaymentMethodsSetupError | Error,
            TContext
          >
    ): number;
    /**
     * @summary Create a Stripe SetupIntent for adding a payment method
     * @description Creates a Stripe SetupIntent that allows users to securely add payment methods to their account. The SetupIntent provides a client secret that can be used with Stripe's frontend SDKs to collect payment method details.
     */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<
            PostStripePaymentMethodsSetupBody,
            PostStripePaymentMethodsSetupData,
            PostStripePaymentMethodsSetupParameters,
            PostStripePaymentMethodsSetupError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PostStripePaymentMethodsSetupSchema,
            PostStripePaymentMethodsSetupBody,
            PostStripePaymentMethodsSetupData,
            PostStripePaymentMethodsSetupParameters,
            PostStripePaymentMethodsSetupError | Error,
            TContext
          >
    ): number;
    /**
     * @summary Create a Stripe SetupIntent for adding a payment method
     * @description Creates a Stripe SetupIntent that allows users to securely add payment methods to their account. The SetupIntent provides a client secret that can be used with Stripe's frontend SDKs to collect payment method details.
     */
    (
      options: ServiceOperationMutationFnOptions<PostStripePaymentMethodsSetupBody, PostStripePaymentMethodsSetupParameters>,
      client?: (
        schema: PostStripePaymentMethodsSetupSchema,
        options: ServiceOperationMutationFnOptions<PostStripePaymentMethodsSetupBody, PostStripePaymentMethodsSetupParameters>
      ) => Promise<RequestFnResponse<PostStripePaymentMethodsSetupData, PostStripePaymentMethodsSetupError>>
    ): Promise<RequestFnResponse<PostStripePaymentMethodsSetupData, PostStripePaymentMethodsSetupError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Create a Stripe SetupIntent for adding a payment method
     * @description Creates a Stripe SetupIntent that allows users to securely add payment methods to their account. The SetupIntent provides a client secret that can be used with Stripe's frontend SDKs to collect payment method details.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const postStripePaymentMethodsSetupPendingMutationVariables = qraft.v1Service.postStripePaymentMethodsSetup.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const postStripePaymentMethodsSetupMutationData = qraft.v1Service.postStripePaymentMethodsSetup.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        PostStripePaymentMethodsSetupData,
        PostStripePaymentMethodsSetupError | Error,
        MutationVariables<PostStripePaymentMethodsSetupBody, PostStripePaymentMethodsSetupParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<
            PostStripePaymentMethodsSetupBody,
            PostStripePaymentMethodsSetupData,
            PostStripePaymentMethodsSetupParameters,
            PostStripePaymentMethodsSetupError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PostStripePaymentMethodsSetupSchema,
            PostStripePaymentMethodsSetupBody,
            PostStripePaymentMethodsSetupData,
            PostStripePaymentMethodsSetupParameters,
            PostStripePaymentMethodsSetupError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          PostStripePaymentMethodsSetupData,
          PostStripePaymentMethodsSetupError | Error,
          MutationVariables<PostStripePaymentMethodsSetupBody, PostStripePaymentMethodsSetupParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: PostStripePaymentMethodsSetupSchema;
    types: {
      parameters: PostStripePaymentMethodsSetupParameters;
      data: PostStripePaymentMethodsSetupData;
      error: PostStripePaymentMethodsSetupError;
      body: PostStripePaymentMethodsSetupBody;
    };
  };
  /** @summary Marks a payment method as the default. */
  postStripePaymentMethodsDefault: {
    /** @summary Marks a payment method as the default. */
    getMutationKey(
      parameters: DeepReadonly<PostStripePaymentMethodsDefaultParameters> | void
    ): ServiceOperationMutationKey<PostStripePaymentMethodsDefaultSchema, PostStripePaymentMethodsDefaultParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Marks a payment method as the default.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStripePaymentMethodsDefault.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStripePaymentMethodsDefault.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends PostStripePaymentMethodsDefaultBody, TContext = unknown>(
      parameters: DeepReadonly<PostStripePaymentMethodsDefaultParameters>,
      options?: ServiceOperationUseMutationOptions<
        PostStripePaymentMethodsDefaultSchema,
        PostStripePaymentMethodsDefaultData,
        PostStripePaymentMethodsDefaultParameters,
        TVariables,
        PostStripePaymentMethodsDefaultError | Error,
        TContext
      >
    ): UseMutationResult<PostStripePaymentMethodsDefaultData, PostStripePaymentMethodsDefaultError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Marks a payment method as the default.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStripePaymentMethodsDefault.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStripePaymentMethodsDefault.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PostStripePaymentMethodsDefaultBody, PostStripePaymentMethodsDefaultParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PostStripePaymentMethodsDefaultSchema,
        PostStripePaymentMethodsDefaultData,
        PostStripePaymentMethodsDefaultParameters,
        TVariables,
        PostStripePaymentMethodsDefaultError | Error,
        TContext
      >
    ): UseMutationResult<PostStripePaymentMethodsDefaultData, PostStripePaymentMethodsDefaultError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Marks a payment method as the default.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const postStripePaymentMethodsDefaultTotal = qraft.v1Service.postStripePaymentMethodsDefault.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const postStripePaymentMethodsDefaultTotal = qraft.v1Service.postStripePaymentMethodsDefault.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<
            PostStripePaymentMethodsDefaultBody,
            PostStripePaymentMethodsDefaultData,
            PostStripePaymentMethodsDefaultParameters,
            PostStripePaymentMethodsDefaultError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PostStripePaymentMethodsDefaultSchema,
            PostStripePaymentMethodsDefaultBody,
            PostStripePaymentMethodsDefaultData,
            PostStripePaymentMethodsDefaultParameters,
            PostStripePaymentMethodsDefaultError | Error,
            TContext
          >
    ): number;
    /** @summary Marks a payment method as the default. */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<
            PostStripePaymentMethodsDefaultBody,
            PostStripePaymentMethodsDefaultData,
            PostStripePaymentMethodsDefaultParameters,
            PostStripePaymentMethodsDefaultError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PostStripePaymentMethodsDefaultSchema,
            PostStripePaymentMethodsDefaultBody,
            PostStripePaymentMethodsDefaultData,
            PostStripePaymentMethodsDefaultParameters,
            PostStripePaymentMethodsDefaultError | Error,
            TContext
          >
    ): number;
    /** @summary Marks a payment method as the default. */
    (
      options: ServiceOperationMutationFnOptions<PostStripePaymentMethodsDefaultBody, PostStripePaymentMethodsDefaultParameters>,
      client?: (
        schema: PostStripePaymentMethodsDefaultSchema,
        options: ServiceOperationMutationFnOptions<PostStripePaymentMethodsDefaultBody, PostStripePaymentMethodsDefaultParameters>
      ) => Promise<RequestFnResponse<PostStripePaymentMethodsDefaultData, PostStripePaymentMethodsDefaultError>>
    ): Promise<RequestFnResponse<PostStripePaymentMethodsDefaultData, PostStripePaymentMethodsDefaultError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Marks a payment method as the default.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const postStripePaymentMethodsDefaultPendingMutationVariables = qraft.v1Service.postStripePaymentMethodsDefault.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const postStripePaymentMethodsDefaultMutationData = qraft.v1Service.postStripePaymentMethodsDefault.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        PostStripePaymentMethodsDefaultData,
        PostStripePaymentMethodsDefaultError | Error,
        MutationVariables<PostStripePaymentMethodsDefaultBody, PostStripePaymentMethodsDefaultParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<
            PostStripePaymentMethodsDefaultBody,
            PostStripePaymentMethodsDefaultData,
            PostStripePaymentMethodsDefaultParameters,
            PostStripePaymentMethodsDefaultError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PostStripePaymentMethodsDefaultSchema,
            PostStripePaymentMethodsDefaultBody,
            PostStripePaymentMethodsDefaultData,
            PostStripePaymentMethodsDefaultParameters,
            PostStripePaymentMethodsDefaultError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          PostStripePaymentMethodsDefaultData,
          PostStripePaymentMethodsDefaultError | Error,
          MutationVariables<PostStripePaymentMethodsDefaultBody, PostStripePaymentMethodsDefaultParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: PostStripePaymentMethodsDefaultSchema;
    types: {
      parameters: PostStripePaymentMethodsDefaultParameters;
      data: PostStripePaymentMethodsDefaultData;
      error: PostStripePaymentMethodsDefaultError;
      body: PostStripePaymentMethodsDefaultBody;
    };
  };
  /**
   * @summary Get the default payment method for the current user
   * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
   */
  getStripePaymentMethodsDefault: {
    /**
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripePaymentMethodsDefaultSchema,
            GetStripePaymentMethodsDefaultData,
            TInfinite,
            GetStripePaymentMethodsDefaultParameters,
            GetStripePaymentMethodsDefaultError
          >
        | QueryFiltersByQueryKey<
            GetStripePaymentMethodsDefaultSchema,
            GetStripePaymentMethodsDefaultData,
            TInfinite,
            GetStripePaymentMethodsDefaultParameters,
            GetStripePaymentMethodsDefaultError
          >,
      options?: CancelOptions
    ): Promise<void>;
    /**
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     */
    getQueryKey(
      parameters: DeepReadonly<GetStripePaymentMethodsDefaultParameters> | void
    ): ServiceOperationQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getStripePaymentMethodsDefault.useQuery()
     * ```
     */
    useQuery<TData = GetStripePaymentMethodsDefaultData>(
      parameters:
        | ServiceOperationQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>
        | (DeepReadonly<GetStripePaymentMethodsDefaultParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetStripePaymentMethodsDefaultData,
          GetStripePaymentMethodsDefaultError,
          TData,
          ServiceOperationQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetStripePaymentMethodsDefaultError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getStripePaymentMethodsDefault.useQuery()
     * ```
     */
    useQuery<TData = GetStripePaymentMethodsDefaultData>(
      parameters:
        | ServiceOperationQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>
        | (DeepReadonly<GetStripePaymentMethodsDefaultParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetStripePaymentMethodsDefaultData,
          GetStripePaymentMethodsDefaultError,
          TData,
          ServiceOperationQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetStripePaymentMethodsDefaultError | Error>;
    /**
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     */
    fetchInfiniteQuery<TPageParam extends GetStripePaymentMethodsDefaultParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetStripePaymentMethodsDefaultSchema,
        GetStripePaymentMethodsDefaultData,
        GetStripePaymentMethodsDefaultParameters,
        DeepReadonly<TPageParam>,
        GetStripePaymentMethodsDefaultError
      > | void
    ): Promise<OperationInfiniteData<GetStripePaymentMethodsDefaultData, GetStripePaymentMethodsDefaultParameters>>;
    /**
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     */
    prefetchInfiniteQuery<TPageParam extends GetStripePaymentMethodsDefaultParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetStripePaymentMethodsDefaultSchema,
        GetStripePaymentMethodsDefaultData,
        GetStripePaymentMethodsDefaultParameters,
        DeepReadonly<TPageParam>,
        GetStripePaymentMethodsDefaultError
      > | void
    ): Promise<void>;
    /**
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     */
    ensureInfiniteQueryData<TPageParam extends GetStripePaymentMethodsDefaultParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetStripePaymentMethodsDefaultSchema,
        GetStripePaymentMethodsDefaultData,
        GetStripePaymentMethodsDefaultParameters,
        DeepReadonly<TPageParam>,
        GetStripePaymentMethodsDefaultError
      > | void
    ): Promise<OperationInfiniteData<GetStripePaymentMethodsDefaultData, GetStripePaymentMethodsDefaultParameters>>;
    /**
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetStripePaymentMethodsDefaultSchema,
        GetStripePaymentMethodsDefaultData,
        GetStripePaymentMethodsDefaultParameters,
        GetStripePaymentMethodsDefaultError
      > | void
    ): Promise<GetStripePaymentMethodsDefaultData>;
    /**
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetStripePaymentMethodsDefaultSchema,
        GetStripePaymentMethodsDefaultData,
        GetStripePaymentMethodsDefaultParameters,
        GetStripePaymentMethodsDefaultError
      > | void
    ): Promise<void>;
    /**
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetStripePaymentMethodsDefaultSchema,
        GetStripePaymentMethodsDefaultData,
        GetStripePaymentMethodsDefaultParameters,
        GetStripePaymentMethodsDefaultError
      > | void
    ): Promise<GetStripePaymentMethodsDefaultData>;
    /**
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     */
    getInfiniteQueryData(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>
        | (DeepReadonly<GetStripePaymentMethodsDefaultParameters> | void)
    ): OperationInfiniteData<GetStripePaymentMethodsDefaultData, GetStripePaymentMethodsDefaultParameters> | undefined;
    /**
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripePaymentMethodsDefaultSchema,
            GetStripePaymentMethodsDefaultData,
            TInfinite,
            GetStripePaymentMethodsDefaultParameters,
            GetStripePaymentMethodsDefaultError
          >
        | QueryFiltersByQueryKey<
            GetStripePaymentMethodsDefaultSchema,
            GetStripePaymentMethodsDefaultData,
            TInfinite,
            GetStripePaymentMethodsDefaultParameters,
            GetStripePaymentMethodsDefaultError
          >
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>,
            data: NoInfer<OperationInfiniteData<GetStripePaymentMethodsDefaultData, GetStripePaymentMethodsDefaultParameters>> | undefined
          ]
        >
      : Array<
          [
            queryKey: ServiceOperationQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>,
            data: GetStripePaymentMethodsDefaultData | undefined
          ]
        >;
    /**
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     */
    getQueryData(
      parameters:
        | ServiceOperationQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>
        | (DeepReadonly<GetStripePaymentMethodsDefaultParameters> | void)
    ): GetStripePaymentMethodsDefaultData | undefined;
    /**
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     */
    getQueryState(
      parameters:
        | ServiceOperationQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>
        | (DeepReadonly<GetStripePaymentMethodsDefaultParameters> | void)
    ): QueryState<GetStripePaymentMethodsDefaultData, GetStripePaymentMethodsDefaultError> | undefined;
    /**
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     */
    getInfiniteQueryState(
      parameters:
        | DeepReadonly<GetStripePaymentMethodsDefaultParameters>
        | ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>
        | void
    ):
      | QueryState<OperationInfiniteData<GetStripePaymentMethodsDefaultData, GetStripePaymentMethodsDefaultParameters>, GetStripePaymentMethodsDefaultError>
      | undefined;
    /**
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<
        GetStripePaymentMethodsDefaultSchema,
        GetStripePaymentMethodsDefaultData,
        TInfinite,
        GetStripePaymentMethodsDefaultParameters,
        GetStripePaymentMethodsDefaultError
      >,
      options?: InvalidateOptions
    ): Promise<void>;
    /**
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripePaymentMethodsDefaultSchema,
            GetStripePaymentMethodsDefaultData,
            TInfinite,
            GetStripePaymentMethodsDefaultParameters,
            GetStripePaymentMethodsDefaultError
          >
        | QueryFiltersByQueryKey<
            GetStripePaymentMethodsDefaultSchema,
            GetStripePaymentMethodsDefaultData,
            TInfinite,
            GetStripePaymentMethodsDefaultParameters,
            GetStripePaymentMethodsDefaultError
          >
    ): number;
    /**
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetStripePaymentMethodsDefaultParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetStripePaymentMethodsDefaultSchema,
        options: {
          parameters: GetStripePaymentMethodsDefaultParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetStripePaymentMethodsDefaultData, GetStripePaymentMethodsDefaultError>>
    ): Promise<RequestFnResponse<GetStripePaymentMethodsDefaultData, GetStripePaymentMethodsDefaultError>>;
    /**
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripePaymentMethodsDefaultSchema,
            GetStripePaymentMethodsDefaultData,
            TInfinite,
            GetStripePaymentMethodsDefaultParameters,
            GetStripePaymentMethodsDefaultError
          >
        | QueryFiltersByQueryKey<
            GetStripePaymentMethodsDefaultSchema,
            GetStripePaymentMethodsDefaultData,
            TInfinite,
            GetStripePaymentMethodsDefaultParameters,
            GetStripePaymentMethodsDefaultError
          >,
      options?: RefetchOptions
    ): Promise<void>;
    /**
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripePaymentMethodsDefaultSchema,
            GetStripePaymentMethodsDefaultData,
            TInfinite,
            GetStripePaymentMethodsDefaultParameters,
            GetStripePaymentMethodsDefaultError
          >
        | QueryFiltersByQueryKey<
            GetStripePaymentMethodsDefaultSchema,
            GetStripePaymentMethodsDefaultData,
            TInfinite,
            GetStripePaymentMethodsDefaultParameters,
            GetStripePaymentMethodsDefaultError
          >
    ): void;
    /**
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripePaymentMethodsDefaultSchema,
            GetStripePaymentMethodsDefaultData,
            TInfinite,
            GetStripePaymentMethodsDefaultParameters,
            GetStripePaymentMethodsDefaultError
          >
        | QueryFiltersByQueryKey<
            GetStripePaymentMethodsDefaultSchema,
            GetStripePaymentMethodsDefaultData,
            TInfinite,
            GetStripePaymentMethodsDefaultParameters,
            GetStripePaymentMethodsDefaultError
          >,
      options?: ResetOptions
    ): Promise<void>;
    /**
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     */
    setInfiniteQueryData(
      parameters:
        | (DeepReadonly<GetStripePaymentMethodsDefaultParameters> | undefined)
        | ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetStripePaymentMethodsDefaultData, GetStripePaymentMethodsDefaultParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetStripePaymentMethodsDefaultData, GetStripePaymentMethodsDefaultParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetStripePaymentMethodsDefaultData, GetStripePaymentMethodsDefaultParameters> | undefined;
    /**
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<
            GetStripePaymentMethodsDefaultSchema,
            GetStripePaymentMethodsDefaultData,
            TInfinite,
            GetStripePaymentMethodsDefaultParameters,
            GetStripePaymentMethodsDefaultError
          >
        | QueryFiltersByQueryKey<
            GetStripePaymentMethodsDefaultSchema,
            GetStripePaymentMethodsDefaultData,
            TInfinite,
            GetStripePaymentMethodsDefaultParameters,
            GetStripePaymentMethodsDefaultError
          >,
      updater: Updater<NoInfer<GetStripePaymentMethodsDefaultData> | undefined, NoInfer<GetStripePaymentMethodsDefaultData> | undefined>,
      options?: SetDataOptions
    ): Array<GetStripePaymentMethodsDefaultData | undefined>;
    /**
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     */
    setQueryData(
      parameters:
        | (DeepReadonly<GetStripePaymentMethodsDefaultParameters> | undefined)
        | ServiceOperationQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>,
      updater: Updater<NoInfer<GetStripePaymentMethodsDefaultData> | undefined, NoInfer<DeepReadonly<GetStripePaymentMethodsDefaultData>> | undefined>,
      options?: SetDataOptions
    ): GetStripePaymentMethodsDefaultData | undefined;
    /**
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetStripePaymentMethodsDefaultParameters> | void
    ): ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getStripePaymentMethodsDefault.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetStripePaymentMethodsDefaultParameters,
      TQueryFnData = GetStripePaymentMethodsDefaultData,
      TData = OperationInfiniteData<TQueryFnData, GetStripePaymentMethodsDefaultParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>
        | (DeepReadonly<GetStripePaymentMethodsDefaultParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetStripePaymentMethodsDefaultError,
          TData,
          ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetStripePaymentMethodsDefaultError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getStripePaymentMethodsDefault.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetStripePaymentMethodsDefaultParameters,
      TQueryFnData = GetStripePaymentMethodsDefaultData,
      TData = OperationInfiniteData<TQueryFnData, GetStripePaymentMethodsDefaultParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>
        | (DeepReadonly<GetStripePaymentMethodsDefaultParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetStripePaymentMethodsDefaultError,
          TData,
          ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetStripePaymentMethodsDefaultData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetStripePaymentMethodsDefaultError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getStripePaymentMethodsDefaultTotal = qraft.v1Service.getStripePaymentMethodsDefault.useIsFetching()
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripePaymentMethodsDefaultSchema,
            GetStripePaymentMethodsDefaultData,
            TInfinite,
            GetStripePaymentMethodsDefaultParameters,
            GetStripePaymentMethodsDefaultError
          >
        | QueryFiltersByQueryKey<
            GetStripePaymentMethodsDefaultSchema,
            GetStripePaymentMethodsDefaultData,
            TInfinite,
            GetStripePaymentMethodsDefaultParameters,
            GetStripePaymentMethodsDefaultError
          >
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getStripePaymentMethodsDefaultResults = qraft.v1Service.getStripePaymentMethodsDefault.useQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getStripePaymentMethodsDefaultResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getStripePaymentMethodsDefaultCombinedResults = qraft.v1Service.getStripePaymentMethodsDefault.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getStripePaymentMethodsDefaultCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<
          GetStripePaymentMethodsDefaultSchema,
          GetStripePaymentMethodsDefaultParameters,
          GetStripePaymentMethodsDefaultData,
          GetStripePaymentMethodsDefaultError
        >
      >,
      TCombinedResult = Array<UseQueryResult<GetStripePaymentMethodsDefaultData, GetStripePaymentMethodsDefaultError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetStripePaymentMethodsDefaultData, GetStripePaymentMethodsDefaultError>>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     */
    getQueryKey(
      parameters: DeepReadonly<GetStripePaymentMethodsDefaultParameters> | void
    ): ServiceOperationQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getStripePaymentMethodsDefault.useQuery()
     * ```
     */
    useQuery<TData = GetStripePaymentMethodsDefaultData>(
      parameters:
        | ServiceOperationQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>
        | (DeepReadonly<GetStripePaymentMethodsDefaultParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetStripePaymentMethodsDefaultData,
          GetStripePaymentMethodsDefaultError,
          TData,
          ServiceOperationQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetStripePaymentMethodsDefaultError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getStripePaymentMethodsDefault.useQuery()
     * ```
     */
    useQuery<TData = GetStripePaymentMethodsDefaultData>(
      parameters:
        | ServiceOperationQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>
        | (DeepReadonly<GetStripePaymentMethodsDefaultParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetStripePaymentMethodsDefaultData,
          GetStripePaymentMethodsDefaultError,
          TData,
          ServiceOperationQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetStripePaymentMethodsDefaultError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getStripePaymentMethodsDefault.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetStripePaymentMethodsDefaultParameters, TData = GetStripePaymentMethodsDefaultData>(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>
        | (DeepReadonly<GetStripePaymentMethodsDefaultParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetStripePaymentMethodsDefaultData,
          GetStripePaymentMethodsDefaultError,
          OperationInfiniteData<TData, GetStripePaymentMethodsDefaultParameters>,
          GetStripePaymentMethodsDefaultData,
          ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetStripePaymentMethodsDefaultData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetStripePaymentMethodsDefaultParameters>, GetStripePaymentMethodsDefaultError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getStripePaymentMethodsDefaultData = qraft.v1Service.getStripePaymentMethodsDefault.useSuspenseQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getStripePaymentMethodsDefaultResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getStripePaymentMethodsDefaultCombinedData = qraft.v1Service.getStripePaymentMethodsDefault.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getStripePaymentMethodsDefaultCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<
          GetStripePaymentMethodsDefaultSchema,
          GetStripePaymentMethodsDefaultParameters,
          GetStripePaymentMethodsDefaultData,
          GetStripePaymentMethodsDefaultError
        >
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetStripePaymentMethodsDefaultData, GetStripePaymentMethodsDefaultError>>
    >(options: {
      queries: T;
      combine?: (
        results: Array<WithOptional<UseSuspenseQueryResult<GetStripePaymentMethodsDefaultData, GetStripePaymentMethodsDefaultError>, "data">>
      ) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get the default payment method for the current user
     * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getStripePaymentMethodsDefault.useSuspenseQuery()
     * ```
     */
    useSuspenseQuery<TData = GetStripePaymentMethodsDefaultData>(
      parameters:
        | ServiceOperationQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>
        | (DeepReadonly<GetStripePaymentMethodsDefaultParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<
          GetStripePaymentMethodsDefaultData,
          GetStripePaymentMethodsDefaultError,
          TData,
          ServiceOperationQueryKey<GetStripePaymentMethodsDefaultSchema, GetStripePaymentMethodsDefaultParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetStripePaymentMethodsDefaultError | Error>;
    schema: GetStripePaymentMethodsDefaultSchema;
    types: {
      parameters: GetStripePaymentMethodsDefaultParameters;
      data: GetStripePaymentMethodsDefaultData;
      error: GetStripePaymentMethodsDefaultError;
    };
  };
  /**
   * @summary Get all payment methods for the current user
   * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
   */
  getStripePaymentMethods: {
    /**
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripePaymentMethodsSchema,
            GetStripePaymentMethodsData,
            TInfinite,
            GetStripePaymentMethodsParameters,
            GetStripePaymentMethodsError
          >
        | QueryFiltersByQueryKey<
            GetStripePaymentMethodsSchema,
            GetStripePaymentMethodsData,
            TInfinite,
            GetStripePaymentMethodsParameters,
            GetStripePaymentMethodsError
          >,
      options?: CancelOptions
    ): Promise<void>;
    /**
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     */
    getQueryKey(
      parameters: DeepReadonly<GetStripePaymentMethodsParameters> | void
    ): ServiceOperationQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getStripePaymentMethods.useQuery()
     * ```
     */
    useQuery<TData = GetStripePaymentMethodsData>(
      parameters:
        | ServiceOperationQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>
        | (DeepReadonly<GetStripePaymentMethodsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetStripePaymentMethodsData,
          GetStripePaymentMethodsError,
          TData,
          ServiceOperationQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetStripePaymentMethodsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getStripePaymentMethods.useQuery()
     * ```
     */
    useQuery<TData = GetStripePaymentMethodsData>(
      parameters:
        | ServiceOperationQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>
        | (DeepReadonly<GetStripePaymentMethodsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetStripePaymentMethodsData,
          GetStripePaymentMethodsError,
          TData,
          ServiceOperationQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetStripePaymentMethodsError | Error>;
    /**
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     */
    fetchInfiniteQuery<TPageParam extends GetStripePaymentMethodsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetStripePaymentMethodsSchema,
        GetStripePaymentMethodsData,
        GetStripePaymentMethodsParameters,
        DeepReadonly<TPageParam>,
        GetStripePaymentMethodsError
      > | void
    ): Promise<OperationInfiniteData<GetStripePaymentMethodsData, GetStripePaymentMethodsParameters>>;
    /**
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     */
    prefetchInfiniteQuery<TPageParam extends GetStripePaymentMethodsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetStripePaymentMethodsSchema,
        GetStripePaymentMethodsData,
        GetStripePaymentMethodsParameters,
        DeepReadonly<TPageParam>,
        GetStripePaymentMethodsError
      > | void
    ): Promise<void>;
    /**
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     */
    ensureInfiniteQueryData<TPageParam extends GetStripePaymentMethodsParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetStripePaymentMethodsSchema,
        GetStripePaymentMethodsData,
        GetStripePaymentMethodsParameters,
        DeepReadonly<TPageParam>,
        GetStripePaymentMethodsError
      > | void
    ): Promise<OperationInfiniteData<GetStripePaymentMethodsData, GetStripePaymentMethodsParameters>>;
    /**
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetStripePaymentMethodsSchema,
        GetStripePaymentMethodsData,
        GetStripePaymentMethodsParameters,
        GetStripePaymentMethodsError
      > | void
    ): Promise<GetStripePaymentMethodsData>;
    /**
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetStripePaymentMethodsSchema,
        GetStripePaymentMethodsData,
        GetStripePaymentMethodsParameters,
        GetStripePaymentMethodsError
      > | void
    ): Promise<void>;
    /**
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetStripePaymentMethodsSchema,
        GetStripePaymentMethodsData,
        GetStripePaymentMethodsParameters,
        GetStripePaymentMethodsError
      > | void
    ): Promise<GetStripePaymentMethodsData>;
    /**
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     */
    getInfiniteQueryData(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>
        | (DeepReadonly<GetStripePaymentMethodsParameters> | void)
    ): OperationInfiniteData<GetStripePaymentMethodsData, GetStripePaymentMethodsParameters> | undefined;
    /**
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripePaymentMethodsSchema,
            GetStripePaymentMethodsData,
            TInfinite,
            GetStripePaymentMethodsParameters,
            GetStripePaymentMethodsError
          >
        | QueryFiltersByQueryKey<
            GetStripePaymentMethodsSchema,
            GetStripePaymentMethodsData,
            TInfinite,
            GetStripePaymentMethodsParameters,
            GetStripePaymentMethodsError
          >
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>,
            data: NoInfer<OperationInfiniteData<GetStripePaymentMethodsData, GetStripePaymentMethodsParameters>> | undefined
          ]
        >
      : Array<
          [queryKey: ServiceOperationQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>, data: GetStripePaymentMethodsData | undefined]
        >;
    /**
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     */
    getQueryData(
      parameters:
        | ServiceOperationQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>
        | (DeepReadonly<GetStripePaymentMethodsParameters> | void)
    ): GetStripePaymentMethodsData | undefined;
    /**
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     */
    getQueryState(
      parameters:
        | ServiceOperationQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>
        | (DeepReadonly<GetStripePaymentMethodsParameters> | void)
    ): QueryState<GetStripePaymentMethodsData, GetStripePaymentMethodsError> | undefined;
    /**
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     */
    getInfiniteQueryState(
      parameters:
        | DeepReadonly<GetStripePaymentMethodsParameters>
        | ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>
        | void
    ): QueryState<OperationInfiniteData<GetStripePaymentMethodsData, GetStripePaymentMethodsParameters>, GetStripePaymentMethodsError> | undefined;
    /**
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<
        GetStripePaymentMethodsSchema,
        GetStripePaymentMethodsData,
        TInfinite,
        GetStripePaymentMethodsParameters,
        GetStripePaymentMethodsError
      >,
      options?: InvalidateOptions
    ): Promise<void>;
    /**
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripePaymentMethodsSchema,
            GetStripePaymentMethodsData,
            TInfinite,
            GetStripePaymentMethodsParameters,
            GetStripePaymentMethodsError
          >
        | QueryFiltersByQueryKey<
            GetStripePaymentMethodsSchema,
            GetStripePaymentMethodsData,
            TInfinite,
            GetStripePaymentMethodsParameters,
            GetStripePaymentMethodsError
          >
    ): number;
    /**
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetStripePaymentMethodsParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetStripePaymentMethodsSchema,
        options: {
          parameters: GetStripePaymentMethodsParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetStripePaymentMethodsData, GetStripePaymentMethodsError>>
    ): Promise<RequestFnResponse<GetStripePaymentMethodsData, GetStripePaymentMethodsError>>;
    /**
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripePaymentMethodsSchema,
            GetStripePaymentMethodsData,
            TInfinite,
            GetStripePaymentMethodsParameters,
            GetStripePaymentMethodsError
          >
        | QueryFiltersByQueryKey<
            GetStripePaymentMethodsSchema,
            GetStripePaymentMethodsData,
            TInfinite,
            GetStripePaymentMethodsParameters,
            GetStripePaymentMethodsError
          >,
      options?: RefetchOptions
    ): Promise<void>;
    /**
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripePaymentMethodsSchema,
            GetStripePaymentMethodsData,
            TInfinite,
            GetStripePaymentMethodsParameters,
            GetStripePaymentMethodsError
          >
        | QueryFiltersByQueryKey<
            GetStripePaymentMethodsSchema,
            GetStripePaymentMethodsData,
            TInfinite,
            GetStripePaymentMethodsParameters,
            GetStripePaymentMethodsError
          >
    ): void;
    /**
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripePaymentMethodsSchema,
            GetStripePaymentMethodsData,
            TInfinite,
            GetStripePaymentMethodsParameters,
            GetStripePaymentMethodsError
          >
        | QueryFiltersByQueryKey<
            GetStripePaymentMethodsSchema,
            GetStripePaymentMethodsData,
            TInfinite,
            GetStripePaymentMethodsParameters,
            GetStripePaymentMethodsError
          >,
      options?: ResetOptions
    ): Promise<void>;
    /**
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     */
    setInfiniteQueryData(
      parameters:
        | (DeepReadonly<GetStripePaymentMethodsParameters> | undefined)
        | ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetStripePaymentMethodsData, GetStripePaymentMethodsParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetStripePaymentMethodsData, GetStripePaymentMethodsParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetStripePaymentMethodsData, GetStripePaymentMethodsParameters> | undefined;
    /**
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<
            GetStripePaymentMethodsSchema,
            GetStripePaymentMethodsData,
            TInfinite,
            GetStripePaymentMethodsParameters,
            GetStripePaymentMethodsError
          >
        | QueryFiltersByQueryKey<
            GetStripePaymentMethodsSchema,
            GetStripePaymentMethodsData,
            TInfinite,
            GetStripePaymentMethodsParameters,
            GetStripePaymentMethodsError
          >,
      updater: Updater<NoInfer<GetStripePaymentMethodsData> | undefined, NoInfer<GetStripePaymentMethodsData> | undefined>,
      options?: SetDataOptions
    ): Array<GetStripePaymentMethodsData | undefined>;
    /**
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     */
    setQueryData(
      parameters:
        | (DeepReadonly<GetStripePaymentMethodsParameters> | undefined)
        | ServiceOperationQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>,
      updater: Updater<NoInfer<GetStripePaymentMethodsData> | undefined, NoInfer<DeepReadonly<GetStripePaymentMethodsData>> | undefined>,
      options?: SetDataOptions
    ): GetStripePaymentMethodsData | undefined;
    /**
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetStripePaymentMethodsParameters> | void
    ): ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getStripePaymentMethods.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetStripePaymentMethodsParameters,
      TQueryFnData = GetStripePaymentMethodsData,
      TData = OperationInfiniteData<TQueryFnData, GetStripePaymentMethodsParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>
        | (DeepReadonly<GetStripePaymentMethodsParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetStripePaymentMethodsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetStripePaymentMethodsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getStripePaymentMethods.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetStripePaymentMethodsParameters,
      TQueryFnData = GetStripePaymentMethodsData,
      TData = OperationInfiniteData<TQueryFnData, GetStripePaymentMethodsParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>
        | (DeepReadonly<GetStripePaymentMethodsParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetStripePaymentMethodsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetStripePaymentMethodsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetStripePaymentMethodsError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getStripePaymentMethodsTotal = qraft.v1Service.getStripePaymentMethods.useIsFetching()
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripePaymentMethodsSchema,
            GetStripePaymentMethodsData,
            TInfinite,
            GetStripePaymentMethodsParameters,
            GetStripePaymentMethodsError
          >
        | QueryFiltersByQueryKey<
            GetStripePaymentMethodsSchema,
            GetStripePaymentMethodsData,
            TInfinite,
            GetStripePaymentMethodsParameters,
            GetStripePaymentMethodsError
          >
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getStripePaymentMethodsResults = qraft.v1Service.getStripePaymentMethods.useQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getStripePaymentMethodsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getStripePaymentMethodsCombinedResults = qraft.v1Service.getStripePaymentMethods.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getStripePaymentMethodsCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<
          GetStripePaymentMethodsSchema,
          GetStripePaymentMethodsParameters,
          GetStripePaymentMethodsData,
          GetStripePaymentMethodsError
        >
      >,
      TCombinedResult = Array<UseQueryResult<GetStripePaymentMethodsData, GetStripePaymentMethodsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetStripePaymentMethodsData, GetStripePaymentMethodsError>>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     */
    getQueryKey(
      parameters: DeepReadonly<GetStripePaymentMethodsParameters> | void
    ): ServiceOperationQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getStripePaymentMethods.useQuery()
     * ```
     */
    useQuery<TData = GetStripePaymentMethodsData>(
      parameters:
        | ServiceOperationQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>
        | (DeepReadonly<GetStripePaymentMethodsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetStripePaymentMethodsData,
          GetStripePaymentMethodsError,
          TData,
          ServiceOperationQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetStripePaymentMethodsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getStripePaymentMethods.useQuery()
     * ```
     */
    useQuery<TData = GetStripePaymentMethodsData>(
      parameters:
        | ServiceOperationQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>
        | (DeepReadonly<GetStripePaymentMethodsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetStripePaymentMethodsData,
          GetStripePaymentMethodsError,
          TData,
          ServiceOperationQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetStripePaymentMethodsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getStripePaymentMethods.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetStripePaymentMethodsParameters, TData = GetStripePaymentMethodsData>(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>
        | (DeepReadonly<GetStripePaymentMethodsParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetStripePaymentMethodsData,
          GetStripePaymentMethodsError,
          OperationInfiniteData<TData, GetStripePaymentMethodsParameters>,
          GetStripePaymentMethodsData,
          ServiceOperationInfiniteQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetStripePaymentMethodsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetStripePaymentMethodsParameters>, GetStripePaymentMethodsError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getStripePaymentMethodsData = qraft.v1Service.getStripePaymentMethods.useSuspenseQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getStripePaymentMethodsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getStripePaymentMethodsCombinedData = qraft.v1Service.getStripePaymentMethods.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getStripePaymentMethodsCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<
          GetStripePaymentMethodsSchema,
          GetStripePaymentMethodsParameters,
          GetStripePaymentMethodsData,
          GetStripePaymentMethodsError
        >
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetStripePaymentMethodsData, GetStripePaymentMethodsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetStripePaymentMethodsData, GetStripePaymentMethodsError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get all payment methods for the current user
     * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getStripePaymentMethods.useSuspenseQuery()
     * ```
     */
    useSuspenseQuery<TData = GetStripePaymentMethodsData>(
      parameters:
        | ServiceOperationQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>
        | (DeepReadonly<GetStripePaymentMethodsParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<
          GetStripePaymentMethodsData,
          GetStripePaymentMethodsError,
          TData,
          ServiceOperationQueryKey<GetStripePaymentMethodsSchema, GetStripePaymentMethodsParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetStripePaymentMethodsError | Error>;
    schema: GetStripePaymentMethodsSchema;
    types: {
      parameters: GetStripePaymentMethodsParameters;
      data: GetStripePaymentMethodsData;
      error: GetStripePaymentMethodsError;
    };
  };
  /**
   * @summary Remove a payment method
   * @description Permanently removes a saved payment method from the user's account. This action cannot be undone.
   */
  deleteStripePaymentMethodsPaymentMethodId: {
    /**
     * @summary Remove a payment method
     * @description Permanently removes a saved payment method from the user's account. This action cannot be undone.
     */
    getMutationKey(
      parameters: DeepReadonly<DeleteStripePaymentMethodsPaymentMethodIdParameters> | void
    ): ServiceOperationMutationKey<DeleteStripePaymentMethodsPaymentMethodIdSchema, DeleteStripePaymentMethodsPaymentMethodIdParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Remove a payment method
     * @description Permanently removes a saved payment method from the user's account. This action cannot be undone.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteStripePaymentMethodsPaymentMethodId.useMutation({
     *     path: {
     *         paymentMethodId: paymentMethodId
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteStripePaymentMethodsPaymentMethodId.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         paymentMethodId: paymentMethodId
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends DeleteStripePaymentMethodsPaymentMethodIdBody, TContext = unknown>(
      parameters: DeepReadonly<DeleteStripePaymentMethodsPaymentMethodIdParameters>,
      options?: ServiceOperationUseMutationOptions<
        DeleteStripePaymentMethodsPaymentMethodIdSchema,
        DeleteStripePaymentMethodsPaymentMethodIdData,
        DeleteStripePaymentMethodsPaymentMethodIdParameters,
        TVariables,
        DeleteStripePaymentMethodsPaymentMethodIdError | Error,
        TContext
      >
    ): UseMutationResult<DeleteStripePaymentMethodsPaymentMethodIdData, DeleteStripePaymentMethodsPaymentMethodIdError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Remove a payment method
     * @description Permanently removes a saved payment method from the user's account. This action cannot be undone.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteStripePaymentMethodsPaymentMethodId.useMutation({
     *     path: {
     *         paymentMethodId: paymentMethodId
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteStripePaymentMethodsPaymentMethodId.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         paymentMethodId: paymentMethodId
     *     }
     * });
     * ```
     */
    useMutation<
      TVariables extends MutationVariables<DeleteStripePaymentMethodsPaymentMethodIdBody, DeleteStripePaymentMethodsPaymentMethodIdParameters>,
      TContext = unknown
    >(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        DeleteStripePaymentMethodsPaymentMethodIdSchema,
        DeleteStripePaymentMethodsPaymentMethodIdData,
        DeleteStripePaymentMethodsPaymentMethodIdParameters,
        TVariables,
        DeleteStripePaymentMethodsPaymentMethodIdError | Error,
        TContext
      >
    ): UseMutationResult<DeleteStripePaymentMethodsPaymentMethodIdData, DeleteStripePaymentMethodsPaymentMethodIdError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Remove a payment method
     * @description Permanently removes a saved payment method from the user's account. This action cannot be undone.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const deleteStripePaymentMethodsPaymentMethodIdTotal = qraft.v1Service.deleteStripePaymentMethodsPaymentMethodId.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const deleteStripePaymentMethodsPaymentMethodIdTotal = qraft.v1Service.deleteStripePaymentMethodsPaymentMethodId.useIsMutating({
     *     parameters: {
     *         path: {
     *             paymentMethodId: paymentMethodId
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<
            DeleteStripePaymentMethodsPaymentMethodIdBody,
            DeleteStripePaymentMethodsPaymentMethodIdData,
            DeleteStripePaymentMethodsPaymentMethodIdParameters,
            DeleteStripePaymentMethodsPaymentMethodIdError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            DeleteStripePaymentMethodsPaymentMethodIdSchema,
            DeleteStripePaymentMethodsPaymentMethodIdBody,
            DeleteStripePaymentMethodsPaymentMethodIdData,
            DeleteStripePaymentMethodsPaymentMethodIdParameters,
            DeleteStripePaymentMethodsPaymentMethodIdError | Error,
            TContext
          >
    ): number;
    /**
     * @summary Remove a payment method
     * @description Permanently removes a saved payment method from the user's account. This action cannot be undone.
     */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<
            DeleteStripePaymentMethodsPaymentMethodIdBody,
            DeleteStripePaymentMethodsPaymentMethodIdData,
            DeleteStripePaymentMethodsPaymentMethodIdParameters,
            DeleteStripePaymentMethodsPaymentMethodIdError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            DeleteStripePaymentMethodsPaymentMethodIdSchema,
            DeleteStripePaymentMethodsPaymentMethodIdBody,
            DeleteStripePaymentMethodsPaymentMethodIdData,
            DeleteStripePaymentMethodsPaymentMethodIdParameters,
            DeleteStripePaymentMethodsPaymentMethodIdError | Error,
            TContext
          >
    ): number;
    /**
     * @summary Remove a payment method
     * @description Permanently removes a saved payment method from the user's account. This action cannot be undone.
     */
    (
      options: ServiceOperationMutationFnOptions<DeleteStripePaymentMethodsPaymentMethodIdBody, DeleteStripePaymentMethodsPaymentMethodIdParameters>,
      client?: (
        schema: DeleteStripePaymentMethodsPaymentMethodIdSchema,
        options: ServiceOperationMutationFnOptions<DeleteStripePaymentMethodsPaymentMethodIdBody, DeleteStripePaymentMethodsPaymentMethodIdParameters>
      ) => Promise<RequestFnResponse<DeleteStripePaymentMethodsPaymentMethodIdData, DeleteStripePaymentMethodsPaymentMethodIdError>>
    ): Promise<RequestFnResponse<DeleteStripePaymentMethodsPaymentMethodIdData, DeleteStripePaymentMethodsPaymentMethodIdError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Remove a payment method
     * @description Permanently removes a saved payment method from the user's account. This action cannot be undone.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const deleteStripePaymentMethodsPaymentMethodIdPendingMutationVariables = qraft.v1Service.deleteStripePaymentMethodsPaymentMethodId.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const deleteStripePaymentMethodsPaymentMethodIdMutationData = qraft.v1Service.deleteStripePaymentMethodsPaymentMethodId.useMutationState({
     *     filters: {
     *         parameters: {
     *             path: {
     *                 paymentMethodId: paymentMethodId
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        DeleteStripePaymentMethodsPaymentMethodIdData,
        DeleteStripePaymentMethodsPaymentMethodIdError | Error,
        MutationVariables<DeleteStripePaymentMethodsPaymentMethodIdBody, DeleteStripePaymentMethodsPaymentMethodIdParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<
            DeleteStripePaymentMethodsPaymentMethodIdBody,
            DeleteStripePaymentMethodsPaymentMethodIdData,
            DeleteStripePaymentMethodsPaymentMethodIdParameters,
            DeleteStripePaymentMethodsPaymentMethodIdError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            DeleteStripePaymentMethodsPaymentMethodIdSchema,
            DeleteStripePaymentMethodsPaymentMethodIdBody,
            DeleteStripePaymentMethodsPaymentMethodIdData,
            DeleteStripePaymentMethodsPaymentMethodIdParameters,
            DeleteStripePaymentMethodsPaymentMethodIdError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          DeleteStripePaymentMethodsPaymentMethodIdData,
          DeleteStripePaymentMethodsPaymentMethodIdError | Error,
          MutationVariables<DeleteStripePaymentMethodsPaymentMethodIdBody, DeleteStripePaymentMethodsPaymentMethodIdParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: DeleteStripePaymentMethodsPaymentMethodIdSchema;
    types: {
      parameters: DeleteStripePaymentMethodsPaymentMethodIdParameters;
      data: DeleteStripePaymentMethodsPaymentMethodIdData;
      error: DeleteStripePaymentMethodsPaymentMethodIdError;
      body: DeleteStripePaymentMethodsPaymentMethodIdBody;
    };
  };
  /**
   * @summary Validates a payment method after 3D Secure authentication
   * @description Completes the validation process for a payment method that required 3D Secure authentication. This endpoint should be called after the user completes the 3D Secure challenge.
   */
  postStripePaymentMethodsValidate: {
    /**
     * @summary Validates a payment method after 3D Secure authentication
     * @description Completes the validation process for a payment method that required 3D Secure authentication. This endpoint should be called after the user completes the 3D Secure challenge.
     */
    getMutationKey(
      parameters: DeepReadonly<PostStripePaymentMethodsValidateParameters> | void
    ): ServiceOperationMutationKey<PostStripePaymentMethodsValidateSchema, PostStripePaymentMethodsValidateParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Validates a payment method after 3D Secure authentication
     * @description Completes the validation process for a payment method that required 3D Secure authentication. This endpoint should be called after the user completes the 3D Secure challenge.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStripePaymentMethodsValidate.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStripePaymentMethodsValidate.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends PostStripePaymentMethodsValidateBody, TContext = unknown>(
      parameters: DeepReadonly<PostStripePaymentMethodsValidateParameters>,
      options?: ServiceOperationUseMutationOptions<
        PostStripePaymentMethodsValidateSchema,
        PostStripePaymentMethodsValidateData,
        PostStripePaymentMethodsValidateParameters,
        TVariables,
        PostStripePaymentMethodsValidateError | Error,
        TContext
      >
    ): UseMutationResult<PostStripePaymentMethodsValidateData, PostStripePaymentMethodsValidateError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Validates a payment method after 3D Secure authentication
     * @description Completes the validation process for a payment method that required 3D Secure authentication. This endpoint should be called after the user completes the 3D Secure challenge.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStripePaymentMethodsValidate.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStripePaymentMethodsValidate.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PostStripePaymentMethodsValidateBody, PostStripePaymentMethodsValidateParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PostStripePaymentMethodsValidateSchema,
        PostStripePaymentMethodsValidateData,
        PostStripePaymentMethodsValidateParameters,
        TVariables,
        PostStripePaymentMethodsValidateError | Error,
        TContext
      >
    ): UseMutationResult<PostStripePaymentMethodsValidateData, PostStripePaymentMethodsValidateError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Validates a payment method after 3D Secure authentication
     * @description Completes the validation process for a payment method that required 3D Secure authentication. This endpoint should be called after the user completes the 3D Secure challenge.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const postStripePaymentMethodsValidateTotal = qraft.v1Service.postStripePaymentMethodsValidate.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const postStripePaymentMethodsValidateTotal = qraft.v1Service.postStripePaymentMethodsValidate.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<
            PostStripePaymentMethodsValidateBody,
            PostStripePaymentMethodsValidateData,
            PostStripePaymentMethodsValidateParameters,
            PostStripePaymentMethodsValidateError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PostStripePaymentMethodsValidateSchema,
            PostStripePaymentMethodsValidateBody,
            PostStripePaymentMethodsValidateData,
            PostStripePaymentMethodsValidateParameters,
            PostStripePaymentMethodsValidateError | Error,
            TContext
          >
    ): number;
    /**
     * @summary Validates a payment method after 3D Secure authentication
     * @description Completes the validation process for a payment method that required 3D Secure authentication. This endpoint should be called after the user completes the 3D Secure challenge.
     */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<
            PostStripePaymentMethodsValidateBody,
            PostStripePaymentMethodsValidateData,
            PostStripePaymentMethodsValidateParameters,
            PostStripePaymentMethodsValidateError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PostStripePaymentMethodsValidateSchema,
            PostStripePaymentMethodsValidateBody,
            PostStripePaymentMethodsValidateData,
            PostStripePaymentMethodsValidateParameters,
            PostStripePaymentMethodsValidateError | Error,
            TContext
          >
    ): number;
    /**
     * @summary Validates a payment method after 3D Secure authentication
     * @description Completes the validation process for a payment method that required 3D Secure authentication. This endpoint should be called after the user completes the 3D Secure challenge.
     */
    (
      options: ServiceOperationMutationFnOptions<PostStripePaymentMethodsValidateBody, PostStripePaymentMethodsValidateParameters>,
      client?: (
        schema: PostStripePaymentMethodsValidateSchema,
        options: ServiceOperationMutationFnOptions<PostStripePaymentMethodsValidateBody, PostStripePaymentMethodsValidateParameters>
      ) => Promise<RequestFnResponse<PostStripePaymentMethodsValidateData, PostStripePaymentMethodsValidateError>>
    ): Promise<RequestFnResponse<PostStripePaymentMethodsValidateData, PostStripePaymentMethodsValidateError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Validates a payment method after 3D Secure authentication
     * @description Completes the validation process for a payment method that required 3D Secure authentication. This endpoint should be called after the user completes the 3D Secure challenge.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const postStripePaymentMethodsValidatePendingMutationVariables = qraft.v1Service.postStripePaymentMethodsValidate.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const postStripePaymentMethodsValidateMutationData = qraft.v1Service.postStripePaymentMethodsValidate.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        PostStripePaymentMethodsValidateData,
        PostStripePaymentMethodsValidateError | Error,
        MutationVariables<PostStripePaymentMethodsValidateBody, PostStripePaymentMethodsValidateParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<
            PostStripePaymentMethodsValidateBody,
            PostStripePaymentMethodsValidateData,
            PostStripePaymentMethodsValidateParameters,
            PostStripePaymentMethodsValidateError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PostStripePaymentMethodsValidateSchema,
            PostStripePaymentMethodsValidateBody,
            PostStripePaymentMethodsValidateData,
            PostStripePaymentMethodsValidateParameters,
            PostStripePaymentMethodsValidateError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          PostStripePaymentMethodsValidateData,
          PostStripePaymentMethodsValidateError | Error,
          MutationVariables<PostStripePaymentMethodsValidateBody, PostStripePaymentMethodsValidateParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: PostStripePaymentMethodsValidateSchema;
    types: {
      parameters: PostStripePaymentMethodsValidateParameters;
      data: PostStripePaymentMethodsValidateData;
      error: PostStripePaymentMethodsValidateError;
      body: PostStripePaymentMethodsValidateBody;
    };
  };
  /**
   * @summary Confirm a payment using a saved payment method
   * @description Processes a payment using a previously saved payment method. This endpoint handles wallet top-ups and may require 3D Secure authentication for certain payment methods or amounts.
   */
  postStripeTransactionsConfirm: {
    /**
     * @summary Confirm a payment using a saved payment method
     * @description Processes a payment using a previously saved payment method. This endpoint handles wallet top-ups and may require 3D Secure authentication for certain payment methods or amounts.
     */
    getMutationKey(
      parameters: DeepReadonly<PostStripeTransactionsConfirmParameters> | void
    ): ServiceOperationMutationKey<PostStripeTransactionsConfirmSchema, PostStripeTransactionsConfirmParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Confirm a payment using a saved payment method
     * @description Processes a payment using a previously saved payment method. This endpoint handles wallet top-ups and may require 3D Secure authentication for certain payment methods or amounts.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStripeTransactionsConfirm.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStripeTransactionsConfirm.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends PostStripeTransactionsConfirmBody, TContext = unknown>(
      parameters: DeepReadonly<PostStripeTransactionsConfirmParameters>,
      options?: ServiceOperationUseMutationOptions<
        PostStripeTransactionsConfirmSchema,
        PostStripeTransactionsConfirmData,
        PostStripeTransactionsConfirmParameters,
        TVariables,
        PostStripeTransactionsConfirmError | Error,
        TContext
      >
    ): UseMutationResult<PostStripeTransactionsConfirmData, PostStripeTransactionsConfirmError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Confirm a payment using a saved payment method
     * @description Processes a payment using a previously saved payment method. This endpoint handles wallet top-ups and may require 3D Secure authentication for certain payment methods or amounts.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStripeTransactionsConfirm.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postStripeTransactionsConfirm.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PostStripeTransactionsConfirmBody, PostStripeTransactionsConfirmParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PostStripeTransactionsConfirmSchema,
        PostStripeTransactionsConfirmData,
        PostStripeTransactionsConfirmParameters,
        TVariables,
        PostStripeTransactionsConfirmError | Error,
        TContext
      >
    ): UseMutationResult<PostStripeTransactionsConfirmData, PostStripeTransactionsConfirmError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Confirm a payment using a saved payment method
     * @description Processes a payment using a previously saved payment method. This endpoint handles wallet top-ups and may require 3D Secure authentication for certain payment methods or amounts.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const postStripeTransactionsConfirmTotal = qraft.v1Service.postStripeTransactionsConfirm.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const postStripeTransactionsConfirmTotal = qraft.v1Service.postStripeTransactionsConfirm.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<
            PostStripeTransactionsConfirmBody,
            PostStripeTransactionsConfirmData,
            PostStripeTransactionsConfirmParameters,
            PostStripeTransactionsConfirmError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PostStripeTransactionsConfirmSchema,
            PostStripeTransactionsConfirmBody,
            PostStripeTransactionsConfirmData,
            PostStripeTransactionsConfirmParameters,
            PostStripeTransactionsConfirmError | Error,
            TContext
          >
    ): number;
    /**
     * @summary Confirm a payment using a saved payment method
     * @description Processes a payment using a previously saved payment method. This endpoint handles wallet top-ups and may require 3D Secure authentication for certain payment methods or amounts.
     */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<
            PostStripeTransactionsConfirmBody,
            PostStripeTransactionsConfirmData,
            PostStripeTransactionsConfirmParameters,
            PostStripeTransactionsConfirmError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PostStripeTransactionsConfirmSchema,
            PostStripeTransactionsConfirmBody,
            PostStripeTransactionsConfirmData,
            PostStripeTransactionsConfirmParameters,
            PostStripeTransactionsConfirmError | Error,
            TContext
          >
    ): number;
    /**
     * @summary Confirm a payment using a saved payment method
     * @description Processes a payment using a previously saved payment method. This endpoint handles wallet top-ups and may require 3D Secure authentication for certain payment methods or amounts.
     */
    (
      options: ServiceOperationMutationFnOptions<PostStripeTransactionsConfirmBody, PostStripeTransactionsConfirmParameters>,
      client?: (
        schema: PostStripeTransactionsConfirmSchema,
        options: ServiceOperationMutationFnOptions<PostStripeTransactionsConfirmBody, PostStripeTransactionsConfirmParameters>
      ) => Promise<RequestFnResponse<PostStripeTransactionsConfirmData, PostStripeTransactionsConfirmError>>
    ): Promise<RequestFnResponse<PostStripeTransactionsConfirmData, PostStripeTransactionsConfirmError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Confirm a payment using a saved payment method
     * @description Processes a payment using a previously saved payment method. This endpoint handles wallet top-ups and may require 3D Secure authentication for certain payment methods or amounts.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const postStripeTransactionsConfirmPendingMutationVariables = qraft.v1Service.postStripeTransactionsConfirm.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const postStripeTransactionsConfirmMutationData = qraft.v1Service.postStripeTransactionsConfirm.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        PostStripeTransactionsConfirmData,
        PostStripeTransactionsConfirmError | Error,
        MutationVariables<PostStripeTransactionsConfirmBody, PostStripeTransactionsConfirmParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<
            PostStripeTransactionsConfirmBody,
            PostStripeTransactionsConfirmData,
            PostStripeTransactionsConfirmParameters,
            PostStripeTransactionsConfirmError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PostStripeTransactionsConfirmSchema,
            PostStripeTransactionsConfirmBody,
            PostStripeTransactionsConfirmData,
            PostStripeTransactionsConfirmParameters,
            PostStripeTransactionsConfirmError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          PostStripeTransactionsConfirmData,
          PostStripeTransactionsConfirmError | Error,
          MutationVariables<PostStripeTransactionsConfirmBody, PostStripeTransactionsConfirmParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: PostStripeTransactionsConfirmSchema;
    types: {
      parameters: PostStripeTransactionsConfirmParameters;
      data: PostStripeTransactionsConfirmData;
      error: PostStripeTransactionsConfirmError;
      body: PostStripeTransactionsConfirmBody;
    };
  };
  /** @summary Get transaction history for the current customer */
  getStripeTransactions: {
    /** @summary Get transaction history for the current customer */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripeTransactionsSchema,
            GetStripeTransactionsData,
            TInfinite,
            GetStripeTransactionsParameters,
            GetStripeTransactionsError
          >
        | QueryFiltersByQueryKey<
            GetStripeTransactionsSchema,
            GetStripeTransactionsData,
            TInfinite,
            GetStripeTransactionsParameters,
            GetStripeTransactionsError
          >,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get transaction history for the current customer */
    getQueryKey(
      parameters: DeepReadonly<GetStripeTransactionsParameters> | void
    ): ServiceOperationQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get transaction history for the current customer
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getStripeTransactions.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getStripeTransactions.useQuery({
     *     query: {
     *         limit: limit
     *     }
     * })
     * ```
     */
    useQuery<TData = GetStripeTransactionsData>(
      parameters:
        | ServiceOperationQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>
        | (DeepReadonly<GetStripeTransactionsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetStripeTransactionsData,
          GetStripeTransactionsError,
          TData,
          ServiceOperationQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetStripeTransactionsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get transaction history for the current customer
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getStripeTransactions.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getStripeTransactions.useQuery({
     *     query: {
     *         limit: limit
     *     }
     * })
     * ```
     */
    useQuery<TData = GetStripeTransactionsData>(
      parameters:
        | ServiceOperationQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>
        | (DeepReadonly<GetStripeTransactionsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetStripeTransactionsData,
          GetStripeTransactionsError,
          TData,
          ServiceOperationQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetStripeTransactionsError | Error>;
    /** @summary Get transaction history for the current customer */
    fetchInfiniteQuery<TPageParam extends GetStripeTransactionsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetStripeTransactionsSchema,
        GetStripeTransactionsData,
        GetStripeTransactionsParameters,
        DeepReadonly<TPageParam>,
        GetStripeTransactionsError
      > | void
    ): Promise<OperationInfiniteData<GetStripeTransactionsData, GetStripeTransactionsParameters>>;
    /** @summary Get transaction history for the current customer */
    prefetchInfiniteQuery<TPageParam extends GetStripeTransactionsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetStripeTransactionsSchema,
        GetStripeTransactionsData,
        GetStripeTransactionsParameters,
        DeepReadonly<TPageParam>,
        GetStripeTransactionsError
      > | void
    ): Promise<void>;
    /** @summary Get transaction history for the current customer */
    ensureInfiniteQueryData<TPageParam extends GetStripeTransactionsParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetStripeTransactionsSchema,
        GetStripeTransactionsData,
        GetStripeTransactionsParameters,
        DeepReadonly<TPageParam>,
        GetStripeTransactionsError
      > | void
    ): Promise<OperationInfiniteData<GetStripeTransactionsData, GetStripeTransactionsParameters>>;
    /** @summary Get transaction history for the current customer */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetStripeTransactionsSchema,
        GetStripeTransactionsData,
        GetStripeTransactionsParameters,
        GetStripeTransactionsError
      > | void
    ): Promise<GetStripeTransactionsData>;
    /** @summary Get transaction history for the current customer */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetStripeTransactionsSchema,
        GetStripeTransactionsData,
        GetStripeTransactionsParameters,
        GetStripeTransactionsError
      > | void
    ): Promise<void>;
    /** @summary Get transaction history for the current customer */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetStripeTransactionsSchema,
        GetStripeTransactionsData,
        GetStripeTransactionsParameters,
        GetStripeTransactionsError
      > | void
    ): Promise<GetStripeTransactionsData>;
    /** @summary Get transaction history for the current customer */
    getInfiniteQueryData(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>
        | (DeepReadonly<GetStripeTransactionsParameters> | void)
    ): OperationInfiniteData<GetStripeTransactionsData, GetStripeTransactionsParameters> | undefined;
    /** @summary Get transaction history for the current customer */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripeTransactionsSchema,
            GetStripeTransactionsData,
            TInfinite,
            GetStripeTransactionsParameters,
            GetStripeTransactionsError
          >
        | QueryFiltersByQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsData, TInfinite, GetStripeTransactionsParameters, GetStripeTransactionsError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>,
            data: NoInfer<OperationInfiniteData<GetStripeTransactionsData, GetStripeTransactionsParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>, data: GetStripeTransactionsData | undefined]>;
    /** @summary Get transaction history for the current customer */
    getQueryData(
      parameters:
        | ServiceOperationQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>
        | (DeepReadonly<GetStripeTransactionsParameters> | void)
    ): GetStripeTransactionsData | undefined;
    /** @summary Get transaction history for the current customer */
    getQueryState(
      parameters:
        | ServiceOperationQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>
        | (DeepReadonly<GetStripeTransactionsParameters> | void)
    ): QueryState<GetStripeTransactionsData, GetStripeTransactionsError> | undefined;
    /** @summary Get transaction history for the current customer */
    getInfiniteQueryState(
      parameters:
        | DeepReadonly<GetStripeTransactionsParameters>
        | ServiceOperationInfiniteQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>
        | void
    ): QueryState<OperationInfiniteData<GetStripeTransactionsData, GetStripeTransactionsParameters>, GetStripeTransactionsError> | undefined;
    /** @summary Get transaction history for the current customer */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<
        GetStripeTransactionsSchema,
        GetStripeTransactionsData,
        TInfinite,
        GetStripeTransactionsParameters,
        GetStripeTransactionsError
      >,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get transaction history for the current customer */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripeTransactionsSchema,
            GetStripeTransactionsData,
            TInfinite,
            GetStripeTransactionsParameters,
            GetStripeTransactionsError
          >
        | QueryFiltersByQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsData, TInfinite, GetStripeTransactionsParameters, GetStripeTransactionsError>
    ): number;
    /** @summary Get transaction history for the current customer */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetStripeTransactionsParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetStripeTransactionsSchema,
        options: {
          parameters: GetStripeTransactionsParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetStripeTransactionsData, GetStripeTransactionsError>>
    ): Promise<RequestFnResponse<GetStripeTransactionsData, GetStripeTransactionsError>>;
    /** @summary Get transaction history for the current customer */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripeTransactionsSchema,
            GetStripeTransactionsData,
            TInfinite,
            GetStripeTransactionsParameters,
            GetStripeTransactionsError
          >
        | QueryFiltersByQueryKey<
            GetStripeTransactionsSchema,
            GetStripeTransactionsData,
            TInfinite,
            GetStripeTransactionsParameters,
            GetStripeTransactionsError
          >,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get transaction history for the current customer */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripeTransactionsSchema,
            GetStripeTransactionsData,
            TInfinite,
            GetStripeTransactionsParameters,
            GetStripeTransactionsError
          >
        | QueryFiltersByQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsData, TInfinite, GetStripeTransactionsParameters, GetStripeTransactionsError>
    ): void;
    /** @summary Get transaction history for the current customer */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripeTransactionsSchema,
            GetStripeTransactionsData,
            TInfinite,
            GetStripeTransactionsParameters,
            GetStripeTransactionsError
          >
        | QueryFiltersByQueryKey<
            GetStripeTransactionsSchema,
            GetStripeTransactionsData,
            TInfinite,
            GetStripeTransactionsParameters,
            GetStripeTransactionsError
          >,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get transaction history for the current customer */
    setInfiniteQueryData(
      parameters:
        | (DeepReadonly<GetStripeTransactionsParameters> | undefined)
        | ServiceOperationInfiniteQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetStripeTransactionsData, GetStripeTransactionsParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetStripeTransactionsData, GetStripeTransactionsParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetStripeTransactionsData, GetStripeTransactionsParameters> | undefined;
    /** @summary Get transaction history for the current customer */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<
            GetStripeTransactionsSchema,
            GetStripeTransactionsData,
            TInfinite,
            GetStripeTransactionsParameters,
            GetStripeTransactionsError
          >
        | QueryFiltersByQueryKey<
            GetStripeTransactionsSchema,
            GetStripeTransactionsData,
            TInfinite,
            GetStripeTransactionsParameters,
            GetStripeTransactionsError
          >,
      updater: Updater<NoInfer<GetStripeTransactionsData> | undefined, NoInfer<GetStripeTransactionsData> | undefined>,
      options?: SetDataOptions
    ): Array<GetStripeTransactionsData | undefined>;
    /** @summary Get transaction history for the current customer */
    setQueryData(
      parameters:
        | (DeepReadonly<GetStripeTransactionsParameters> | undefined)
        | ServiceOperationQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>,
      updater: Updater<NoInfer<GetStripeTransactionsData> | undefined, NoInfer<DeepReadonly<GetStripeTransactionsData>> | undefined>,
      options?: SetDataOptions
    ): GetStripeTransactionsData | undefined;
    /** @summary Get transaction history for the current customer */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetStripeTransactionsParameters> | void
    ): ServiceOperationInfiniteQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get transaction history for the current customer
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getStripeTransactions.useInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             limit: initialLimit
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetStripeTransactionsParameters,
      TQueryFnData = GetStripeTransactionsData,
      TData = OperationInfiniteData<TQueryFnData, GetStripeTransactionsParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>
        | (DeepReadonly<GetStripeTransactionsParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetStripeTransactionsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetStripeTransactionsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get transaction history for the current customer
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getStripeTransactions.useInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             limit: initialLimit
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetStripeTransactionsParameters,
      TQueryFnData = GetStripeTransactionsData,
      TData = OperationInfiniteData<TQueryFnData, GetStripeTransactionsParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>
        | (DeepReadonly<GetStripeTransactionsParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetStripeTransactionsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetStripeTransactionsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetStripeTransactionsError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get transaction history for the current customer
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getStripeTransactionsTotal = qraft.v1Service.getStripeTransactions.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getStripeTransactionsByParametersTotal = qraft.v1Service.getStripeTransactions.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         query: {
     *             limit: limit
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripeTransactionsSchema,
            GetStripeTransactionsData,
            TInfinite,
            GetStripeTransactionsParameters,
            GetStripeTransactionsError
          >
        | QueryFiltersByQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsData, TInfinite, GetStripeTransactionsParameters, GetStripeTransactionsError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get transaction history for the current customer
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getStripeTransactionsResults = qraft.v1Service.getStripeTransactions.useQueries({
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             }
     *         }
     *     ]
     * });
     * getStripeTransactionsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getStripeTransactionsCombinedResults = qraft.v1Service.getStripeTransactions.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             }
     *         }
     *     ]
     * });
     * getStripeTransactionsCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<GetStripeTransactionsSchema, GetStripeTransactionsParameters, GetStripeTransactionsData, GetStripeTransactionsError>
      >,
      TCombinedResult = Array<UseQueryResult<GetStripeTransactionsData, GetStripeTransactionsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetStripeTransactionsData, GetStripeTransactionsError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get transaction history for the current customer */
    getQueryKey(
      parameters: DeepReadonly<GetStripeTransactionsParameters> | void
    ): ServiceOperationQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get transaction history for the current customer
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getStripeTransactions.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getStripeTransactions.useQuery({
     *     query: {
     *         limit: limit
     *     }
     * })
     * ```
     */
    useQuery<TData = GetStripeTransactionsData>(
      parameters:
        | ServiceOperationQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>
        | (DeepReadonly<GetStripeTransactionsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetStripeTransactionsData,
          GetStripeTransactionsError,
          TData,
          ServiceOperationQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetStripeTransactionsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get transaction history for the current customer
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getStripeTransactions.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getStripeTransactions.useQuery({
     *     query: {
     *         limit: limit
     *     }
     * })
     * ```
     */
    useQuery<TData = GetStripeTransactionsData>(
      parameters:
        | ServiceOperationQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>
        | (DeepReadonly<GetStripeTransactionsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetStripeTransactionsData,
          GetStripeTransactionsError,
          TData,
          ServiceOperationQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetStripeTransactionsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get transaction history for the current customer
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getStripeTransactions.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             limit: initialLimit
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetStripeTransactionsParameters, TData = GetStripeTransactionsData>(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>
        | (DeepReadonly<GetStripeTransactionsParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetStripeTransactionsData,
          GetStripeTransactionsError,
          OperationInfiniteData<TData, GetStripeTransactionsParameters>,
          GetStripeTransactionsData,
          ServiceOperationInfiniteQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetStripeTransactionsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetStripeTransactionsParameters>, GetStripeTransactionsError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get transaction history for the current customer
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getStripeTransactionsData = qraft.v1Service.getStripeTransactions.useSuspenseQueries({
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             }
     *         }
     *     ]
     * });
     * getStripeTransactionsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getStripeTransactionsCombinedData = qraft.v1Service.getStripeTransactions.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             }
     *         }
     *     ]
     * });
     * getStripeTransactionsCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<GetStripeTransactionsSchema, GetStripeTransactionsParameters, GetStripeTransactionsData, GetStripeTransactionsError>
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetStripeTransactionsData, GetStripeTransactionsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetStripeTransactionsData, GetStripeTransactionsError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get transaction history for the current customer
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getStripeTransactions.useSuspenseQuery()
     * ```
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getStripeTransactions.useSuspenseQuery({
     *     query: {
     *         limit: limit
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetStripeTransactionsData>(
      parameters:
        | ServiceOperationQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>
        | (DeepReadonly<GetStripeTransactionsParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<
          GetStripeTransactionsData,
          GetStripeTransactionsError,
          TData,
          ServiceOperationQueryKey<GetStripeTransactionsSchema, GetStripeTransactionsParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetStripeTransactionsError | Error>;
    schema: GetStripeTransactionsSchema;
    types: {
      parameters: GetStripeTransactionsParameters;
      data: GetStripeTransactionsData;
      error: GetStripeTransactionsError;
    };
  };
  /** @summary Export transaction history as CSV for the current customer */
  getStripeTransactionsExport: {
    /** @summary Export transaction history as CSV for the current customer */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripeTransactionsExportSchema,
            GetStripeTransactionsExportData,
            TInfinite,
            GetStripeTransactionsExportParameters,
            GetStripeTransactionsExportError
          >
        | QueryFiltersByQueryKey<
            GetStripeTransactionsExportSchema,
            GetStripeTransactionsExportData,
            TInfinite,
            GetStripeTransactionsExportParameters,
            GetStripeTransactionsExportError
          >,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Export transaction history as CSV for the current customer */
    getQueryKey(
      parameters: DeepReadonly<GetStripeTransactionsExportParameters>
    ): ServiceOperationQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Export transaction history as CSV for the current customer
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getStripeTransactionsExport.useQuery({
     *     query: {
     *         timezone: timezone,
     *         startDate: startDate,
     *         endDate: endDate
     *     }
     * })
     * ```
     */
    useQuery<TData = GetStripeTransactionsExportData>(
      parameters:
        | ServiceOperationQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>
        | DeepReadonly<GetStripeTransactionsExportParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetStripeTransactionsExportData,
          GetStripeTransactionsExportError,
          TData,
          ServiceOperationQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetStripeTransactionsExportError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Export transaction history as CSV for the current customer
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getStripeTransactionsExport.useQuery({
     *     query: {
     *         timezone: timezone,
     *         startDate: startDate,
     *         endDate: endDate
     *     }
     * })
     * ```
     */
    useQuery<TData = GetStripeTransactionsExportData>(
      parameters:
        | ServiceOperationQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>
        | DeepReadonly<GetStripeTransactionsExportParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetStripeTransactionsExportData,
          GetStripeTransactionsExportError,
          TData,
          ServiceOperationQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetStripeTransactionsExportError | Error>;
    /** @summary Export transaction history as CSV for the current customer */
    fetchInfiniteQuery<TPageParam extends GetStripeTransactionsExportParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetStripeTransactionsExportSchema,
        GetStripeTransactionsExportData,
        GetStripeTransactionsExportParameters,
        DeepReadonly<TPageParam>,
        GetStripeTransactionsExportError
      >
    ): Promise<OperationInfiniteData<GetStripeTransactionsExportData, GetStripeTransactionsExportParameters>>;
    /** @summary Export transaction history as CSV for the current customer */
    prefetchInfiniteQuery<TPageParam extends GetStripeTransactionsExportParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetStripeTransactionsExportSchema,
        GetStripeTransactionsExportData,
        GetStripeTransactionsExportParameters,
        DeepReadonly<TPageParam>,
        GetStripeTransactionsExportError
      >
    ): Promise<void>;
    /** @summary Export transaction history as CSV for the current customer */
    ensureInfiniteQueryData<TPageParam extends GetStripeTransactionsExportParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetStripeTransactionsExportSchema,
        GetStripeTransactionsExportData,
        GetStripeTransactionsExportParameters,
        DeepReadonly<TPageParam>,
        GetStripeTransactionsExportError
      >
    ): Promise<OperationInfiniteData<GetStripeTransactionsExportData, GetStripeTransactionsExportParameters>>;
    /** @summary Export transaction history as CSV for the current customer */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetStripeTransactionsExportSchema,
        GetStripeTransactionsExportData,
        GetStripeTransactionsExportParameters,
        GetStripeTransactionsExportError
      >
    ): Promise<GetStripeTransactionsExportData>;
    /** @summary Export transaction history as CSV for the current customer */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetStripeTransactionsExportSchema,
        GetStripeTransactionsExportData,
        GetStripeTransactionsExportParameters,
        GetStripeTransactionsExportError
      >
    ): Promise<void>;
    /** @summary Export transaction history as CSV for the current customer */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetStripeTransactionsExportSchema,
        GetStripeTransactionsExportData,
        GetStripeTransactionsExportParameters,
        GetStripeTransactionsExportError
      >
    ): Promise<GetStripeTransactionsExportData>;
    /** @summary Export transaction history as CSV for the current customer */
    getInfiniteQueryData(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>
        | DeepReadonly<GetStripeTransactionsExportParameters>
    ): OperationInfiniteData<GetStripeTransactionsExportData, GetStripeTransactionsExportParameters> | undefined;
    /** @summary Export transaction history as CSV for the current customer */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripeTransactionsExportSchema,
            GetStripeTransactionsExportData,
            TInfinite,
            GetStripeTransactionsExportParameters,
            GetStripeTransactionsExportError
          >
        | QueryFiltersByQueryKey<
            GetStripeTransactionsExportSchema,
            GetStripeTransactionsExportData,
            TInfinite,
            GetStripeTransactionsExportParameters,
            GetStripeTransactionsExportError
          >
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>,
            data: NoInfer<OperationInfiniteData<GetStripeTransactionsExportData, GetStripeTransactionsExportParameters>> | undefined
          ]
        >
      : Array<
          [
            queryKey: ServiceOperationQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>,
            data: GetStripeTransactionsExportData | undefined
          ]
        >;
    /** @summary Export transaction history as CSV for the current customer */
    getQueryData(
      parameters:
        | ServiceOperationQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>
        | DeepReadonly<GetStripeTransactionsExportParameters>
    ): GetStripeTransactionsExportData | undefined;
    /** @summary Export transaction history as CSV for the current customer */
    getQueryState(
      parameters:
        | ServiceOperationQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>
        | DeepReadonly<GetStripeTransactionsExportParameters>
    ): QueryState<GetStripeTransactionsExportData, GetStripeTransactionsExportError> | undefined;
    /** @summary Export transaction history as CSV for the current customer */
    getInfiniteQueryState(
      parameters:
        | DeepReadonly<GetStripeTransactionsExportParameters>
        | ServiceOperationInfiniteQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>
    ): QueryState<OperationInfiniteData<GetStripeTransactionsExportData, GetStripeTransactionsExportParameters>, GetStripeTransactionsExportError> | undefined;
    /** @summary Export transaction history as CSV for the current customer */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<
        GetStripeTransactionsExportSchema,
        GetStripeTransactionsExportData,
        TInfinite,
        GetStripeTransactionsExportParameters,
        GetStripeTransactionsExportError
      >,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Export transaction history as CSV for the current customer */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripeTransactionsExportSchema,
            GetStripeTransactionsExportData,
            TInfinite,
            GetStripeTransactionsExportParameters,
            GetStripeTransactionsExportError
          >
        | QueryFiltersByQueryKey<
            GetStripeTransactionsExportSchema,
            GetStripeTransactionsExportData,
            TInfinite,
            GetStripeTransactionsExportParameters,
            GetStripeTransactionsExportError
          >
    ): number;
    /** @summary Export transaction history as CSV for the current customer */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetStripeTransactionsExportParameters, TMeta, TSignal>,
      client?: (
        schema: GetStripeTransactionsExportSchema,
        options: {
          parameters: GetStripeTransactionsExportParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetStripeTransactionsExportData, GetStripeTransactionsExportError>>
    ): Promise<RequestFnResponse<GetStripeTransactionsExportData, GetStripeTransactionsExportError>>;
    /** @summary Export transaction history as CSV for the current customer */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripeTransactionsExportSchema,
            GetStripeTransactionsExportData,
            TInfinite,
            GetStripeTransactionsExportParameters,
            GetStripeTransactionsExportError
          >
        | QueryFiltersByQueryKey<
            GetStripeTransactionsExportSchema,
            GetStripeTransactionsExportData,
            TInfinite,
            GetStripeTransactionsExportParameters,
            GetStripeTransactionsExportError
          >,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Export transaction history as CSV for the current customer */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripeTransactionsExportSchema,
            GetStripeTransactionsExportData,
            TInfinite,
            GetStripeTransactionsExportParameters,
            GetStripeTransactionsExportError
          >
        | QueryFiltersByQueryKey<
            GetStripeTransactionsExportSchema,
            GetStripeTransactionsExportData,
            TInfinite,
            GetStripeTransactionsExportParameters,
            GetStripeTransactionsExportError
          >
    ): void;
    /** @summary Export transaction history as CSV for the current customer */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripeTransactionsExportSchema,
            GetStripeTransactionsExportData,
            TInfinite,
            GetStripeTransactionsExportParameters,
            GetStripeTransactionsExportError
          >
        | QueryFiltersByQueryKey<
            GetStripeTransactionsExportSchema,
            GetStripeTransactionsExportData,
            TInfinite,
            GetStripeTransactionsExportParameters,
            GetStripeTransactionsExportError
          >,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Export transaction history as CSV for the current customer */
    setInfiniteQueryData(
      parameters:
        | DeepReadonly<GetStripeTransactionsExportParameters>
        | ServiceOperationInfiniteQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetStripeTransactionsExportData, GetStripeTransactionsExportParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetStripeTransactionsExportData, GetStripeTransactionsExportParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetStripeTransactionsExportData, GetStripeTransactionsExportParameters> | undefined;
    /** @summary Export transaction history as CSV for the current customer */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<
            GetStripeTransactionsExportSchema,
            GetStripeTransactionsExportData,
            TInfinite,
            GetStripeTransactionsExportParameters,
            GetStripeTransactionsExportError
          >
        | QueryFiltersByQueryKey<
            GetStripeTransactionsExportSchema,
            GetStripeTransactionsExportData,
            TInfinite,
            GetStripeTransactionsExportParameters,
            GetStripeTransactionsExportError
          >,
      updater: Updater<NoInfer<GetStripeTransactionsExportData> | undefined, NoInfer<GetStripeTransactionsExportData> | undefined>,
      options?: SetDataOptions
    ): Array<GetStripeTransactionsExportData | undefined>;
    /** @summary Export transaction history as CSV for the current customer */
    setQueryData(
      parameters:
        | DeepReadonly<GetStripeTransactionsExportParameters>
        | ServiceOperationQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>,
      updater: Updater<NoInfer<GetStripeTransactionsExportData> | undefined, NoInfer<DeepReadonly<GetStripeTransactionsExportData>> | undefined>,
      options?: SetDataOptions
    ): GetStripeTransactionsExportData | undefined;
    /** @summary Export transaction history as CSV for the current customer */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetStripeTransactionsExportParameters>
    ): ServiceOperationInfiniteQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Export transaction history as CSV for the current customer
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getStripeTransactionsExport.useInfiniteQuery({
     *     query: {
     *         timezone: timezone,
     *         startDate: startDate,
     *         endDate: endDate
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             timezone: initialTimezone,
     *             startDate: initialStartDate,
     *             endDate: initialEndDate
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetStripeTransactionsExportParameters,
      TQueryFnData = GetStripeTransactionsExportData,
      TData = OperationInfiniteData<TQueryFnData, GetStripeTransactionsExportParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>
        | DeepReadonly<GetStripeTransactionsExportParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetStripeTransactionsExportError,
          TData,
          ServiceOperationInfiniteQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetStripeTransactionsExportError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Export transaction history as CSV for the current customer
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getStripeTransactionsExport.useInfiniteQuery({
     *     query: {
     *         timezone: timezone,
     *         startDate: startDate,
     *         endDate: endDate
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             timezone: initialTimezone,
     *             startDate: initialStartDate,
     *             endDate: initialEndDate
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetStripeTransactionsExportParameters,
      TQueryFnData = GetStripeTransactionsExportData,
      TData = OperationInfiniteData<TQueryFnData, GetStripeTransactionsExportParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>
        | DeepReadonly<GetStripeTransactionsExportParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetStripeTransactionsExportError,
          TData,
          ServiceOperationInfiniteQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetStripeTransactionsExportData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetStripeTransactionsExportError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Export transaction history as CSV for the current customer
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getStripeTransactionsExportTotal = qraft.v1Service.getStripeTransactionsExport.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getStripeTransactionsExportByParametersTotal = qraft.v1Service.getStripeTransactionsExport.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         query: {
     *             timezone: timezone,
     *             startDate: startDate,
     *             endDate: endDate
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetStripeTransactionsExportSchema,
            GetStripeTransactionsExportData,
            TInfinite,
            GetStripeTransactionsExportParameters,
            GetStripeTransactionsExportError
          >
        | QueryFiltersByQueryKey<
            GetStripeTransactionsExportSchema,
            GetStripeTransactionsExportData,
            TInfinite,
            GetStripeTransactionsExportParameters,
            GetStripeTransactionsExportError
          >
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Export transaction history as CSV for the current customer
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getStripeTransactionsExportResults = qraft.v1Service.getStripeTransactionsExport.useQueries({
     *     queries: [
     *         {
     *             query: {
     *                 timezone: timezone1,
     *                 startDate: startDate1,
     *                 endDate: endDate1
     *             }
     *         },
     *         {
     *             query: {
     *                 timezone: timezone2,
     *                 startDate: startDate2,
     *                 endDate: endDate2
     *             }
     *         }
     *     ]
     * });
     * getStripeTransactionsExportResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getStripeTransactionsExportCombinedResults = qraft.v1Service.getStripeTransactionsExport.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 timezone: timezone1,
     *                 startDate: startDate1,
     *                 endDate: endDate1
     *             }
     *         },
     *         {
     *             query: {
     *                 timezone: timezone2,
     *                 startDate: startDate2,
     *                 endDate: endDate2
     *             }
     *         }
     *     ]
     * });
     * getStripeTransactionsExportCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<
          GetStripeTransactionsExportSchema,
          GetStripeTransactionsExportParameters,
          GetStripeTransactionsExportData,
          GetStripeTransactionsExportError
        >
      >,
      TCombinedResult = Array<UseQueryResult<GetStripeTransactionsExportData, GetStripeTransactionsExportError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetStripeTransactionsExportData, GetStripeTransactionsExportError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Export transaction history as CSV for the current customer */
    getQueryKey(
      parameters: DeepReadonly<GetStripeTransactionsExportParameters>
    ): ServiceOperationQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Export transaction history as CSV for the current customer
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getStripeTransactionsExport.useQuery({
     *     query: {
     *         timezone: timezone,
     *         startDate: startDate,
     *         endDate: endDate
     *     }
     * })
     * ```
     */
    useQuery<TData = GetStripeTransactionsExportData>(
      parameters:
        | ServiceOperationQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>
        | DeepReadonly<GetStripeTransactionsExportParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetStripeTransactionsExportData,
          GetStripeTransactionsExportError,
          TData,
          ServiceOperationQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetStripeTransactionsExportError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Export transaction history as CSV for the current customer
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getStripeTransactionsExport.useQuery({
     *     query: {
     *         timezone: timezone,
     *         startDate: startDate,
     *         endDate: endDate
     *     }
     * })
     * ```
     */
    useQuery<TData = GetStripeTransactionsExportData>(
      parameters:
        | ServiceOperationQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>
        | DeepReadonly<GetStripeTransactionsExportParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetStripeTransactionsExportData,
          GetStripeTransactionsExportError,
          TData,
          ServiceOperationQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetStripeTransactionsExportError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Export transaction history as CSV for the current customer
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getStripeTransactionsExport.useSuspenseInfiniteQuery({
     *     query: {
     *         timezone: timezone,
     *         startDate: startDate,
     *         endDate: endDate
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             timezone: initialTimezone,
     *             startDate: initialStartDate,
     *             endDate: initialEndDate
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetStripeTransactionsExportParameters, TData = GetStripeTransactionsExportData>(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>
        | DeepReadonly<GetStripeTransactionsExportParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetStripeTransactionsExportData,
          GetStripeTransactionsExportError,
          OperationInfiniteData<TData, GetStripeTransactionsExportParameters>,
          GetStripeTransactionsExportData,
          ServiceOperationInfiniteQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetStripeTransactionsExportData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetStripeTransactionsExportParameters>, GetStripeTransactionsExportError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Export transaction history as CSV for the current customer
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getStripeTransactionsExportData = qraft.v1Service.getStripeTransactionsExport.useSuspenseQueries({
     *     queries: [
     *         {
     *             query: {
     *                 timezone: timezone1,
     *                 startDate: startDate1,
     *                 endDate: endDate1
     *             }
     *         },
     *         {
     *             query: {
     *                 timezone: timezone2,
     *                 startDate: startDate2,
     *                 endDate: endDate2
     *             }
     *         }
     *     ]
     * });
     * getStripeTransactionsExportResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getStripeTransactionsExportCombinedData = qraft.v1Service.getStripeTransactionsExport.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 timezone: timezone1,
     *                 startDate: startDate1,
     *                 endDate: endDate1
     *             }
     *         },
     *         {
     *             query: {
     *                 timezone: timezone2,
     *                 startDate: startDate2,
     *                 endDate: endDate2
     *             }
     *         }
     *     ]
     * });
     * getStripeTransactionsExportCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<
          GetStripeTransactionsExportSchema,
          GetStripeTransactionsExportParameters,
          GetStripeTransactionsExportData,
          GetStripeTransactionsExportError
        >
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetStripeTransactionsExportData, GetStripeTransactionsExportError>>
    >(options: {
      queries: T;
      combine?: (
        results: Array<WithOptional<UseSuspenseQueryResult<GetStripeTransactionsExportData, GetStripeTransactionsExportError>, "data">>
      ) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Export transaction history as CSV for the current customer
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getStripeTransactionsExport.useSuspenseQuery({
     *     query: {
     *         timezone: timezone,
     *         startDate: startDate,
     *         endDate: endDate
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetStripeTransactionsExportData>(
      parameters:
        | ServiceOperationQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>
        | DeepReadonly<GetStripeTransactionsExportParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<
          GetStripeTransactionsExportData,
          GetStripeTransactionsExportError,
          TData,
          ServiceOperationQueryKey<GetStripeTransactionsExportSchema, GetStripeTransactionsExportParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetStripeTransactionsExportError | Error>;
    schema: GetStripeTransactionsExportSchema;
    types: {
      parameters: GetStripeTransactionsExportParameters;
      data: GetStripeTransactionsExportData;
      error: GetStripeTransactionsExportError;
    };
  };
  /** @summary Get historical data of billing and usage for a wallet address. */
  getUsageHistory: {
    /** @summary Get historical data of billing and usage for a wallet address. */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetUsageHistorySchema, GetUsageHistoryData, TInfinite, GetUsageHistoryParameters, GetUsageHistoryError>
        | QueryFiltersByQueryKey<GetUsageHistorySchema, GetUsageHistoryData, TInfinite, GetUsageHistoryParameters, GetUsageHistoryError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get historical data of billing and usage for a wallet address. */
    getQueryKey(parameters: DeepReadonly<GetUsageHistoryParameters>): ServiceOperationQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get historical data of billing and usage for a wallet address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getUsageHistory.useQuery({
     *     query: {
     *         address: address
     *     }
     * })
     * ```
     */
    useQuery<TData = GetUsageHistoryData>(
      parameters: ServiceOperationQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters> | DeepReadonly<GetUsageHistoryParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetUsageHistoryData,
          GetUsageHistoryError,
          TData,
          ServiceOperationQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetUsageHistoryError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get historical data of billing and usage for a wallet address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getUsageHistory.useQuery({
     *     query: {
     *         address: address
     *     }
     * })
     * ```
     */
    useQuery<TData = GetUsageHistoryData>(
      parameters: ServiceOperationQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters> | DeepReadonly<GetUsageHistoryParameters>,
      options: Omit<
        DefinedInitialDataOptions<GetUsageHistoryData, GetUsageHistoryError, TData, ServiceOperationQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetUsageHistoryError | Error>;
    /** @summary Get historical data of billing and usage for a wallet address. */
    fetchInfiniteQuery<TPageParam extends GetUsageHistoryParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetUsageHistorySchema,
        GetUsageHistoryData,
        GetUsageHistoryParameters,
        DeepReadonly<TPageParam>,
        GetUsageHistoryError
      >
    ): Promise<OperationInfiniteData<GetUsageHistoryData, GetUsageHistoryParameters>>;
    /** @summary Get historical data of billing and usage for a wallet address. */
    prefetchInfiniteQuery<TPageParam extends GetUsageHistoryParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetUsageHistorySchema,
        GetUsageHistoryData,
        GetUsageHistoryParameters,
        DeepReadonly<TPageParam>,
        GetUsageHistoryError
      >
    ): Promise<void>;
    /** @summary Get historical data of billing and usage for a wallet address. */
    ensureInfiniteQueryData<TPageParam extends GetUsageHistoryParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetUsageHistorySchema,
        GetUsageHistoryData,
        GetUsageHistoryParameters,
        DeepReadonly<TPageParam>,
        GetUsageHistoryError
      >
    ): Promise<OperationInfiniteData<GetUsageHistoryData, GetUsageHistoryParameters>>;
    /** @summary Get historical data of billing and usage for a wallet address. */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetUsageHistorySchema, GetUsageHistoryData, GetUsageHistoryParameters, GetUsageHistoryError>
    ): Promise<GetUsageHistoryData>;
    /** @summary Get historical data of billing and usage for a wallet address. */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetUsageHistorySchema, GetUsageHistoryData, GetUsageHistoryParameters, GetUsageHistoryError>
    ): Promise<void>;
    /** @summary Get historical data of billing and usage for a wallet address. */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetUsageHistorySchema, GetUsageHistoryData, GetUsageHistoryParameters, GetUsageHistoryError>
    ): Promise<GetUsageHistoryData>;
    /** @summary Get historical data of billing and usage for a wallet address. */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters> | DeepReadonly<GetUsageHistoryParameters>
    ): OperationInfiniteData<GetUsageHistoryData, GetUsageHistoryParameters> | undefined;
    /** @summary Get historical data of billing and usage for a wallet address. */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetUsageHistorySchema, GetUsageHistoryData, TInfinite, GetUsageHistoryParameters, GetUsageHistoryError>
        | QueryFiltersByQueryKey<GetUsageHistorySchema, GetUsageHistoryData, TInfinite, GetUsageHistoryParameters, GetUsageHistoryError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters>,
            data: NoInfer<OperationInfiniteData<GetUsageHistoryData, GetUsageHistoryParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters>, data: GetUsageHistoryData | undefined]>;
    /** @summary Get historical data of billing and usage for a wallet address. */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters> | DeepReadonly<GetUsageHistoryParameters>
    ): GetUsageHistoryData | undefined;
    /** @summary Get historical data of billing and usage for a wallet address. */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters> | DeepReadonly<GetUsageHistoryParameters>
    ): QueryState<GetUsageHistoryData, GetUsageHistoryError> | undefined;
    /** @summary Get historical data of billing and usage for a wallet address. */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetUsageHistoryParameters> | ServiceOperationInfiniteQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters>
    ): QueryState<OperationInfiniteData<GetUsageHistoryData, GetUsageHistoryParameters>, GetUsageHistoryError> | undefined;
    /** @summary Get historical data of billing and usage for a wallet address. */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetUsageHistorySchema, GetUsageHistoryData, TInfinite, GetUsageHistoryParameters, GetUsageHistoryError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get historical data of billing and usage for a wallet address. */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetUsageHistorySchema, GetUsageHistoryData, TInfinite, GetUsageHistoryParameters, GetUsageHistoryError>
        | QueryFiltersByQueryKey<GetUsageHistorySchema, GetUsageHistoryData, TInfinite, GetUsageHistoryParameters, GetUsageHistoryError>
    ): number;
    /** @summary Get historical data of billing and usage for a wallet address. */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetUsageHistoryParameters, TMeta, TSignal>,
      client?: (
        schema: GetUsageHistorySchema,
        options: {
          parameters: GetUsageHistoryParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetUsageHistoryData, GetUsageHistoryError>>
    ): Promise<RequestFnResponse<GetUsageHistoryData, GetUsageHistoryError>>;
    /** @summary Get historical data of billing and usage for a wallet address. */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetUsageHistorySchema, GetUsageHistoryData, TInfinite, GetUsageHistoryParameters, GetUsageHistoryError>
        | QueryFiltersByQueryKey<GetUsageHistorySchema, GetUsageHistoryData, TInfinite, GetUsageHistoryParameters, GetUsageHistoryError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get historical data of billing and usage for a wallet address. */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetUsageHistorySchema, GetUsageHistoryData, TInfinite, GetUsageHistoryParameters, GetUsageHistoryError>
        | QueryFiltersByQueryKey<GetUsageHistorySchema, GetUsageHistoryData, TInfinite, GetUsageHistoryParameters, GetUsageHistoryError>
    ): void;
    /** @summary Get historical data of billing and usage for a wallet address. */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetUsageHistorySchema, GetUsageHistoryData, TInfinite, GetUsageHistoryParameters, GetUsageHistoryError>
        | QueryFiltersByQueryKey<GetUsageHistorySchema, GetUsageHistoryData, TInfinite, GetUsageHistoryParameters, GetUsageHistoryError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get historical data of billing and usage for a wallet address. */
    setInfiniteQueryData(
      parameters: DeepReadonly<GetUsageHistoryParameters> | ServiceOperationInfiniteQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetUsageHistoryData, GetUsageHistoryParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetUsageHistoryData, GetUsageHistoryParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetUsageHistoryData, GetUsageHistoryParameters> | undefined;
    /** @summary Get historical data of billing and usage for a wallet address. */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetUsageHistorySchema, GetUsageHistoryData, TInfinite, GetUsageHistoryParameters, GetUsageHistoryError>
        | QueryFiltersByQueryKey<GetUsageHistorySchema, GetUsageHistoryData, TInfinite, GetUsageHistoryParameters, GetUsageHistoryError>,
      updater: Updater<NoInfer<GetUsageHistoryData> | undefined, NoInfer<GetUsageHistoryData> | undefined>,
      options?: SetDataOptions
    ): Array<GetUsageHistoryData | undefined>;
    /** @summary Get historical data of billing and usage for a wallet address. */
    setQueryData(
      parameters: DeepReadonly<GetUsageHistoryParameters> | ServiceOperationQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters>,
      updater: Updater<NoInfer<GetUsageHistoryData> | undefined, NoInfer<DeepReadonly<GetUsageHistoryData>> | undefined>,
      options?: SetDataOptions
    ): GetUsageHistoryData | undefined;
    /** @summary Get historical data of billing and usage for a wallet address. */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetUsageHistoryParameters>
    ): ServiceOperationInfiniteQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get historical data of billing and usage for a wallet address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getUsageHistory.useInfiniteQuery({
     *     query: {
     *         address: address
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             address: initialAddress
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetUsageHistoryParameters,
      TQueryFnData = GetUsageHistoryData,
      TData = OperationInfiniteData<TQueryFnData, GetUsageHistoryParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters> | DeepReadonly<GetUsageHistoryParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetUsageHistoryError,
          TData,
          ServiceOperationInfiniteQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetUsageHistoryError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get historical data of billing and usage for a wallet address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getUsageHistory.useInfiniteQuery({
     *     query: {
     *         address: address
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             address: initialAddress
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetUsageHistoryParameters,
      TQueryFnData = GetUsageHistoryData,
      TData = OperationInfiniteData<TQueryFnData, GetUsageHistoryParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters> | DeepReadonly<GetUsageHistoryParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetUsageHistoryError,
          TData,
          ServiceOperationInfiniteQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetUsageHistoryData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetUsageHistoryError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get historical data of billing and usage for a wallet address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getUsageHistoryTotal = qraft.v1Service.getUsageHistory.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getUsageHistoryByParametersTotal = qraft.v1Service.getUsageHistory.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         query: {
     *             address: address
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetUsageHistorySchema, GetUsageHistoryData, TInfinite, GetUsageHistoryParameters, GetUsageHistoryError>
        | QueryFiltersByQueryKey<GetUsageHistorySchema, GetUsageHistoryData, TInfinite, GetUsageHistoryParameters, GetUsageHistoryError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get historical data of billing and usage for a wallet address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getUsageHistoryResults = qraft.v1Service.getUsageHistory.useQueries({
     *     queries: [
     *         {
     *             query: {
     *                 address: address1
     *             }
     *         },
     *         {
     *             query: {
     *                 address: address2
     *             }
     *         }
     *     ]
     * });
     * getUsageHistoryResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getUsageHistoryCombinedResults = qraft.v1Service.getUsageHistory.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 address: address1
     *             }
     *         },
     *         {
     *             query: {
     *                 address: address2
     *             }
     *         }
     *     ]
     * });
     * getUsageHistoryCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetUsageHistorySchema, GetUsageHistoryParameters, GetUsageHistoryData, GetUsageHistoryError>>,
      TCombinedResult = Array<UseQueryResult<GetUsageHistoryData, GetUsageHistoryError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetUsageHistoryData, GetUsageHistoryError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get historical data of billing and usage for a wallet address. */
    getQueryKey(parameters: DeepReadonly<GetUsageHistoryParameters>): ServiceOperationQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get historical data of billing and usage for a wallet address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getUsageHistory.useQuery({
     *     query: {
     *         address: address
     *     }
     * })
     * ```
     */
    useQuery<TData = GetUsageHistoryData>(
      parameters: ServiceOperationQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters> | DeepReadonly<GetUsageHistoryParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetUsageHistoryData,
          GetUsageHistoryError,
          TData,
          ServiceOperationQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetUsageHistoryError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get historical data of billing and usage for a wallet address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getUsageHistory.useQuery({
     *     query: {
     *         address: address
     *     }
     * })
     * ```
     */
    useQuery<TData = GetUsageHistoryData>(
      parameters: ServiceOperationQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters> | DeepReadonly<GetUsageHistoryParameters>,
      options: Omit<
        DefinedInitialDataOptions<GetUsageHistoryData, GetUsageHistoryError, TData, ServiceOperationQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetUsageHistoryError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get historical data of billing and usage for a wallet address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getUsageHistory.useSuspenseInfiniteQuery({
     *     query: {
     *         address: address
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             address: initialAddress
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetUsageHistoryParameters, TData = GetUsageHistoryData>(
      parameters: ServiceOperationInfiniteQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters> | DeepReadonly<GetUsageHistoryParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetUsageHistoryData,
          GetUsageHistoryError,
          OperationInfiniteData<TData, GetUsageHistoryParameters>,
          GetUsageHistoryData,
          ServiceOperationInfiniteQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetUsageHistoryData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetUsageHistoryParameters>, GetUsageHistoryError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get historical data of billing and usage for a wallet address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getUsageHistoryData = qraft.v1Service.getUsageHistory.useSuspenseQueries({
     *     queries: [
     *         {
     *             query: {
     *                 address: address1
     *             }
     *         },
     *         {
     *             query: {
     *                 address: address2
     *             }
     *         }
     *     ]
     * });
     * getUsageHistoryResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getUsageHistoryCombinedData = qraft.v1Service.getUsageHistory.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 address: address1
     *             }
     *         },
     *         {
     *             query: {
     *                 address: address2
     *             }
     *         }
     *     ]
     * });
     * getUsageHistoryCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetUsageHistorySchema, GetUsageHistoryParameters, GetUsageHistoryData, GetUsageHistoryError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetUsageHistoryData, GetUsageHistoryError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetUsageHistoryData, GetUsageHistoryError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get historical data of billing and usage for a wallet address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getUsageHistory.useSuspenseQuery({
     *     query: {
     *         address: address
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetUsageHistoryData>(
      parameters: ServiceOperationQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters> | DeepReadonly<GetUsageHistoryParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<GetUsageHistoryData, GetUsageHistoryError, TData, ServiceOperationQueryKey<GetUsageHistorySchema, GetUsageHistoryParameters>>,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetUsageHistoryError | Error>;
    schema: GetUsageHistorySchema;
    types: {
      parameters: GetUsageHistoryParameters;
      data: GetUsageHistoryData;
      error: GetUsageHistoryError;
    };
  };
  /** @summary Get historical usage stats for a wallet address. */
  getUsageHistoryStats: {
    /** @summary Get historical usage stats for a wallet address. */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetUsageHistoryStatsSchema, GetUsageHistoryStatsData, TInfinite, GetUsageHistoryStatsParameters, GetUsageHistoryStatsError>
        | QueryFiltersByQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsData, TInfinite, GetUsageHistoryStatsParameters, GetUsageHistoryStatsError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get historical usage stats for a wallet address. */
    getQueryKey(parameters: DeepReadonly<GetUsageHistoryStatsParameters>): ServiceOperationQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get historical usage stats for a wallet address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getUsageHistoryStats.useQuery({
     *     query: {
     *         address: address
     *     }
     * })
     * ```
     */
    useQuery<TData = GetUsageHistoryStatsData>(
      parameters: ServiceOperationQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters> | DeepReadonly<GetUsageHistoryStatsParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetUsageHistoryStatsData,
          GetUsageHistoryStatsError,
          TData,
          ServiceOperationQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetUsageHistoryStatsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get historical usage stats for a wallet address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getUsageHistoryStats.useQuery({
     *     query: {
     *         address: address
     *     }
     * })
     * ```
     */
    useQuery<TData = GetUsageHistoryStatsData>(
      parameters: ServiceOperationQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters> | DeepReadonly<GetUsageHistoryStatsParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetUsageHistoryStatsData,
          GetUsageHistoryStatsError,
          TData,
          ServiceOperationQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetUsageHistoryStatsError | Error>;
    /** @summary Get historical usage stats for a wallet address. */
    fetchInfiniteQuery<TPageParam extends GetUsageHistoryStatsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetUsageHistoryStatsSchema,
        GetUsageHistoryStatsData,
        GetUsageHistoryStatsParameters,
        DeepReadonly<TPageParam>,
        GetUsageHistoryStatsError
      >
    ): Promise<OperationInfiniteData<GetUsageHistoryStatsData, GetUsageHistoryStatsParameters>>;
    /** @summary Get historical usage stats for a wallet address. */
    prefetchInfiniteQuery<TPageParam extends GetUsageHistoryStatsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetUsageHistoryStatsSchema,
        GetUsageHistoryStatsData,
        GetUsageHistoryStatsParameters,
        DeepReadonly<TPageParam>,
        GetUsageHistoryStatsError
      >
    ): Promise<void>;
    /** @summary Get historical usage stats for a wallet address. */
    ensureInfiniteQueryData<TPageParam extends GetUsageHistoryStatsParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetUsageHistoryStatsSchema,
        GetUsageHistoryStatsData,
        GetUsageHistoryStatsParameters,
        DeepReadonly<TPageParam>,
        GetUsageHistoryStatsError
      >
    ): Promise<OperationInfiniteData<GetUsageHistoryStatsData, GetUsageHistoryStatsParameters>>;
    /** @summary Get historical usage stats for a wallet address. */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetUsageHistoryStatsSchema,
        GetUsageHistoryStatsData,
        GetUsageHistoryStatsParameters,
        GetUsageHistoryStatsError
      >
    ): Promise<GetUsageHistoryStatsData>;
    /** @summary Get historical usage stats for a wallet address. */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetUsageHistoryStatsSchema,
        GetUsageHistoryStatsData,
        GetUsageHistoryStatsParameters,
        GetUsageHistoryStatsError
      >
    ): Promise<void>;
    /** @summary Get historical usage stats for a wallet address. */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetUsageHistoryStatsSchema,
        GetUsageHistoryStatsData,
        GetUsageHistoryStatsParameters,
        GetUsageHistoryStatsError
      >
    ): Promise<GetUsageHistoryStatsData>;
    /** @summary Get historical usage stats for a wallet address. */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters> | DeepReadonly<GetUsageHistoryStatsParameters>
    ): OperationInfiniteData<GetUsageHistoryStatsData, GetUsageHistoryStatsParameters> | undefined;
    /** @summary Get historical usage stats for a wallet address. */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetUsageHistoryStatsSchema, GetUsageHistoryStatsData, TInfinite, GetUsageHistoryStatsParameters, GetUsageHistoryStatsError>
        | QueryFiltersByQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsData, TInfinite, GetUsageHistoryStatsParameters, GetUsageHistoryStatsError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters>,
            data: NoInfer<OperationInfiniteData<GetUsageHistoryStatsData, GetUsageHistoryStatsParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters>, data: GetUsageHistoryStatsData | undefined]>;
    /** @summary Get historical usage stats for a wallet address. */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters> | DeepReadonly<GetUsageHistoryStatsParameters>
    ): GetUsageHistoryStatsData | undefined;
    /** @summary Get historical usage stats for a wallet address. */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters> | DeepReadonly<GetUsageHistoryStatsParameters>
    ): QueryState<GetUsageHistoryStatsData, GetUsageHistoryStatsError> | undefined;
    /** @summary Get historical usage stats for a wallet address. */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetUsageHistoryStatsParameters> | ServiceOperationInfiniteQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters>
    ): QueryState<OperationInfiniteData<GetUsageHistoryStatsData, GetUsageHistoryStatsParameters>, GetUsageHistoryStatsError> | undefined;
    /** @summary Get historical usage stats for a wallet address. */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<
        GetUsageHistoryStatsSchema,
        GetUsageHistoryStatsData,
        TInfinite,
        GetUsageHistoryStatsParameters,
        GetUsageHistoryStatsError
      >,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get historical usage stats for a wallet address. */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetUsageHistoryStatsSchema, GetUsageHistoryStatsData, TInfinite, GetUsageHistoryStatsParameters, GetUsageHistoryStatsError>
        | QueryFiltersByQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsData, TInfinite, GetUsageHistoryStatsParameters, GetUsageHistoryStatsError>
    ): number;
    /** @summary Get historical usage stats for a wallet address. */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetUsageHistoryStatsParameters, TMeta, TSignal>,
      client?: (
        schema: GetUsageHistoryStatsSchema,
        options: {
          parameters: GetUsageHistoryStatsParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetUsageHistoryStatsData, GetUsageHistoryStatsError>>
    ): Promise<RequestFnResponse<GetUsageHistoryStatsData, GetUsageHistoryStatsError>>;
    /** @summary Get historical usage stats for a wallet address. */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetUsageHistoryStatsSchema, GetUsageHistoryStatsData, TInfinite, GetUsageHistoryStatsParameters, GetUsageHistoryStatsError>
        | QueryFiltersByQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsData, TInfinite, GetUsageHistoryStatsParameters, GetUsageHistoryStatsError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get historical usage stats for a wallet address. */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetUsageHistoryStatsSchema, GetUsageHistoryStatsData, TInfinite, GetUsageHistoryStatsParameters, GetUsageHistoryStatsError>
        | QueryFiltersByQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsData, TInfinite, GetUsageHistoryStatsParameters, GetUsageHistoryStatsError>
    ): void;
    /** @summary Get historical usage stats for a wallet address. */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetUsageHistoryStatsSchema, GetUsageHistoryStatsData, TInfinite, GetUsageHistoryStatsParameters, GetUsageHistoryStatsError>
        | QueryFiltersByQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsData, TInfinite, GetUsageHistoryStatsParameters, GetUsageHistoryStatsError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get historical usage stats for a wallet address. */
    setInfiniteQueryData(
      parameters: DeepReadonly<GetUsageHistoryStatsParameters> | ServiceOperationInfiniteQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetUsageHistoryStatsData, GetUsageHistoryStatsParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetUsageHistoryStatsData, GetUsageHistoryStatsParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetUsageHistoryStatsData, GetUsageHistoryStatsParameters> | undefined;
    /** @summary Get historical usage stats for a wallet address. */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetUsageHistoryStatsSchema, GetUsageHistoryStatsData, TInfinite, GetUsageHistoryStatsParameters, GetUsageHistoryStatsError>
        | QueryFiltersByQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsData, TInfinite, GetUsageHistoryStatsParameters, GetUsageHistoryStatsError>,
      updater: Updater<NoInfer<GetUsageHistoryStatsData> | undefined, NoInfer<GetUsageHistoryStatsData> | undefined>,
      options?: SetDataOptions
    ): Array<GetUsageHistoryStatsData | undefined>;
    /** @summary Get historical usage stats for a wallet address. */
    setQueryData(
      parameters: DeepReadonly<GetUsageHistoryStatsParameters> | ServiceOperationQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters>,
      updater: Updater<NoInfer<GetUsageHistoryStatsData> | undefined, NoInfer<DeepReadonly<GetUsageHistoryStatsData>> | undefined>,
      options?: SetDataOptions
    ): GetUsageHistoryStatsData | undefined;
    /** @summary Get historical usage stats for a wallet address. */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetUsageHistoryStatsParameters>
    ): ServiceOperationInfiniteQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get historical usage stats for a wallet address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getUsageHistoryStats.useInfiniteQuery({
     *     query: {
     *         address: address
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             address: initialAddress
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetUsageHistoryStatsParameters,
      TQueryFnData = GetUsageHistoryStatsData,
      TData = OperationInfiniteData<TQueryFnData, GetUsageHistoryStatsParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters> | DeepReadonly<GetUsageHistoryStatsParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetUsageHistoryStatsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetUsageHistoryStatsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get historical usage stats for a wallet address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getUsageHistoryStats.useInfiniteQuery({
     *     query: {
     *         address: address
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             address: initialAddress
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetUsageHistoryStatsParameters,
      TQueryFnData = GetUsageHistoryStatsData,
      TData = OperationInfiniteData<TQueryFnData, GetUsageHistoryStatsParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters> | DeepReadonly<GetUsageHistoryStatsParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetUsageHistoryStatsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetUsageHistoryStatsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetUsageHistoryStatsError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get historical usage stats for a wallet address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getUsageHistoryStatsTotal = qraft.v1Service.getUsageHistoryStats.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getUsageHistoryStatsByParametersTotal = qraft.v1Service.getUsageHistoryStats.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         query: {
     *             address: address
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetUsageHistoryStatsSchema, GetUsageHistoryStatsData, TInfinite, GetUsageHistoryStatsParameters, GetUsageHistoryStatsError>
        | QueryFiltersByQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsData, TInfinite, GetUsageHistoryStatsParameters, GetUsageHistoryStatsError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get historical usage stats for a wallet address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getUsageHistoryStatsResults = qraft.v1Service.getUsageHistoryStats.useQueries({
     *     queries: [
     *         {
     *             query: {
     *                 address: address1
     *             }
     *         },
     *         {
     *             query: {
     *                 address: address2
     *             }
     *         }
     *     ]
     * });
     * getUsageHistoryStatsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getUsageHistoryStatsCombinedResults = qraft.v1Service.getUsageHistoryStats.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 address: address1
     *             }
     *         },
     *         {
     *             query: {
     *                 address: address2
     *             }
     *         }
     *     ]
     * });
     * getUsageHistoryStatsCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters, GetUsageHistoryStatsData, GetUsageHistoryStatsError>
      >,
      TCombinedResult = Array<UseQueryResult<GetUsageHistoryStatsData, GetUsageHistoryStatsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetUsageHistoryStatsData, GetUsageHistoryStatsError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get historical usage stats for a wallet address. */
    getQueryKey(parameters: DeepReadonly<GetUsageHistoryStatsParameters>): ServiceOperationQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get historical usage stats for a wallet address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getUsageHistoryStats.useQuery({
     *     query: {
     *         address: address
     *     }
     * })
     * ```
     */
    useQuery<TData = GetUsageHistoryStatsData>(
      parameters: ServiceOperationQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters> | DeepReadonly<GetUsageHistoryStatsParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetUsageHistoryStatsData,
          GetUsageHistoryStatsError,
          TData,
          ServiceOperationQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetUsageHistoryStatsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get historical usage stats for a wallet address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getUsageHistoryStats.useQuery({
     *     query: {
     *         address: address
     *     }
     * })
     * ```
     */
    useQuery<TData = GetUsageHistoryStatsData>(
      parameters: ServiceOperationQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters> | DeepReadonly<GetUsageHistoryStatsParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetUsageHistoryStatsData,
          GetUsageHistoryStatsError,
          TData,
          ServiceOperationQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetUsageHistoryStatsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get historical usage stats for a wallet address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getUsageHistoryStats.useSuspenseInfiniteQuery({
     *     query: {
     *         address: address
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             address: initialAddress
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetUsageHistoryStatsParameters, TData = GetUsageHistoryStatsData>(
      parameters: ServiceOperationInfiniteQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters> | DeepReadonly<GetUsageHistoryStatsParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetUsageHistoryStatsData,
          GetUsageHistoryStatsError,
          OperationInfiniteData<TData, GetUsageHistoryStatsParameters>,
          GetUsageHistoryStatsData,
          ServiceOperationInfiniteQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetUsageHistoryStatsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetUsageHistoryStatsParameters>, GetUsageHistoryStatsError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get historical usage stats for a wallet address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getUsageHistoryStatsData = qraft.v1Service.getUsageHistoryStats.useSuspenseQueries({
     *     queries: [
     *         {
     *             query: {
     *                 address: address1
     *             }
     *         },
     *         {
     *             query: {
     *                 address: address2
     *             }
     *         }
     *     ]
     * });
     * getUsageHistoryStatsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getUsageHistoryStatsCombinedData = qraft.v1Service.getUsageHistoryStats.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 address: address1
     *             }
     *         },
     *         {
     *             query: {
     *                 address: address2
     *             }
     *         }
     *     ]
     * });
     * getUsageHistoryStatsCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters, GetUsageHistoryStatsData, GetUsageHistoryStatsError>
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetUsageHistoryStatsData, GetUsageHistoryStatsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetUsageHistoryStatsData, GetUsageHistoryStatsError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get historical usage stats for a wallet address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getUsageHistoryStats.useSuspenseQuery({
     *     query: {
     *         address: address
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetUsageHistoryStatsData>(
      parameters: ServiceOperationQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters> | DeepReadonly<GetUsageHistoryStatsParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<
          GetUsageHistoryStatsData,
          GetUsageHistoryStatsError,
          TData,
          ServiceOperationQueryKey<GetUsageHistoryStatsSchema, GetUsageHistoryStatsParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetUsageHistoryStatsError | Error>;
    schema: GetUsageHistoryStatsSchema;
    types: {
      parameters: GetUsageHistoryStatsParameters;
      data: GetUsageHistoryStatsData;
      error: GetUsageHistoryStatsError;
    };
  };
  /** @summary Creates an anonymous user */
  postAnonymousUsers: {
    /** @summary Creates an anonymous user */
    getMutationKey(
      parameters: DeepReadonly<PostAnonymousUsersParameters> | void
    ): ServiceOperationMutationKey<PostAnonymousUsersSchema, PostAnonymousUsersParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Creates an anonymous user
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postAnonymousUsers.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postAnonymousUsers.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends PostAnonymousUsersBody, TContext = unknown>(
      parameters: DeepReadonly<PostAnonymousUsersParameters>,
      options?: ServiceOperationUseMutationOptions<
        PostAnonymousUsersSchema,
        PostAnonymousUsersData,
        PostAnonymousUsersParameters,
        TVariables,
        PostAnonymousUsersError | Error,
        TContext
      >
    ): UseMutationResult<PostAnonymousUsersData, PostAnonymousUsersError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Creates an anonymous user
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postAnonymousUsers.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postAnonymousUsers.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PostAnonymousUsersBody, PostAnonymousUsersParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PostAnonymousUsersSchema,
        PostAnonymousUsersData,
        PostAnonymousUsersParameters,
        TVariables,
        PostAnonymousUsersError | Error,
        TContext
      >
    ): UseMutationResult<PostAnonymousUsersData, PostAnonymousUsersError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Creates an anonymous user
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const postAnonymousUsersTotal = qraft.v1Service.postAnonymousUsers.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const postAnonymousUsersTotal = qraft.v1Service.postAnonymousUsers.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<PostAnonymousUsersBody, PostAnonymousUsersData, PostAnonymousUsersParameters, PostAnonymousUsersError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostAnonymousUsersSchema,
            PostAnonymousUsersBody,
            PostAnonymousUsersData,
            PostAnonymousUsersParameters,
            PostAnonymousUsersError | Error,
            TContext
          >
    ): number;
    /** @summary Creates an anonymous user */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<PostAnonymousUsersBody, PostAnonymousUsersData, PostAnonymousUsersParameters, PostAnonymousUsersError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostAnonymousUsersSchema,
            PostAnonymousUsersBody,
            PostAnonymousUsersData,
            PostAnonymousUsersParameters,
            PostAnonymousUsersError | Error,
            TContext
          >
    ): number;
    /** @summary Creates an anonymous user */
    (
      options: ServiceOperationMutationFnOptions<PostAnonymousUsersBody, PostAnonymousUsersParameters>,
      client?: (
        schema: PostAnonymousUsersSchema,
        options: ServiceOperationMutationFnOptions<PostAnonymousUsersBody, PostAnonymousUsersParameters>
      ) => Promise<RequestFnResponse<PostAnonymousUsersData, PostAnonymousUsersError>>
    ): Promise<RequestFnResponse<PostAnonymousUsersData, PostAnonymousUsersError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Creates an anonymous user
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const postAnonymousUsersPendingMutationVariables = qraft.v1Service.postAnonymousUsers.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const postAnonymousUsersMutationData = qraft.v1Service.postAnonymousUsers.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        PostAnonymousUsersData,
        PostAnonymousUsersError | Error,
        MutationVariables<PostAnonymousUsersBody, PostAnonymousUsersParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<PostAnonymousUsersBody, PostAnonymousUsersData, PostAnonymousUsersParameters, PostAnonymousUsersError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostAnonymousUsersSchema,
            PostAnonymousUsersBody,
            PostAnonymousUsersData,
            PostAnonymousUsersParameters,
            PostAnonymousUsersError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          PostAnonymousUsersData,
          PostAnonymousUsersError | Error,
          MutationVariables<PostAnonymousUsersBody, PostAnonymousUsersParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: PostAnonymousUsersSchema;
    types: {
      parameters: PostAnonymousUsersParameters;
      data: PostAnonymousUsersData;
      error: PostAnonymousUsersError;
      body: PostAnonymousUsersBody;
    };
  };
  /** @summary Retrieves an anonymous user by id */
  getAnonymousUsersId: {
    /** @summary Retrieves an anonymous user by id */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAnonymousUsersIdSchema, GetAnonymousUsersIdData, TInfinite, GetAnonymousUsersIdParameters, GetAnonymousUsersIdError>
        | QueryFiltersByQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdData, TInfinite, GetAnonymousUsersIdParameters, GetAnonymousUsersIdError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Retrieves an anonymous user by id */
    getQueryKey(parameters: DeepReadonly<GetAnonymousUsersIdParameters>): ServiceOperationQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Retrieves an anonymous user by id
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAnonymousUsersId.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAnonymousUsersIdData>(
      parameters: ServiceOperationQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters> | DeepReadonly<GetAnonymousUsersIdParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetAnonymousUsersIdData,
          GetAnonymousUsersIdError,
          TData,
          ServiceOperationQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetAnonymousUsersIdError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Retrieves an anonymous user by id
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAnonymousUsersId.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAnonymousUsersIdData>(
      parameters: ServiceOperationQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters> | DeepReadonly<GetAnonymousUsersIdParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetAnonymousUsersIdData,
          GetAnonymousUsersIdError,
          TData,
          ServiceOperationQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetAnonymousUsersIdError | Error>;
    /** @summary Retrieves an anonymous user by id */
    fetchInfiniteQuery<TPageParam extends GetAnonymousUsersIdParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetAnonymousUsersIdSchema,
        GetAnonymousUsersIdData,
        GetAnonymousUsersIdParameters,
        DeepReadonly<TPageParam>,
        GetAnonymousUsersIdError
      >
    ): Promise<OperationInfiniteData<GetAnonymousUsersIdData, GetAnonymousUsersIdParameters>>;
    /** @summary Retrieves an anonymous user by id */
    prefetchInfiniteQuery<TPageParam extends GetAnonymousUsersIdParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetAnonymousUsersIdSchema,
        GetAnonymousUsersIdData,
        GetAnonymousUsersIdParameters,
        DeepReadonly<TPageParam>,
        GetAnonymousUsersIdError
      >
    ): Promise<void>;
    /** @summary Retrieves an anonymous user by id */
    ensureInfiniteQueryData<TPageParam extends GetAnonymousUsersIdParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetAnonymousUsersIdSchema,
        GetAnonymousUsersIdData,
        GetAnonymousUsersIdParameters,
        DeepReadonly<TPageParam>,
        GetAnonymousUsersIdError
      >
    ): Promise<OperationInfiniteData<GetAnonymousUsersIdData, GetAnonymousUsersIdParameters>>;
    /** @summary Retrieves an anonymous user by id */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetAnonymousUsersIdSchema, GetAnonymousUsersIdData, GetAnonymousUsersIdParameters, GetAnonymousUsersIdError>
    ): Promise<GetAnonymousUsersIdData>;
    /** @summary Retrieves an anonymous user by id */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetAnonymousUsersIdSchema, GetAnonymousUsersIdData, GetAnonymousUsersIdParameters, GetAnonymousUsersIdError>
    ): Promise<void>;
    /** @summary Retrieves an anonymous user by id */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetAnonymousUsersIdSchema,
        GetAnonymousUsersIdData,
        GetAnonymousUsersIdParameters,
        GetAnonymousUsersIdError
      >
    ): Promise<GetAnonymousUsersIdData>;
    /** @summary Retrieves an anonymous user by id */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters> | DeepReadonly<GetAnonymousUsersIdParameters>
    ): OperationInfiniteData<GetAnonymousUsersIdData, GetAnonymousUsersIdParameters> | undefined;
    /** @summary Retrieves an anonymous user by id */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAnonymousUsersIdSchema, GetAnonymousUsersIdData, TInfinite, GetAnonymousUsersIdParameters, GetAnonymousUsersIdError>
        | QueryFiltersByQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdData, TInfinite, GetAnonymousUsersIdParameters, GetAnonymousUsersIdError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters>,
            data: NoInfer<OperationInfiniteData<GetAnonymousUsersIdData, GetAnonymousUsersIdParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters>, data: GetAnonymousUsersIdData | undefined]>;
    /** @summary Retrieves an anonymous user by id */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters> | DeepReadonly<GetAnonymousUsersIdParameters>
    ): GetAnonymousUsersIdData | undefined;
    /** @summary Retrieves an anonymous user by id */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters> | DeepReadonly<GetAnonymousUsersIdParameters>
    ): QueryState<GetAnonymousUsersIdData, GetAnonymousUsersIdError> | undefined;
    /** @summary Retrieves an anonymous user by id */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetAnonymousUsersIdParameters> | ServiceOperationInfiniteQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters>
    ): QueryState<OperationInfiniteData<GetAnonymousUsersIdData, GetAnonymousUsersIdParameters>, GetAnonymousUsersIdError> | undefined;
    /** @summary Retrieves an anonymous user by id */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetAnonymousUsersIdSchema, GetAnonymousUsersIdData, TInfinite, GetAnonymousUsersIdParameters, GetAnonymousUsersIdError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Retrieves an anonymous user by id */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAnonymousUsersIdSchema, GetAnonymousUsersIdData, TInfinite, GetAnonymousUsersIdParameters, GetAnonymousUsersIdError>
        | QueryFiltersByQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdData, TInfinite, GetAnonymousUsersIdParameters, GetAnonymousUsersIdError>
    ): number;
    /** @summary Retrieves an anonymous user by id */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetAnonymousUsersIdParameters, TMeta, TSignal>,
      client?: (
        schema: GetAnonymousUsersIdSchema,
        options: {
          parameters: GetAnonymousUsersIdParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetAnonymousUsersIdData, GetAnonymousUsersIdError>>
    ): Promise<RequestFnResponse<GetAnonymousUsersIdData, GetAnonymousUsersIdError>>;
    /** @summary Retrieves an anonymous user by id */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAnonymousUsersIdSchema, GetAnonymousUsersIdData, TInfinite, GetAnonymousUsersIdParameters, GetAnonymousUsersIdError>
        | QueryFiltersByQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdData, TInfinite, GetAnonymousUsersIdParameters, GetAnonymousUsersIdError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Retrieves an anonymous user by id */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAnonymousUsersIdSchema, GetAnonymousUsersIdData, TInfinite, GetAnonymousUsersIdParameters, GetAnonymousUsersIdError>
        | QueryFiltersByQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdData, TInfinite, GetAnonymousUsersIdParameters, GetAnonymousUsersIdError>
    ): void;
    /** @summary Retrieves an anonymous user by id */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAnonymousUsersIdSchema, GetAnonymousUsersIdData, TInfinite, GetAnonymousUsersIdParameters, GetAnonymousUsersIdError>
        | QueryFiltersByQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdData, TInfinite, GetAnonymousUsersIdParameters, GetAnonymousUsersIdError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Retrieves an anonymous user by id */
    setInfiniteQueryData(
      parameters: DeepReadonly<GetAnonymousUsersIdParameters> | ServiceOperationInfiniteQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetAnonymousUsersIdData, GetAnonymousUsersIdParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetAnonymousUsersIdData, GetAnonymousUsersIdParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetAnonymousUsersIdData, GetAnonymousUsersIdParameters> | undefined;
    /** @summary Retrieves an anonymous user by id */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetAnonymousUsersIdSchema, GetAnonymousUsersIdData, TInfinite, GetAnonymousUsersIdParameters, GetAnonymousUsersIdError>
        | QueryFiltersByQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdData, TInfinite, GetAnonymousUsersIdParameters, GetAnonymousUsersIdError>,
      updater: Updater<NoInfer<GetAnonymousUsersIdData> | undefined, NoInfer<GetAnonymousUsersIdData> | undefined>,
      options?: SetDataOptions
    ): Array<GetAnonymousUsersIdData | undefined>;
    /** @summary Retrieves an anonymous user by id */
    setQueryData(
      parameters: DeepReadonly<GetAnonymousUsersIdParameters> | ServiceOperationQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters>,
      updater: Updater<NoInfer<GetAnonymousUsersIdData> | undefined, NoInfer<DeepReadonly<GetAnonymousUsersIdData>> | undefined>,
      options?: SetDataOptions
    ): GetAnonymousUsersIdData | undefined;
    /** @summary Retrieves an anonymous user by id */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetAnonymousUsersIdParameters>
    ): ServiceOperationInfiniteQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Retrieves an anonymous user by id
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAnonymousUsersId.useInfiniteQuery({
     *     path: {
     *         id: id
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetAnonymousUsersIdParameters,
      TQueryFnData = GetAnonymousUsersIdData,
      TData = OperationInfiniteData<TQueryFnData, GetAnonymousUsersIdParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters> | DeepReadonly<GetAnonymousUsersIdParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetAnonymousUsersIdError,
          TData,
          ServiceOperationInfiniteQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetAnonymousUsersIdError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Retrieves an anonymous user by id
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAnonymousUsersId.useInfiniteQuery({
     *     path: {
     *         id: id
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetAnonymousUsersIdParameters,
      TQueryFnData = GetAnonymousUsersIdData,
      TData = OperationInfiniteData<TQueryFnData, GetAnonymousUsersIdParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters> | DeepReadonly<GetAnonymousUsersIdParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetAnonymousUsersIdError,
          TData,
          ServiceOperationInfiniteQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetAnonymousUsersIdData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetAnonymousUsersIdError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Retrieves an anonymous user by id
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getAnonymousUsersIdTotal = qraft.v1Service.getAnonymousUsersId.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getAnonymousUsersIdByParametersTotal = qraft.v1Service.getAnonymousUsersId.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             id: id
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAnonymousUsersIdSchema, GetAnonymousUsersIdData, TInfinite, GetAnonymousUsersIdParameters, GetAnonymousUsersIdError>
        | QueryFiltersByQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdData, TInfinite, GetAnonymousUsersIdParameters, GetAnonymousUsersIdError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Retrieves an anonymous user by id
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getAnonymousUsersIdResults = qraft.v1Service.getAnonymousUsersId.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getAnonymousUsersIdResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getAnonymousUsersIdCombinedResults = qraft.v1Service.getAnonymousUsersId.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getAnonymousUsersIdCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters, GetAnonymousUsersIdData, GetAnonymousUsersIdError>
      >,
      TCombinedResult = Array<UseQueryResult<GetAnonymousUsersIdData, GetAnonymousUsersIdError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetAnonymousUsersIdData, GetAnonymousUsersIdError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Retrieves an anonymous user by id */
    getQueryKey(parameters: DeepReadonly<GetAnonymousUsersIdParameters>): ServiceOperationQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Retrieves an anonymous user by id
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAnonymousUsersId.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAnonymousUsersIdData>(
      parameters: ServiceOperationQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters> | DeepReadonly<GetAnonymousUsersIdParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetAnonymousUsersIdData,
          GetAnonymousUsersIdError,
          TData,
          ServiceOperationQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetAnonymousUsersIdError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Retrieves an anonymous user by id
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAnonymousUsersId.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAnonymousUsersIdData>(
      parameters: ServiceOperationQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters> | DeepReadonly<GetAnonymousUsersIdParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetAnonymousUsersIdData,
          GetAnonymousUsersIdError,
          TData,
          ServiceOperationQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetAnonymousUsersIdError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Retrieves an anonymous user by id
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAnonymousUsersId.useSuspenseInfiniteQuery({
     *     path: {
     *         id: id
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetAnonymousUsersIdParameters, TData = GetAnonymousUsersIdData>(
      parameters: ServiceOperationInfiniteQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters> | DeepReadonly<GetAnonymousUsersIdParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetAnonymousUsersIdData,
          GetAnonymousUsersIdError,
          OperationInfiniteData<TData, GetAnonymousUsersIdParameters>,
          GetAnonymousUsersIdData,
          ServiceOperationInfiniteQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetAnonymousUsersIdData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetAnonymousUsersIdParameters>, GetAnonymousUsersIdError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Retrieves an anonymous user by id
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getAnonymousUsersIdData = qraft.v1Service.getAnonymousUsersId.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getAnonymousUsersIdResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getAnonymousUsersIdCombinedData = qraft.v1Service.getAnonymousUsersId.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getAnonymousUsersIdCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters, GetAnonymousUsersIdData, GetAnonymousUsersIdError>
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetAnonymousUsersIdData, GetAnonymousUsersIdError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetAnonymousUsersIdData, GetAnonymousUsersIdError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Retrieves an anonymous user by id
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getAnonymousUsersId.useSuspenseQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetAnonymousUsersIdData>(
      parameters: ServiceOperationQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters> | DeepReadonly<GetAnonymousUsersIdParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<
          GetAnonymousUsersIdData,
          GetAnonymousUsersIdError,
          TData,
          ServiceOperationQueryKey<GetAnonymousUsersIdSchema, GetAnonymousUsersIdParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetAnonymousUsersIdError | Error>;
    schema: GetAnonymousUsersIdSchema;
    types: {
      parameters: GetAnonymousUsersIdParameters;
      data: GetAnonymousUsersIdData;
      error: GetAnonymousUsersIdError;
    };
  };
  /** @summary Registers a new user */
  postRegisterUser: {
    /** @summary Registers a new user */
    getMutationKey(
      parameters: DeepReadonly<PostRegisterUserParameters> | void
    ): ServiceOperationMutationKey<PostRegisterUserSchema, PostRegisterUserParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Registers a new user
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postRegisterUser.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postRegisterUser.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends PostRegisterUserBody, TContext = unknown>(
      parameters: DeepReadonly<PostRegisterUserParameters>,
      options?: ServiceOperationUseMutationOptions<
        PostRegisterUserSchema,
        PostRegisterUserData,
        PostRegisterUserParameters,
        TVariables,
        PostRegisterUserError | Error,
        TContext
      >
    ): UseMutationResult<PostRegisterUserData, PostRegisterUserError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Registers a new user
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postRegisterUser.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postRegisterUser.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PostRegisterUserBody, PostRegisterUserParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PostRegisterUserSchema,
        PostRegisterUserData,
        PostRegisterUserParameters,
        TVariables,
        PostRegisterUserError | Error,
        TContext
      >
    ): UseMutationResult<PostRegisterUserData, PostRegisterUserError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Registers a new user
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const postRegisterUserTotal = qraft.v1Service.postRegisterUser.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const postRegisterUserTotal = qraft.v1Service.postRegisterUser.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<PostRegisterUserBody, PostRegisterUserData, PostRegisterUserParameters, PostRegisterUserError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostRegisterUserSchema,
            PostRegisterUserBody,
            PostRegisterUserData,
            PostRegisterUserParameters,
            PostRegisterUserError | Error,
            TContext
          >
    ): number;
    /** @summary Registers a new user */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<PostRegisterUserBody, PostRegisterUserData, PostRegisterUserParameters, PostRegisterUserError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostRegisterUserSchema,
            PostRegisterUserBody,
            PostRegisterUserData,
            PostRegisterUserParameters,
            PostRegisterUserError | Error,
            TContext
          >
    ): number;
    /** @summary Registers a new user */
    (
      options: ServiceOperationMutationFnOptions<PostRegisterUserBody, PostRegisterUserParameters>,
      client?: (
        schema: PostRegisterUserSchema,
        options: ServiceOperationMutationFnOptions<PostRegisterUserBody, PostRegisterUserParameters>
      ) => Promise<RequestFnResponse<PostRegisterUserData, PostRegisterUserError>>
    ): Promise<RequestFnResponse<PostRegisterUserData, PostRegisterUserError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Registers a new user
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const postRegisterUserPendingMutationVariables = qraft.v1Service.postRegisterUser.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const postRegisterUserMutationData = qraft.v1Service.postRegisterUser.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        PostRegisterUserData,
        PostRegisterUserError | Error,
        MutationVariables<PostRegisterUserBody, PostRegisterUserParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<PostRegisterUserBody, PostRegisterUserData, PostRegisterUserParameters, PostRegisterUserError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostRegisterUserSchema,
            PostRegisterUserBody,
            PostRegisterUserData,
            PostRegisterUserParameters,
            PostRegisterUserError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<PostRegisterUserData, PostRegisterUserError | Error, MutationVariables<PostRegisterUserBody, PostRegisterUserParameters>, TContext>
      ) => TResult;
    }): Array<TResult>;
    schema: PostRegisterUserSchema;
    types: {
      parameters: PostRegisterUserParameters;
      data: PostRegisterUserData;
      error: PostRegisterUserError;
      body: PostRegisterUserBody;
    };
  };
  /** @summary Retrieves the logged in user */
  getUserMe: {
    /** @summary Retrieves the logged in user */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetUserMeSchema, GetUserMeData, TInfinite, GetUserMeParameters, GetUserMeError>
        | QueryFiltersByQueryKey<GetUserMeSchema, GetUserMeData, TInfinite, GetUserMeParameters, GetUserMeError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Retrieves the logged in user */
    getQueryKey(parameters: DeepReadonly<GetUserMeParameters> | void): ServiceOperationQueryKey<GetUserMeSchema, GetUserMeParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Retrieves the logged in user
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getUserMe.useQuery()
     * ```
     */
    useQuery<TData = GetUserMeData>(
      parameters: ServiceOperationQueryKey<GetUserMeSchema, GetUserMeParameters> | (DeepReadonly<GetUserMeParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetUserMeData, GetUserMeError, TData, ServiceOperationQueryKey<GetUserMeSchema, GetUserMeParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetUserMeError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Retrieves the logged in user
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getUserMe.useQuery()
     * ```
     */
    useQuery<TData = GetUserMeData>(
      parameters: ServiceOperationQueryKey<GetUserMeSchema, GetUserMeParameters> | (DeepReadonly<GetUserMeParameters> | void),
      options: Omit<DefinedInitialDataOptions<GetUserMeData, GetUserMeError, TData, ServiceOperationQueryKey<GetUserMeSchema, GetUserMeParameters>>, "queryKey">
    ): DefinedUseQueryResult<TData, GetUserMeError | Error>;
    /** @summary Retrieves the logged in user */
    fetchInfiniteQuery<TPageParam extends GetUserMeParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<GetUserMeSchema, GetUserMeData, GetUserMeParameters, DeepReadonly<TPageParam>, GetUserMeError> | void
    ): Promise<OperationInfiniteData<GetUserMeData, GetUserMeParameters>>;
    /** @summary Retrieves the logged in user */
    prefetchInfiniteQuery<TPageParam extends GetUserMeParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<GetUserMeSchema, GetUserMeData, GetUserMeParameters, DeepReadonly<TPageParam>, GetUserMeError> | void
    ): Promise<void>;
    /** @summary Retrieves the logged in user */
    ensureInfiniteQueryData<TPageParam extends GetUserMeParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetUserMeSchema,
        GetUserMeData,
        GetUserMeParameters,
        DeepReadonly<TPageParam>,
        GetUserMeError
      > | void
    ): Promise<OperationInfiniteData<GetUserMeData, GetUserMeParameters>>;
    /** @summary Retrieves the logged in user */
    fetchQuery(options: ServiceOperationFetchQueryOptions<GetUserMeSchema, GetUserMeData, GetUserMeParameters, GetUserMeError> | void): Promise<GetUserMeData>;
    /** @summary Retrieves the logged in user */
    prefetchQuery(options: ServiceOperationFetchQueryOptions<GetUserMeSchema, GetUserMeData, GetUserMeParameters, GetUserMeError> | void): Promise<void>;
    /** @summary Retrieves the logged in user */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetUserMeSchema, GetUserMeData, GetUserMeParameters, GetUserMeError> | void
    ): Promise<GetUserMeData>;
    /** @summary Retrieves the logged in user */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetUserMeSchema, GetUserMeParameters> | (DeepReadonly<GetUserMeParameters> | void)
    ): OperationInfiniteData<GetUserMeData, GetUserMeParameters> | undefined;
    /** @summary Retrieves the logged in user */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetUserMeSchema, GetUserMeData, TInfinite, GetUserMeParameters, GetUserMeError>
        | QueryFiltersByQueryKey<GetUserMeSchema, GetUserMeData, TInfinite, GetUserMeParameters, GetUserMeError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetUserMeSchema, GetUserMeParameters>,
            data: NoInfer<OperationInfiniteData<GetUserMeData, GetUserMeParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetUserMeSchema, GetUserMeParameters>, data: GetUserMeData | undefined]>;
    /** @summary Retrieves the logged in user */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetUserMeSchema, GetUserMeParameters> | (DeepReadonly<GetUserMeParameters> | void)
    ): GetUserMeData | undefined;
    /** @summary Retrieves the logged in user */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetUserMeSchema, GetUserMeParameters> | (DeepReadonly<GetUserMeParameters> | void)
    ): QueryState<GetUserMeData, GetUserMeError> | undefined;
    /** @summary Retrieves the logged in user */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetUserMeParameters> | ServiceOperationInfiniteQueryKey<GetUserMeSchema, GetUserMeParameters> | void
    ): QueryState<OperationInfiniteData<GetUserMeData, GetUserMeParameters>, GetUserMeError> | undefined;
    /** @summary Retrieves the logged in user */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetUserMeSchema, GetUserMeData, TInfinite, GetUserMeParameters, GetUserMeError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Retrieves the logged in user */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetUserMeSchema, GetUserMeData, TInfinite, GetUserMeParameters, GetUserMeError>
        | QueryFiltersByQueryKey<GetUserMeSchema, GetUserMeData, TInfinite, GetUserMeParameters, GetUserMeError>
    ): number;
    /** @summary Retrieves the logged in user */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetUserMeSchema, GetUserMeParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetUserMeParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetUserMeSchema,
        options: {
          parameters: GetUserMeParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetUserMeData, GetUserMeError>>
    ): Promise<RequestFnResponse<GetUserMeData, GetUserMeError>>;
    /** @summary Retrieves the logged in user */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetUserMeSchema, GetUserMeData, TInfinite, GetUserMeParameters, GetUserMeError>
        | QueryFiltersByQueryKey<GetUserMeSchema, GetUserMeData, TInfinite, GetUserMeParameters, GetUserMeError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Retrieves the logged in user */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetUserMeSchema, GetUserMeData, TInfinite, GetUserMeParameters, GetUserMeError>
        | QueryFiltersByQueryKey<GetUserMeSchema, GetUserMeData, TInfinite, GetUserMeParameters, GetUserMeError>
    ): void;
    /** @summary Retrieves the logged in user */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetUserMeSchema, GetUserMeData, TInfinite, GetUserMeParameters, GetUserMeError>
        | QueryFiltersByQueryKey<GetUserMeSchema, GetUserMeData, TInfinite, GetUserMeParameters, GetUserMeError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Retrieves the logged in user */
    setInfiniteQueryData(
      parameters: (DeepReadonly<GetUserMeParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetUserMeSchema, GetUserMeParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetUserMeData, GetUserMeParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetUserMeData, GetUserMeParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetUserMeData, GetUserMeParameters> | undefined;
    /** @summary Retrieves the logged in user */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetUserMeSchema, GetUserMeData, TInfinite, GetUserMeParameters, GetUserMeError>
        | QueryFiltersByQueryKey<GetUserMeSchema, GetUserMeData, TInfinite, GetUserMeParameters, GetUserMeError>,
      updater: Updater<NoInfer<GetUserMeData> | undefined, NoInfer<GetUserMeData> | undefined>,
      options?: SetDataOptions
    ): Array<GetUserMeData | undefined>;
    /** @summary Retrieves the logged in user */
    setQueryData(
      parameters: (DeepReadonly<GetUserMeParameters> | undefined) | ServiceOperationQueryKey<GetUserMeSchema, GetUserMeParameters>,
      updater: Updater<NoInfer<GetUserMeData> | undefined, NoInfer<DeepReadonly<GetUserMeData>> | undefined>,
      options?: SetDataOptions
    ): GetUserMeData | undefined;
    /** @summary Retrieves the logged in user */
    getInfiniteQueryKey(parameters: DeepReadonly<GetUserMeParameters> | void): ServiceOperationInfiniteQueryKey<GetUserMeSchema, GetUserMeParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Retrieves the logged in user
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getUserMe.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<TPageParam extends GetUserMeParameters, TQueryFnData = GetUserMeData, TData = OperationInfiniteData<TQueryFnData, GetUserMeParameters>>(
      parameters: ServiceOperationInfiniteQueryKey<GetUserMeSchema, GetUserMeParameters> | (DeepReadonly<GetUserMeParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetUserMeError,
          TData,
          ServiceOperationInfiniteQueryKey<GetUserMeSchema, GetUserMeParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetUserMeError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Retrieves the logged in user
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getUserMe.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<TPageParam extends GetUserMeParameters, TQueryFnData = GetUserMeData, TData = OperationInfiniteData<TQueryFnData, GetUserMeParameters>>(
      parameters: ServiceOperationInfiniteQueryKey<GetUserMeSchema, GetUserMeParameters> | (DeepReadonly<GetUserMeParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetUserMeError,
          TData,
          ServiceOperationInfiniteQueryKey<GetUserMeSchema, GetUserMeParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetUserMeData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetUserMeError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Retrieves the logged in user
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getUserMeTotal = qraft.v1Service.getUserMe.useIsFetching()
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetUserMeSchema, GetUserMeData, TInfinite, GetUserMeParameters, GetUserMeError>
        | QueryFiltersByQueryKey<GetUserMeSchema, GetUserMeData, TInfinite, GetUserMeParameters, GetUserMeError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Retrieves the logged in user
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getUserMeResults = qraft.v1Service.getUserMe.useQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getUserMeResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getUserMeCombinedResults = qraft.v1Service.getUserMe.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getUserMeCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetUserMeSchema, GetUserMeParameters, GetUserMeData, GetUserMeError>>,
      TCombinedResult = Array<UseQueryResult<GetUserMeData, GetUserMeError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetUserMeData, GetUserMeError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Retrieves the logged in user */
    getQueryKey(parameters: DeepReadonly<GetUserMeParameters> | void): ServiceOperationQueryKey<GetUserMeSchema, GetUserMeParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Retrieves the logged in user
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getUserMe.useQuery()
     * ```
     */
    useQuery<TData = GetUserMeData>(
      parameters: ServiceOperationQueryKey<GetUserMeSchema, GetUserMeParameters> | (DeepReadonly<GetUserMeParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetUserMeData, GetUserMeError, TData, ServiceOperationQueryKey<GetUserMeSchema, GetUserMeParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetUserMeError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Retrieves the logged in user
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getUserMe.useQuery()
     * ```
     */
    useQuery<TData = GetUserMeData>(
      parameters: ServiceOperationQueryKey<GetUserMeSchema, GetUserMeParameters> | (DeepReadonly<GetUserMeParameters> | void),
      options: Omit<DefinedInitialDataOptions<GetUserMeData, GetUserMeError, TData, ServiceOperationQueryKey<GetUserMeSchema, GetUserMeParameters>>, "queryKey">
    ): DefinedUseQueryResult<TData, GetUserMeError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Retrieves the logged in user
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getUserMe.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetUserMeParameters, TData = GetUserMeData>(
      parameters: ServiceOperationInfiniteQueryKey<GetUserMeSchema, GetUserMeParameters> | (DeepReadonly<GetUserMeParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetUserMeData,
          GetUserMeError,
          OperationInfiniteData<TData, GetUserMeParameters>,
          GetUserMeData,
          ServiceOperationInfiniteQueryKey<GetUserMeSchema, GetUserMeParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetUserMeData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetUserMeParameters>, GetUserMeError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Retrieves the logged in user
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getUserMeData = qraft.v1Service.getUserMe.useSuspenseQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getUserMeResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getUserMeCombinedData = qraft.v1Service.getUserMe.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getUserMeCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetUserMeSchema, GetUserMeParameters, GetUserMeData, GetUserMeError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetUserMeData, GetUserMeError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetUserMeData, GetUserMeError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Retrieves the logged in user
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getUserMe.useSuspenseQuery()
     * ```
     */
    useSuspenseQuery<TData = GetUserMeData>(
      parameters: ServiceOperationQueryKey<GetUserMeSchema, GetUserMeParameters> | (DeepReadonly<GetUserMeParameters> | void),
      options?: Omit<UseSuspenseQueryOptions<GetUserMeData, GetUserMeError, TData, ServiceOperationQueryKey<GetUserMeSchema, GetUserMeParameters>>, "queryKey">
    ): UseSuspenseQueryResult<TData, GetUserMeError | Error>;
    schema: GetUserMeSchema;
    types: {
      parameters: GetUserMeParameters;
      data: GetUserMeData;
      error: GetUserMeError;
    };
  };
  /** @summary Resends a verification email */
  postSendVerificationEmail: {
    /** @summary Resends a verification email */
    getMutationKey(
      parameters: DeepReadonly<PostSendVerificationEmailParameters> | void
    ): ServiceOperationMutationKey<PostSendVerificationEmailSchema, PostSendVerificationEmailParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Resends a verification email
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postSendVerificationEmail.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postSendVerificationEmail.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends PostSendVerificationEmailBody, TContext = unknown>(
      parameters: DeepReadonly<PostSendVerificationEmailParameters>,
      options?: ServiceOperationUseMutationOptions<
        PostSendVerificationEmailSchema,
        PostSendVerificationEmailData,
        PostSendVerificationEmailParameters,
        TVariables,
        PostSendVerificationEmailError | Error,
        TContext
      >
    ): UseMutationResult<PostSendVerificationEmailData, PostSendVerificationEmailError | Error, TVariables, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Resends a verification email
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postSendVerificationEmail.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postSendVerificationEmail.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PostSendVerificationEmailBody, PostSendVerificationEmailParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PostSendVerificationEmailSchema,
        PostSendVerificationEmailData,
        PostSendVerificationEmailParameters,
        TVariables,
        PostSendVerificationEmailError | Error,
        TContext
      >
    ): UseMutationResult<PostSendVerificationEmailData, PostSendVerificationEmailError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Resends a verification email
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const postSendVerificationEmailTotal = qraft.v1Service.postSendVerificationEmail.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const postSendVerificationEmailTotal = qraft.v1Service.postSendVerificationEmail.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<
            PostSendVerificationEmailBody,
            PostSendVerificationEmailData,
            PostSendVerificationEmailParameters,
            PostSendVerificationEmailError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PostSendVerificationEmailSchema,
            PostSendVerificationEmailBody,
            PostSendVerificationEmailData,
            PostSendVerificationEmailParameters,
            PostSendVerificationEmailError | Error,
            TContext
          >
    ): number;
    /** @summary Resends a verification email */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<
            PostSendVerificationEmailBody,
            PostSendVerificationEmailData,
            PostSendVerificationEmailParameters,
            PostSendVerificationEmailError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PostSendVerificationEmailSchema,
            PostSendVerificationEmailBody,
            PostSendVerificationEmailData,
            PostSendVerificationEmailParameters,
            PostSendVerificationEmailError | Error,
            TContext
          >
    ): number;
    /** @summary Resends a verification email */
    (
      options: ServiceOperationMutationFnOptions<PostSendVerificationEmailBody, PostSendVerificationEmailParameters>,
      client?: (
        schema: PostSendVerificationEmailSchema,
        options: ServiceOperationMutationFnOptions<PostSendVerificationEmailBody, PostSendVerificationEmailParameters>
      ) => Promise<RequestFnResponse<PostSendVerificationEmailData, PostSendVerificationEmailError>>
    ): Promise<RequestFnResponse<PostSendVerificationEmailData, PostSendVerificationEmailError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Resends a verification email
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const postSendVerificationEmailPendingMutationVariables = qraft.v1Service.postSendVerificationEmail.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const postSendVerificationEmailMutationData = qraft.v1Service.postSendVerificationEmail.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        PostSendVerificationEmailData,
        PostSendVerificationEmailError | Error,
        MutationVariables<PostSendVerificationEmailBody, PostSendVerificationEmailParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<
            PostSendVerificationEmailBody,
            PostSendVerificationEmailData,
            PostSendVerificationEmailParameters,
            PostSendVerificationEmailError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PostSendVerificationEmailSchema,
            PostSendVerificationEmailBody,
            PostSendVerificationEmailData,
            PostSendVerificationEmailParameters,
            PostSendVerificationEmailError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          PostSendVerificationEmailData,
          PostSendVerificationEmailError | Error,
          MutationVariables<PostSendVerificationEmailBody, PostSendVerificationEmailParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: PostSendVerificationEmailSchema;
    types: {
      parameters: PostSendVerificationEmailParameters;
      data: PostSendVerificationEmailData;
      error: PostSendVerificationEmailError;
      body: PostSendVerificationEmailBody;
    };
  };
  /** @summary Checks if the email is verified */
  postVerifyEmail: {
    /** @summary Checks if the email is verified */
    getMutationKey(parameters: DeepReadonly<PostVerifyEmailParameters> | void): ServiceOperationMutationKey<PostVerifyEmailSchema, PostVerifyEmailParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Checks if the email is verified
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postVerifyEmail.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postVerifyEmail.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends PostVerifyEmailBody, TContext = unknown>(
      parameters: DeepReadonly<PostVerifyEmailParameters>,
      options?: ServiceOperationUseMutationOptions<
        PostVerifyEmailSchema,
        PostVerifyEmailData,
        PostVerifyEmailParameters,
        TVariables,
        PostVerifyEmailError | Error,
        TContext
      >
    ): UseMutationResult<PostVerifyEmailData, PostVerifyEmailError | Error, TVariables, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Checks if the email is verified
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postVerifyEmail.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postVerifyEmail.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PostVerifyEmailBody, PostVerifyEmailParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PostVerifyEmailSchema,
        PostVerifyEmailData,
        PostVerifyEmailParameters,
        TVariables,
        PostVerifyEmailError | Error,
        TContext
      >
    ): UseMutationResult<PostVerifyEmailData, PostVerifyEmailError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Checks if the email is verified
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const postVerifyEmailTotal = qraft.v1Service.postVerifyEmail.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const postVerifyEmailTotal = qraft.v1Service.postVerifyEmail.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<PostVerifyEmailBody, PostVerifyEmailData, PostVerifyEmailParameters, PostVerifyEmailError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostVerifyEmailSchema,
            PostVerifyEmailBody,
            PostVerifyEmailData,
            PostVerifyEmailParameters,
            PostVerifyEmailError | Error,
            TContext
          >
    ): number;
    /** @summary Checks if the email is verified */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<PostVerifyEmailBody, PostVerifyEmailData, PostVerifyEmailParameters, PostVerifyEmailError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostVerifyEmailSchema,
            PostVerifyEmailBody,
            PostVerifyEmailData,
            PostVerifyEmailParameters,
            PostVerifyEmailError | Error,
            TContext
          >
    ): number;
    /** @summary Checks if the email is verified */
    (
      options: ServiceOperationMutationFnOptions<PostVerifyEmailBody, PostVerifyEmailParameters>,
      client?: (
        schema: PostVerifyEmailSchema,
        options: ServiceOperationMutationFnOptions<PostVerifyEmailBody, PostVerifyEmailParameters>
      ) => Promise<RequestFnResponse<PostVerifyEmailData, PostVerifyEmailError>>
    ): Promise<RequestFnResponse<PostVerifyEmailData, PostVerifyEmailError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Checks if the email is verified
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const postVerifyEmailPendingMutationVariables = qraft.v1Service.postVerifyEmail.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const postVerifyEmailMutationData = qraft.v1Service.postVerifyEmail.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<PostVerifyEmailData, PostVerifyEmailError | Error, MutationVariables<PostVerifyEmailBody, PostVerifyEmailParameters>, TContext>
    >(options?: {
      filters?:
        | MutationFiltersByParameters<PostVerifyEmailBody, PostVerifyEmailData, PostVerifyEmailParameters, PostVerifyEmailError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostVerifyEmailSchema,
            PostVerifyEmailBody,
            PostVerifyEmailData,
            PostVerifyEmailParameters,
            PostVerifyEmailError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<PostVerifyEmailData, PostVerifyEmailError | Error, MutationVariables<PostVerifyEmailBody, PostVerifyEmailParameters>, TContext>
      ) => TResult;
    }): Array<TResult>;
    schema: PostVerifyEmailSchema;
    types: {
      parameters: PostVerifyEmailParameters;
      data: PostVerifyEmailData;
      error: PostVerifyEmailError;
      body: PostVerifyEmailBody;
    };
  };
  /** @summary Get deployment settings by user ID and dseq */
  getDeploymentSettingsUserIdDseq: {
    /** @summary Get deployment settings by user ID and dseq */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetDeploymentSettingsUserIdDseqSchema,
            GetDeploymentSettingsUserIdDseqData,
            TInfinite,
            GetDeploymentSettingsUserIdDseqParameters,
            GetDeploymentSettingsUserIdDseqError
          >
        | QueryFiltersByQueryKey<
            GetDeploymentSettingsUserIdDseqSchema,
            GetDeploymentSettingsUserIdDseqData,
            TInfinite,
            GetDeploymentSettingsUserIdDseqParameters,
            GetDeploymentSettingsUserIdDseqError
          >,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get deployment settings by user ID and dseq */
    getQueryKey(
      parameters: DeepReadonly<GetDeploymentSettingsUserIdDseqParameters>
    ): ServiceOperationQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get deployment settings by user ID and dseq
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeploymentSettingsUserIdDseq.useQuery({
     *     path: {
     *         userId: userId,
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useQuery<TData = GetDeploymentSettingsUserIdDseqData>(
      parameters:
        | ServiceOperationQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>
        | DeepReadonly<GetDeploymentSettingsUserIdDseqParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetDeploymentSettingsUserIdDseqData,
          GetDeploymentSettingsUserIdDseqError,
          TData,
          ServiceOperationQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetDeploymentSettingsUserIdDseqError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get deployment settings by user ID and dseq
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeploymentSettingsUserIdDseq.useQuery({
     *     path: {
     *         userId: userId,
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useQuery<TData = GetDeploymentSettingsUserIdDseqData>(
      parameters:
        | ServiceOperationQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>
        | DeepReadonly<GetDeploymentSettingsUserIdDseqParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetDeploymentSettingsUserIdDseqData,
          GetDeploymentSettingsUserIdDseqError,
          TData,
          ServiceOperationQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetDeploymentSettingsUserIdDseqError | Error>;
    /** @summary Get deployment settings by user ID and dseq */
    fetchInfiniteQuery<TPageParam extends GetDeploymentSettingsUserIdDseqParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetDeploymentSettingsUserIdDseqSchema,
        GetDeploymentSettingsUserIdDseqData,
        GetDeploymentSettingsUserIdDseqParameters,
        DeepReadonly<TPageParam>,
        GetDeploymentSettingsUserIdDseqError
      >
    ): Promise<OperationInfiniteData<GetDeploymentSettingsUserIdDseqData, GetDeploymentSettingsUserIdDseqParameters>>;
    /** @summary Get deployment settings by user ID and dseq */
    prefetchInfiniteQuery<TPageParam extends GetDeploymentSettingsUserIdDseqParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetDeploymentSettingsUserIdDseqSchema,
        GetDeploymentSettingsUserIdDseqData,
        GetDeploymentSettingsUserIdDseqParameters,
        DeepReadonly<TPageParam>,
        GetDeploymentSettingsUserIdDseqError
      >
    ): Promise<void>;
    /** @summary Get deployment settings by user ID and dseq */
    ensureInfiniteQueryData<TPageParam extends GetDeploymentSettingsUserIdDseqParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetDeploymentSettingsUserIdDseqSchema,
        GetDeploymentSettingsUserIdDseqData,
        GetDeploymentSettingsUserIdDseqParameters,
        DeepReadonly<TPageParam>,
        GetDeploymentSettingsUserIdDseqError
      >
    ): Promise<OperationInfiniteData<GetDeploymentSettingsUserIdDseqData, GetDeploymentSettingsUserIdDseqParameters>>;
    /** @summary Get deployment settings by user ID and dseq */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetDeploymentSettingsUserIdDseqSchema,
        GetDeploymentSettingsUserIdDseqData,
        GetDeploymentSettingsUserIdDseqParameters,
        GetDeploymentSettingsUserIdDseqError
      >
    ): Promise<GetDeploymentSettingsUserIdDseqData>;
    /** @summary Get deployment settings by user ID and dseq */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetDeploymentSettingsUserIdDseqSchema,
        GetDeploymentSettingsUserIdDseqData,
        GetDeploymentSettingsUserIdDseqParameters,
        GetDeploymentSettingsUserIdDseqError
      >
    ): Promise<void>;
    /** @summary Get deployment settings by user ID and dseq */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetDeploymentSettingsUserIdDseqSchema,
        GetDeploymentSettingsUserIdDseqData,
        GetDeploymentSettingsUserIdDseqParameters,
        GetDeploymentSettingsUserIdDseqError
      >
    ): Promise<GetDeploymentSettingsUserIdDseqData>;
    /** @summary Get deployment settings by user ID and dseq */
    getInfiniteQueryData(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>
        | DeepReadonly<GetDeploymentSettingsUserIdDseqParameters>
    ): OperationInfiniteData<GetDeploymentSettingsUserIdDseqData, GetDeploymentSettingsUserIdDseqParameters> | undefined;
    /** @summary Get deployment settings by user ID and dseq */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetDeploymentSettingsUserIdDseqSchema,
            GetDeploymentSettingsUserIdDseqData,
            TInfinite,
            GetDeploymentSettingsUserIdDseqParameters,
            GetDeploymentSettingsUserIdDseqError
          >
        | QueryFiltersByQueryKey<
            GetDeploymentSettingsUserIdDseqSchema,
            GetDeploymentSettingsUserIdDseqData,
            TInfinite,
            GetDeploymentSettingsUserIdDseqParameters,
            GetDeploymentSettingsUserIdDseqError
          >
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>,
            data: NoInfer<OperationInfiniteData<GetDeploymentSettingsUserIdDseqData, GetDeploymentSettingsUserIdDseqParameters>> | undefined
          ]
        >
      : Array<
          [
            queryKey: ServiceOperationQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>,
            data: GetDeploymentSettingsUserIdDseqData | undefined
          ]
        >;
    /** @summary Get deployment settings by user ID and dseq */
    getQueryData(
      parameters:
        | ServiceOperationQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>
        | DeepReadonly<GetDeploymentSettingsUserIdDseqParameters>
    ): GetDeploymentSettingsUserIdDseqData | undefined;
    /** @summary Get deployment settings by user ID and dseq */
    getQueryState(
      parameters:
        | ServiceOperationQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>
        | DeepReadonly<GetDeploymentSettingsUserIdDseqParameters>
    ): QueryState<GetDeploymentSettingsUserIdDseqData, GetDeploymentSettingsUserIdDseqError> | undefined;
    /** @summary Get deployment settings by user ID and dseq */
    getInfiniteQueryState(
      parameters:
        | DeepReadonly<GetDeploymentSettingsUserIdDseqParameters>
        | ServiceOperationInfiniteQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>
    ):
      | QueryState<OperationInfiniteData<GetDeploymentSettingsUserIdDseqData, GetDeploymentSettingsUserIdDseqParameters>, GetDeploymentSettingsUserIdDseqError>
      | undefined;
    /** @summary Get deployment settings by user ID and dseq */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<
        GetDeploymentSettingsUserIdDseqSchema,
        GetDeploymentSettingsUserIdDseqData,
        TInfinite,
        GetDeploymentSettingsUserIdDseqParameters,
        GetDeploymentSettingsUserIdDseqError
      >,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get deployment settings by user ID and dseq */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetDeploymentSettingsUserIdDseqSchema,
            GetDeploymentSettingsUserIdDseqData,
            TInfinite,
            GetDeploymentSettingsUserIdDseqParameters,
            GetDeploymentSettingsUserIdDseqError
          >
        | QueryFiltersByQueryKey<
            GetDeploymentSettingsUserIdDseqSchema,
            GetDeploymentSettingsUserIdDseqData,
            TInfinite,
            GetDeploymentSettingsUserIdDseqParameters,
            GetDeploymentSettingsUserIdDseqError
          >
    ): number;
    /** @summary Get deployment settings by user ID and dseq */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetDeploymentSettingsUserIdDseqParameters, TMeta, TSignal>,
      client?: (
        schema: GetDeploymentSettingsUserIdDseqSchema,
        options: {
          parameters: GetDeploymentSettingsUserIdDseqParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetDeploymentSettingsUserIdDseqData, GetDeploymentSettingsUserIdDseqError>>
    ): Promise<RequestFnResponse<GetDeploymentSettingsUserIdDseqData, GetDeploymentSettingsUserIdDseqError>>;
    /** @summary Get deployment settings by user ID and dseq */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetDeploymentSettingsUserIdDseqSchema,
            GetDeploymentSettingsUserIdDseqData,
            TInfinite,
            GetDeploymentSettingsUserIdDseqParameters,
            GetDeploymentSettingsUserIdDseqError
          >
        | QueryFiltersByQueryKey<
            GetDeploymentSettingsUserIdDseqSchema,
            GetDeploymentSettingsUserIdDseqData,
            TInfinite,
            GetDeploymentSettingsUserIdDseqParameters,
            GetDeploymentSettingsUserIdDseqError
          >,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get deployment settings by user ID and dseq */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetDeploymentSettingsUserIdDseqSchema,
            GetDeploymentSettingsUserIdDseqData,
            TInfinite,
            GetDeploymentSettingsUserIdDseqParameters,
            GetDeploymentSettingsUserIdDseqError
          >
        | QueryFiltersByQueryKey<
            GetDeploymentSettingsUserIdDseqSchema,
            GetDeploymentSettingsUserIdDseqData,
            TInfinite,
            GetDeploymentSettingsUserIdDseqParameters,
            GetDeploymentSettingsUserIdDseqError
          >
    ): void;
    /** @summary Get deployment settings by user ID and dseq */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetDeploymentSettingsUserIdDseqSchema,
            GetDeploymentSettingsUserIdDseqData,
            TInfinite,
            GetDeploymentSettingsUserIdDseqParameters,
            GetDeploymentSettingsUserIdDseqError
          >
        | QueryFiltersByQueryKey<
            GetDeploymentSettingsUserIdDseqSchema,
            GetDeploymentSettingsUserIdDseqData,
            TInfinite,
            GetDeploymentSettingsUserIdDseqParameters,
            GetDeploymentSettingsUserIdDseqError
          >,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get deployment settings by user ID and dseq */
    setInfiniteQueryData(
      parameters:
        | DeepReadonly<GetDeploymentSettingsUserIdDseqParameters>
        | ServiceOperationInfiniteQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetDeploymentSettingsUserIdDseqData, GetDeploymentSettingsUserIdDseqParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetDeploymentSettingsUserIdDseqData, GetDeploymentSettingsUserIdDseqParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetDeploymentSettingsUserIdDseqData, GetDeploymentSettingsUserIdDseqParameters> | undefined;
    /** @summary Get deployment settings by user ID and dseq */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<
            GetDeploymentSettingsUserIdDseqSchema,
            GetDeploymentSettingsUserIdDseqData,
            TInfinite,
            GetDeploymentSettingsUserIdDseqParameters,
            GetDeploymentSettingsUserIdDseqError
          >
        | QueryFiltersByQueryKey<
            GetDeploymentSettingsUserIdDseqSchema,
            GetDeploymentSettingsUserIdDseqData,
            TInfinite,
            GetDeploymentSettingsUserIdDseqParameters,
            GetDeploymentSettingsUserIdDseqError
          >,
      updater: Updater<NoInfer<GetDeploymentSettingsUserIdDseqData> | undefined, NoInfer<GetDeploymentSettingsUserIdDseqData> | undefined>,
      options?: SetDataOptions
    ): Array<GetDeploymentSettingsUserIdDseqData | undefined>;
    /** @summary Get deployment settings by user ID and dseq */
    setQueryData(
      parameters:
        | DeepReadonly<GetDeploymentSettingsUserIdDseqParameters>
        | ServiceOperationQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>,
      updater: Updater<NoInfer<GetDeploymentSettingsUserIdDseqData> | undefined, NoInfer<DeepReadonly<GetDeploymentSettingsUserIdDseqData>> | undefined>,
      options?: SetDataOptions
    ): GetDeploymentSettingsUserIdDseqData | undefined;
    /** @summary Get deployment settings by user ID and dseq */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetDeploymentSettingsUserIdDseqParameters>
    ): ServiceOperationInfiniteQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get deployment settings by user ID and dseq
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getDeploymentSettingsUserIdDseq.useInfiniteQuery({
     *     path: {
     *         userId: userId,
     *         dseq: dseq
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetDeploymentSettingsUserIdDseqParameters,
      TQueryFnData = GetDeploymentSettingsUserIdDseqData,
      TData = OperationInfiniteData<TQueryFnData, GetDeploymentSettingsUserIdDseqParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>
        | DeepReadonly<GetDeploymentSettingsUserIdDseqParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetDeploymentSettingsUserIdDseqError,
          TData,
          ServiceOperationInfiniteQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetDeploymentSettingsUserIdDseqError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get deployment settings by user ID and dseq
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getDeploymentSettingsUserIdDseq.useInfiniteQuery({
     *     path: {
     *         userId: userId,
     *         dseq: dseq
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetDeploymentSettingsUserIdDseqParameters,
      TQueryFnData = GetDeploymentSettingsUserIdDseqData,
      TData = OperationInfiniteData<TQueryFnData, GetDeploymentSettingsUserIdDseqParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>
        | DeepReadonly<GetDeploymentSettingsUserIdDseqParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetDeploymentSettingsUserIdDseqError,
          TData,
          ServiceOperationInfiniteQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetDeploymentSettingsUserIdDseqData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetDeploymentSettingsUserIdDseqError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get deployment settings by user ID and dseq
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getDeploymentSettingsUserIdDseqTotal = qraft.v1Service.getDeploymentSettingsUserIdDseq.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getDeploymentSettingsUserIdDseqByParametersTotal = qraft.v1Service.getDeploymentSettingsUserIdDseq.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             userId: userId,
     *             dseq: dseq
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetDeploymentSettingsUserIdDseqSchema,
            GetDeploymentSettingsUserIdDseqData,
            TInfinite,
            GetDeploymentSettingsUserIdDseqParameters,
            GetDeploymentSettingsUserIdDseqError
          >
        | QueryFiltersByQueryKey<
            GetDeploymentSettingsUserIdDseqSchema,
            GetDeploymentSettingsUserIdDseqData,
            TInfinite,
            GetDeploymentSettingsUserIdDseqParameters,
            GetDeploymentSettingsUserIdDseqError
          >
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get deployment settings by user ID and dseq
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getDeploymentSettingsUserIdDseqResults = qraft.v1Service.getDeploymentSettingsUserIdDseq.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 userId: userId1,
     *                 dseq: dseq1
     *             }
     *         },
     *         {
     *             path: {
     *                 userId: userId2,
     *                 dseq: dseq2
     *             }
     *         }
     *     ]
     * });
     * getDeploymentSettingsUserIdDseqResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getDeploymentSettingsUserIdDseqCombinedResults = qraft.v1Service.getDeploymentSettingsUserIdDseq.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 userId: userId1,
     *                 dseq: dseq1
     *             }
     *         },
     *         {
     *             path: {
     *                 userId: userId2,
     *                 dseq: dseq2
     *             }
     *         }
     *     ]
     * });
     * getDeploymentSettingsUserIdDseqCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<
          GetDeploymentSettingsUserIdDseqSchema,
          GetDeploymentSettingsUserIdDseqParameters,
          GetDeploymentSettingsUserIdDseqData,
          GetDeploymentSettingsUserIdDseqError
        >
      >,
      TCombinedResult = Array<UseQueryResult<GetDeploymentSettingsUserIdDseqData, GetDeploymentSettingsUserIdDseqError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetDeploymentSettingsUserIdDseqData, GetDeploymentSettingsUserIdDseqError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get deployment settings by user ID and dseq */
    getQueryKey(
      parameters: DeepReadonly<GetDeploymentSettingsUserIdDseqParameters>
    ): ServiceOperationQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get deployment settings by user ID and dseq
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeploymentSettingsUserIdDseq.useQuery({
     *     path: {
     *         userId: userId,
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useQuery<TData = GetDeploymentSettingsUserIdDseqData>(
      parameters:
        | ServiceOperationQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>
        | DeepReadonly<GetDeploymentSettingsUserIdDseqParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetDeploymentSettingsUserIdDseqData,
          GetDeploymentSettingsUserIdDseqError,
          TData,
          ServiceOperationQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetDeploymentSettingsUserIdDseqError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get deployment settings by user ID and dseq
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeploymentSettingsUserIdDseq.useQuery({
     *     path: {
     *         userId: userId,
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useQuery<TData = GetDeploymentSettingsUserIdDseqData>(
      parameters:
        | ServiceOperationQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>
        | DeepReadonly<GetDeploymentSettingsUserIdDseqParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetDeploymentSettingsUserIdDseqData,
          GetDeploymentSettingsUserIdDseqError,
          TData,
          ServiceOperationQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetDeploymentSettingsUserIdDseqError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get deployment settings by user ID and dseq
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getDeploymentSettingsUserIdDseq.useSuspenseInfiniteQuery({
     *     path: {
     *         userId: userId,
     *         dseq: dseq
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetDeploymentSettingsUserIdDseqParameters, TData = GetDeploymentSettingsUserIdDseqData>(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>
        | DeepReadonly<GetDeploymentSettingsUserIdDseqParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetDeploymentSettingsUserIdDseqData,
          GetDeploymentSettingsUserIdDseqError,
          OperationInfiniteData<TData, GetDeploymentSettingsUserIdDseqParameters>,
          GetDeploymentSettingsUserIdDseqData,
          ServiceOperationInfiniteQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetDeploymentSettingsUserIdDseqData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetDeploymentSettingsUserIdDseqParameters>, GetDeploymentSettingsUserIdDseqError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get deployment settings by user ID and dseq
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getDeploymentSettingsUserIdDseqData = qraft.v1Service.getDeploymentSettingsUserIdDseq.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 userId: userId1,
     *                 dseq: dseq1
     *             }
     *         },
     *         {
     *             path: {
     *                 userId: userId2,
     *                 dseq: dseq2
     *             }
     *         }
     *     ]
     * });
     * getDeploymentSettingsUserIdDseqResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getDeploymentSettingsUserIdDseqCombinedData = qraft.v1Service.getDeploymentSettingsUserIdDseq.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 userId: userId1,
     *                 dseq: dseq1
     *             }
     *         },
     *         {
     *             path: {
     *                 userId: userId2,
     *                 dseq: dseq2
     *             }
     *         }
     *     ]
     * });
     * getDeploymentSettingsUserIdDseqCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<
          GetDeploymentSettingsUserIdDseqSchema,
          GetDeploymentSettingsUserIdDseqParameters,
          GetDeploymentSettingsUserIdDseqData,
          GetDeploymentSettingsUserIdDseqError
        >
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetDeploymentSettingsUserIdDseqData, GetDeploymentSettingsUserIdDseqError>>
    >(options: {
      queries: T;
      combine?: (
        results: Array<WithOptional<UseSuspenseQueryResult<GetDeploymentSettingsUserIdDseqData, GetDeploymentSettingsUserIdDseqError>, "data">>
      ) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get deployment settings by user ID and dseq
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getDeploymentSettingsUserIdDseq.useSuspenseQuery({
     *     path: {
     *         userId: userId,
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetDeploymentSettingsUserIdDseqData>(
      parameters:
        | ServiceOperationQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>
        | DeepReadonly<GetDeploymentSettingsUserIdDseqParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<
          GetDeploymentSettingsUserIdDseqData,
          GetDeploymentSettingsUserIdDseqError,
          TData,
          ServiceOperationQueryKey<GetDeploymentSettingsUserIdDseqSchema, GetDeploymentSettingsUserIdDseqParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetDeploymentSettingsUserIdDseqError | Error>;
    schema: GetDeploymentSettingsUserIdDseqSchema;
    types: {
      parameters: GetDeploymentSettingsUserIdDseqParameters;
      data: GetDeploymentSettingsUserIdDseqData;
      error: GetDeploymentSettingsUserIdDseqError;
    };
  };
  /** @summary Update deployment settings */
  patchDeploymentSettingsUserIdDseq: {
    /** @summary Update deployment settings */
    getMutationKey(
      parameters: DeepReadonly<PatchDeploymentSettingsUserIdDseqParameters> | void
    ): ServiceOperationMutationKey<PatchDeploymentSettingsUserIdDseqSchema, PatchDeploymentSettingsUserIdDseqParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Update deployment settings
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchDeploymentSettingsUserIdDseq.useMutation({
     *     path: {
     *         userId: userId,
     *         dseq: dseq
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchDeploymentSettingsUserIdDseq.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         userId: userId,
     *         dseq: dseq
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends PatchDeploymentSettingsUserIdDseqBody, TContext = unknown>(
      parameters: DeepReadonly<PatchDeploymentSettingsUserIdDseqParameters>,
      options?: ServiceOperationUseMutationOptions<
        PatchDeploymentSettingsUserIdDseqSchema,
        PatchDeploymentSettingsUserIdDseqData,
        PatchDeploymentSettingsUserIdDseqParameters,
        TVariables,
        PatchDeploymentSettingsUserIdDseqError | Error,
        TContext
      >
    ): UseMutationResult<PatchDeploymentSettingsUserIdDseqData, PatchDeploymentSettingsUserIdDseqError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Update deployment settings
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchDeploymentSettingsUserIdDseq.useMutation({
     *     path: {
     *         userId: userId,
     *         dseq: dseq
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchDeploymentSettingsUserIdDseq.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         userId: userId,
     *         dseq: dseq
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PatchDeploymentSettingsUserIdDseqBody, PatchDeploymentSettingsUserIdDseqParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PatchDeploymentSettingsUserIdDseqSchema,
        PatchDeploymentSettingsUserIdDseqData,
        PatchDeploymentSettingsUserIdDseqParameters,
        TVariables,
        PatchDeploymentSettingsUserIdDseqError | Error,
        TContext
      >
    ): UseMutationResult<PatchDeploymentSettingsUserIdDseqData, PatchDeploymentSettingsUserIdDseqError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Update deployment settings
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const patchDeploymentSettingsUserIdDseqTotal = qraft.v1Service.patchDeploymentSettingsUserIdDseq.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const patchDeploymentSettingsUserIdDseqTotal = qraft.v1Service.patchDeploymentSettingsUserIdDseq.useIsMutating({
     *     parameters: {
     *         path: {
     *             userId: userId,
     *             dseq: dseq
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<
            PatchDeploymentSettingsUserIdDseqBody,
            PatchDeploymentSettingsUserIdDseqData,
            PatchDeploymentSettingsUserIdDseqParameters,
            PatchDeploymentSettingsUserIdDseqError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PatchDeploymentSettingsUserIdDseqSchema,
            PatchDeploymentSettingsUserIdDseqBody,
            PatchDeploymentSettingsUserIdDseqData,
            PatchDeploymentSettingsUserIdDseqParameters,
            PatchDeploymentSettingsUserIdDseqError | Error,
            TContext
          >
    ): number;
    /** @summary Update deployment settings */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<
            PatchDeploymentSettingsUserIdDseqBody,
            PatchDeploymentSettingsUserIdDseqData,
            PatchDeploymentSettingsUserIdDseqParameters,
            PatchDeploymentSettingsUserIdDseqError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PatchDeploymentSettingsUserIdDseqSchema,
            PatchDeploymentSettingsUserIdDseqBody,
            PatchDeploymentSettingsUserIdDseqData,
            PatchDeploymentSettingsUserIdDseqParameters,
            PatchDeploymentSettingsUserIdDseqError | Error,
            TContext
          >
    ): number;
    /** @summary Update deployment settings */
    (
      options: ServiceOperationMutationFnOptions<PatchDeploymentSettingsUserIdDseqBody, PatchDeploymentSettingsUserIdDseqParameters>,
      client?: (
        schema: PatchDeploymentSettingsUserIdDseqSchema,
        options: ServiceOperationMutationFnOptions<PatchDeploymentSettingsUserIdDseqBody, PatchDeploymentSettingsUserIdDseqParameters>
      ) => Promise<RequestFnResponse<PatchDeploymentSettingsUserIdDseqData, PatchDeploymentSettingsUserIdDseqError>>
    ): Promise<RequestFnResponse<PatchDeploymentSettingsUserIdDseqData, PatchDeploymentSettingsUserIdDseqError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Update deployment settings
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const patchDeploymentSettingsUserIdDseqPendingMutationVariables = qraft.v1Service.patchDeploymentSettingsUserIdDseq.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const patchDeploymentSettingsUserIdDseqMutationData = qraft.v1Service.patchDeploymentSettingsUserIdDseq.useMutationState({
     *     filters: {
     *         parameters: {
     *             path: {
     *                 userId: userId,
     *                 dseq: dseq
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        PatchDeploymentSettingsUserIdDseqData,
        PatchDeploymentSettingsUserIdDseqError | Error,
        MutationVariables<PatchDeploymentSettingsUserIdDseqBody, PatchDeploymentSettingsUserIdDseqParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<
            PatchDeploymentSettingsUserIdDseqBody,
            PatchDeploymentSettingsUserIdDseqData,
            PatchDeploymentSettingsUserIdDseqParameters,
            PatchDeploymentSettingsUserIdDseqError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PatchDeploymentSettingsUserIdDseqSchema,
            PatchDeploymentSettingsUserIdDseqBody,
            PatchDeploymentSettingsUserIdDseqData,
            PatchDeploymentSettingsUserIdDseqParameters,
            PatchDeploymentSettingsUserIdDseqError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          PatchDeploymentSettingsUserIdDseqData,
          PatchDeploymentSettingsUserIdDseqError | Error,
          MutationVariables<PatchDeploymentSettingsUserIdDseqBody, PatchDeploymentSettingsUserIdDseqParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: PatchDeploymentSettingsUserIdDseqSchema;
    types: {
      parameters: PatchDeploymentSettingsUserIdDseqParameters;
      data: PatchDeploymentSettingsUserIdDseqData;
      error: PatchDeploymentSettingsUserIdDseqError;
      body: PatchDeploymentSettingsUserIdDseqBody;
    };
  };
  /** @summary Create deployment settings */
  postDeploymentSettings: {
    /** @summary Create deployment settings */
    getMutationKey(
      parameters: DeepReadonly<PostDeploymentSettingsParameters> | void
    ): ServiceOperationMutationKey<PostDeploymentSettingsSchema, PostDeploymentSettingsParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Create deployment settings
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postDeploymentSettings.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postDeploymentSettings.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends PostDeploymentSettingsBody, TContext = unknown>(
      parameters: DeepReadonly<PostDeploymentSettingsParameters>,
      options?: ServiceOperationUseMutationOptions<
        PostDeploymentSettingsSchema,
        PostDeploymentSettingsData,
        PostDeploymentSettingsParameters,
        TVariables,
        PostDeploymentSettingsError | Error,
        TContext
      >
    ): UseMutationResult<PostDeploymentSettingsData, PostDeploymentSettingsError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Create deployment settings
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postDeploymentSettings.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postDeploymentSettings.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PostDeploymentSettingsBody, PostDeploymentSettingsParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PostDeploymentSettingsSchema,
        PostDeploymentSettingsData,
        PostDeploymentSettingsParameters,
        TVariables,
        PostDeploymentSettingsError | Error,
        TContext
      >
    ): UseMutationResult<PostDeploymentSettingsData, PostDeploymentSettingsError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Create deployment settings
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const postDeploymentSettingsTotal = qraft.v1Service.postDeploymentSettings.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const postDeploymentSettingsTotal = qraft.v1Service.postDeploymentSettings.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<
            PostDeploymentSettingsBody,
            PostDeploymentSettingsData,
            PostDeploymentSettingsParameters,
            PostDeploymentSettingsError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PostDeploymentSettingsSchema,
            PostDeploymentSettingsBody,
            PostDeploymentSettingsData,
            PostDeploymentSettingsParameters,
            PostDeploymentSettingsError | Error,
            TContext
          >
    ): number;
    /** @summary Create deployment settings */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<
            PostDeploymentSettingsBody,
            PostDeploymentSettingsData,
            PostDeploymentSettingsParameters,
            PostDeploymentSettingsError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PostDeploymentSettingsSchema,
            PostDeploymentSettingsBody,
            PostDeploymentSettingsData,
            PostDeploymentSettingsParameters,
            PostDeploymentSettingsError | Error,
            TContext
          >
    ): number;
    /** @summary Create deployment settings */
    (
      options: ServiceOperationMutationFnOptions<PostDeploymentSettingsBody, PostDeploymentSettingsParameters>,
      client?: (
        schema: PostDeploymentSettingsSchema,
        options: ServiceOperationMutationFnOptions<PostDeploymentSettingsBody, PostDeploymentSettingsParameters>
      ) => Promise<RequestFnResponse<PostDeploymentSettingsData, PostDeploymentSettingsError>>
    ): Promise<RequestFnResponse<PostDeploymentSettingsData, PostDeploymentSettingsError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Create deployment settings
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const postDeploymentSettingsPendingMutationVariables = qraft.v1Service.postDeploymentSettings.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const postDeploymentSettingsMutationData = qraft.v1Service.postDeploymentSettings.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        PostDeploymentSettingsData,
        PostDeploymentSettingsError | Error,
        MutationVariables<PostDeploymentSettingsBody, PostDeploymentSettingsParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<
            PostDeploymentSettingsBody,
            PostDeploymentSettingsData,
            PostDeploymentSettingsParameters,
            PostDeploymentSettingsError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PostDeploymentSettingsSchema,
            PostDeploymentSettingsBody,
            PostDeploymentSettingsData,
            PostDeploymentSettingsParameters,
            PostDeploymentSettingsError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          PostDeploymentSettingsData,
          PostDeploymentSettingsError | Error,
          MutationVariables<PostDeploymentSettingsBody, PostDeploymentSettingsParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: PostDeploymentSettingsSchema;
    types: {
      parameters: PostDeploymentSettingsParameters;
      data: PostDeploymentSettingsData;
      error: PostDeploymentSettingsError;
      body: PostDeploymentSettingsBody;
    };
  };
  /** @summary Get a deployment */
  getDeploymentsDseq: {
    /** @summary Get a deployment */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentsDseqSchema, GetDeploymentsDseqData, TInfinite, GetDeploymentsDseqParameters, GetDeploymentsDseqError>
        | QueryFiltersByQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqData, TInfinite, GetDeploymentsDseqParameters, GetDeploymentsDseqError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get a deployment */
    getQueryKey(parameters: DeepReadonly<GetDeploymentsDseqParameters>): ServiceOperationQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeploymentsDseq.useQuery({
     *     path: {
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useQuery<TData = GetDeploymentsDseqData>(
      parameters: ServiceOperationQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters> | DeepReadonly<GetDeploymentsDseqParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetDeploymentsDseqData,
          GetDeploymentsDseqError,
          TData,
          ServiceOperationQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetDeploymentsDseqError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeploymentsDseq.useQuery({
     *     path: {
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useQuery<TData = GetDeploymentsDseqData>(
      parameters: ServiceOperationQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters> | DeepReadonly<GetDeploymentsDseqParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetDeploymentsDseqData,
          GetDeploymentsDseqError,
          TData,
          ServiceOperationQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetDeploymentsDseqError | Error>;
    /** @summary Get a deployment */
    fetchInfiniteQuery<TPageParam extends GetDeploymentsDseqParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetDeploymentsDseqSchema,
        GetDeploymentsDseqData,
        GetDeploymentsDseqParameters,
        DeepReadonly<TPageParam>,
        GetDeploymentsDseqError
      >
    ): Promise<OperationInfiniteData<GetDeploymentsDseqData, GetDeploymentsDseqParameters>>;
    /** @summary Get a deployment */
    prefetchInfiniteQuery<TPageParam extends GetDeploymentsDseqParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetDeploymentsDseqSchema,
        GetDeploymentsDseqData,
        GetDeploymentsDseqParameters,
        DeepReadonly<TPageParam>,
        GetDeploymentsDseqError
      >
    ): Promise<void>;
    /** @summary Get a deployment */
    ensureInfiniteQueryData<TPageParam extends GetDeploymentsDseqParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetDeploymentsDseqSchema,
        GetDeploymentsDseqData,
        GetDeploymentsDseqParameters,
        DeepReadonly<TPageParam>,
        GetDeploymentsDseqError
      >
    ): Promise<OperationInfiniteData<GetDeploymentsDseqData, GetDeploymentsDseqParameters>>;
    /** @summary Get a deployment */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetDeploymentsDseqSchema, GetDeploymentsDseqData, GetDeploymentsDseqParameters, GetDeploymentsDseqError>
    ): Promise<GetDeploymentsDseqData>;
    /** @summary Get a deployment */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetDeploymentsDseqSchema, GetDeploymentsDseqData, GetDeploymentsDseqParameters, GetDeploymentsDseqError>
    ): Promise<void>;
    /** @summary Get a deployment */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetDeploymentsDseqSchema, GetDeploymentsDseqData, GetDeploymentsDseqParameters, GetDeploymentsDseqError>
    ): Promise<GetDeploymentsDseqData>;
    /** @summary Get a deployment */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters> | DeepReadonly<GetDeploymentsDseqParameters>
    ): OperationInfiniteData<GetDeploymentsDseqData, GetDeploymentsDseqParameters> | undefined;
    /** @summary Get a deployment */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentsDseqSchema, GetDeploymentsDseqData, TInfinite, GetDeploymentsDseqParameters, GetDeploymentsDseqError>
        | QueryFiltersByQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqData, TInfinite, GetDeploymentsDseqParameters, GetDeploymentsDseqError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters>,
            data: NoInfer<OperationInfiniteData<GetDeploymentsDseqData, GetDeploymentsDseqParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters>, data: GetDeploymentsDseqData | undefined]>;
    /** @summary Get a deployment */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters> | DeepReadonly<GetDeploymentsDseqParameters>
    ): GetDeploymentsDseqData | undefined;
    /** @summary Get a deployment */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters> | DeepReadonly<GetDeploymentsDseqParameters>
    ): QueryState<GetDeploymentsDseqData, GetDeploymentsDseqError> | undefined;
    /** @summary Get a deployment */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetDeploymentsDseqParameters> | ServiceOperationInfiniteQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters>
    ): QueryState<OperationInfiniteData<GetDeploymentsDseqData, GetDeploymentsDseqParameters>, GetDeploymentsDseqError> | undefined;
    /** @summary Get a deployment */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetDeploymentsDseqSchema, GetDeploymentsDseqData, TInfinite, GetDeploymentsDseqParameters, GetDeploymentsDseqError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get a deployment */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentsDseqSchema, GetDeploymentsDseqData, TInfinite, GetDeploymentsDseqParameters, GetDeploymentsDseqError>
        | QueryFiltersByQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqData, TInfinite, GetDeploymentsDseqParameters, GetDeploymentsDseqError>
    ): number;
    /** @summary Get a deployment */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetDeploymentsDseqParameters, TMeta, TSignal>,
      client?: (
        schema: GetDeploymentsDseqSchema,
        options: {
          parameters: GetDeploymentsDseqParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetDeploymentsDseqData, GetDeploymentsDseqError>>
    ): Promise<RequestFnResponse<GetDeploymentsDseqData, GetDeploymentsDseqError>>;
    /** @summary Get a deployment */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentsDseqSchema, GetDeploymentsDseqData, TInfinite, GetDeploymentsDseqParameters, GetDeploymentsDseqError>
        | QueryFiltersByQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqData, TInfinite, GetDeploymentsDseqParameters, GetDeploymentsDseqError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get a deployment */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentsDseqSchema, GetDeploymentsDseqData, TInfinite, GetDeploymentsDseqParameters, GetDeploymentsDseqError>
        | QueryFiltersByQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqData, TInfinite, GetDeploymentsDseqParameters, GetDeploymentsDseqError>
    ): void;
    /** @summary Get a deployment */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentsDseqSchema, GetDeploymentsDseqData, TInfinite, GetDeploymentsDseqParameters, GetDeploymentsDseqError>
        | QueryFiltersByQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqData, TInfinite, GetDeploymentsDseqParameters, GetDeploymentsDseqError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get a deployment */
    setInfiniteQueryData(
      parameters: DeepReadonly<GetDeploymentsDseqParameters> | ServiceOperationInfiniteQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetDeploymentsDseqData, GetDeploymentsDseqParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetDeploymentsDseqData, GetDeploymentsDseqParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetDeploymentsDseqData, GetDeploymentsDseqParameters> | undefined;
    /** @summary Get a deployment */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetDeploymentsDseqSchema, GetDeploymentsDseqData, TInfinite, GetDeploymentsDseqParameters, GetDeploymentsDseqError>
        | QueryFiltersByQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqData, TInfinite, GetDeploymentsDseqParameters, GetDeploymentsDseqError>,
      updater: Updater<NoInfer<GetDeploymentsDseqData> | undefined, NoInfer<GetDeploymentsDseqData> | undefined>,
      options?: SetDataOptions
    ): Array<GetDeploymentsDseqData | undefined>;
    /** @summary Get a deployment */
    setQueryData(
      parameters: DeepReadonly<GetDeploymentsDseqParameters> | ServiceOperationQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters>,
      updater: Updater<NoInfer<GetDeploymentsDseqData> | undefined, NoInfer<DeepReadonly<GetDeploymentsDseqData>> | undefined>,
      options?: SetDataOptions
    ): GetDeploymentsDseqData | undefined;
    /** @summary Get a deployment */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetDeploymentsDseqParameters>
    ): ServiceOperationInfiniteQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getDeploymentsDseq.useInfiniteQuery({
     *     path: {
     *         dseq: dseq
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetDeploymentsDseqParameters,
      TQueryFnData = GetDeploymentsDseqData,
      TData = OperationInfiniteData<TQueryFnData, GetDeploymentsDseqParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters> | DeepReadonly<GetDeploymentsDseqParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetDeploymentsDseqError,
          TData,
          ServiceOperationInfiniteQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetDeploymentsDseqError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getDeploymentsDseq.useInfiniteQuery({
     *     path: {
     *         dseq: dseq
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetDeploymentsDseqParameters,
      TQueryFnData = GetDeploymentsDseqData,
      TData = OperationInfiniteData<TQueryFnData, GetDeploymentsDseqParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters> | DeepReadonly<GetDeploymentsDseqParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetDeploymentsDseqError,
          TData,
          ServiceOperationInfiniteQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetDeploymentsDseqData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetDeploymentsDseqError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get a deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getDeploymentsDseqTotal = qraft.v1Service.getDeploymentsDseq.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getDeploymentsDseqByParametersTotal = qraft.v1Service.getDeploymentsDseq.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             dseq: dseq
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentsDseqSchema, GetDeploymentsDseqData, TInfinite, GetDeploymentsDseqParameters, GetDeploymentsDseqError>
        | QueryFiltersByQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqData, TInfinite, GetDeploymentsDseqParameters, GetDeploymentsDseqError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get a deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getDeploymentsDseqResults = qraft.v1Service.getDeploymentsDseq.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 dseq: dseq1
     *             }
     *         },
     *         {
     *             path: {
     *                 dseq: dseq2
     *             }
     *         }
     *     ]
     * });
     * getDeploymentsDseqResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getDeploymentsDseqCombinedResults = qraft.v1Service.getDeploymentsDseq.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 dseq: dseq1
     *             }
     *         },
     *         {
     *             path: {
     *                 dseq: dseq2
     *             }
     *         }
     *     ]
     * });
     * getDeploymentsDseqCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters, GetDeploymentsDseqData, GetDeploymentsDseqError>>,
      TCombinedResult = Array<UseQueryResult<GetDeploymentsDseqData, GetDeploymentsDseqError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetDeploymentsDseqData, GetDeploymentsDseqError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get a deployment */
    getQueryKey(parameters: DeepReadonly<GetDeploymentsDseqParameters>): ServiceOperationQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeploymentsDseq.useQuery({
     *     path: {
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useQuery<TData = GetDeploymentsDseqData>(
      parameters: ServiceOperationQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters> | DeepReadonly<GetDeploymentsDseqParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetDeploymentsDseqData,
          GetDeploymentsDseqError,
          TData,
          ServiceOperationQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetDeploymentsDseqError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeploymentsDseq.useQuery({
     *     path: {
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useQuery<TData = GetDeploymentsDseqData>(
      parameters: ServiceOperationQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters> | DeepReadonly<GetDeploymentsDseqParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetDeploymentsDseqData,
          GetDeploymentsDseqError,
          TData,
          ServiceOperationQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetDeploymentsDseqError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get a deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getDeploymentsDseq.useSuspenseInfiniteQuery({
     *     path: {
     *         dseq: dseq
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetDeploymentsDseqParameters, TData = GetDeploymentsDseqData>(
      parameters: ServiceOperationInfiniteQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters> | DeepReadonly<GetDeploymentsDseqParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetDeploymentsDseqData,
          GetDeploymentsDseqError,
          OperationInfiniteData<TData, GetDeploymentsDseqParameters>,
          GetDeploymentsDseqData,
          ServiceOperationInfiniteQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetDeploymentsDseqData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetDeploymentsDseqParameters>, GetDeploymentsDseqError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get a deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getDeploymentsDseqData = qraft.v1Service.getDeploymentsDseq.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 dseq: dseq1
     *             }
     *         },
     *         {
     *             path: {
     *                 dseq: dseq2
     *             }
     *         }
     *     ]
     * });
     * getDeploymentsDseqResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getDeploymentsDseqCombinedData = qraft.v1Service.getDeploymentsDseq.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 dseq: dseq1
     *             }
     *         },
     *         {
     *             path: {
     *                 dseq: dseq2
     *             }
     *         }
     *     ]
     * });
     * getDeploymentsDseqCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters, GetDeploymentsDseqData, GetDeploymentsDseqError>
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetDeploymentsDseqData, GetDeploymentsDseqError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetDeploymentsDseqData, GetDeploymentsDseqError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get a deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getDeploymentsDseq.useSuspenseQuery({
     *     path: {
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetDeploymentsDseqData>(
      parameters: ServiceOperationQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters> | DeepReadonly<GetDeploymentsDseqParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<
          GetDeploymentsDseqData,
          GetDeploymentsDseqError,
          TData,
          ServiceOperationQueryKey<GetDeploymentsDseqSchema, GetDeploymentsDseqParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetDeploymentsDseqError | Error>;
    schema: GetDeploymentsDseqSchema;
    types: {
      parameters: GetDeploymentsDseqParameters;
      data: GetDeploymentsDseqData;
      error: GetDeploymentsDseqError;
    };
  };
  /** @summary Close a deployment */
  deleteDeploymentsDseq: {
    /** @summary Close a deployment */
    getMutationKey(
      parameters: DeepReadonly<DeleteDeploymentsDseqParameters> | void
    ): ServiceOperationMutationKey<DeleteDeploymentsDseqSchema, DeleteDeploymentsDseqParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Close a deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteDeploymentsDseq.useMutation({
     *     path: {
     *         dseq: dseq
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteDeploymentsDseq.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         dseq: dseq
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends DeleteDeploymentsDseqBody, TContext = unknown>(
      parameters: DeepReadonly<DeleteDeploymentsDseqParameters>,
      options?: ServiceOperationUseMutationOptions<
        DeleteDeploymentsDseqSchema,
        DeleteDeploymentsDseqData,
        DeleteDeploymentsDseqParameters,
        TVariables,
        DeleteDeploymentsDseqError | Error,
        TContext
      >
    ): UseMutationResult<DeleteDeploymentsDseqData, DeleteDeploymentsDseqError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Close a deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteDeploymentsDseq.useMutation({
     *     path: {
     *         dseq: dseq
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteDeploymentsDseq.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         dseq: dseq
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<DeleteDeploymentsDseqBody, DeleteDeploymentsDseqParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        DeleteDeploymentsDseqSchema,
        DeleteDeploymentsDseqData,
        DeleteDeploymentsDseqParameters,
        TVariables,
        DeleteDeploymentsDseqError | Error,
        TContext
      >
    ): UseMutationResult<DeleteDeploymentsDseqData, DeleteDeploymentsDseqError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Close a deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const deleteDeploymentsDseqTotal = qraft.v1Service.deleteDeploymentsDseq.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const deleteDeploymentsDseqTotal = qraft.v1Service.deleteDeploymentsDseq.useIsMutating({
     *     parameters: {
     *         path: {
     *             dseq: dseq
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<
            DeleteDeploymentsDseqBody,
            DeleteDeploymentsDseqData,
            DeleteDeploymentsDseqParameters,
            DeleteDeploymentsDseqError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            DeleteDeploymentsDseqSchema,
            DeleteDeploymentsDseqBody,
            DeleteDeploymentsDseqData,
            DeleteDeploymentsDseqParameters,
            DeleteDeploymentsDseqError | Error,
            TContext
          >
    ): number;
    /** @summary Close a deployment */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<
            DeleteDeploymentsDseqBody,
            DeleteDeploymentsDseqData,
            DeleteDeploymentsDseqParameters,
            DeleteDeploymentsDseqError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            DeleteDeploymentsDseqSchema,
            DeleteDeploymentsDseqBody,
            DeleteDeploymentsDseqData,
            DeleteDeploymentsDseqParameters,
            DeleteDeploymentsDseqError | Error,
            TContext
          >
    ): number;
    /** @summary Close a deployment */
    (
      options: ServiceOperationMutationFnOptions<DeleteDeploymentsDseqBody, DeleteDeploymentsDseqParameters>,
      client?: (
        schema: DeleteDeploymentsDseqSchema,
        options: ServiceOperationMutationFnOptions<DeleteDeploymentsDseqBody, DeleteDeploymentsDseqParameters>
      ) => Promise<RequestFnResponse<DeleteDeploymentsDseqData, DeleteDeploymentsDseqError>>
    ): Promise<RequestFnResponse<DeleteDeploymentsDseqData, DeleteDeploymentsDseqError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Close a deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const deleteDeploymentsDseqPendingMutationVariables = qraft.v1Service.deleteDeploymentsDseq.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const deleteDeploymentsDseqMutationData = qraft.v1Service.deleteDeploymentsDseq.useMutationState({
     *     filters: {
     *         parameters: {
     *             path: {
     *                 dseq: dseq
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        DeleteDeploymentsDseqData,
        DeleteDeploymentsDseqError | Error,
        MutationVariables<DeleteDeploymentsDseqBody, DeleteDeploymentsDseqParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<
            DeleteDeploymentsDseqBody,
            DeleteDeploymentsDseqData,
            DeleteDeploymentsDseqParameters,
            DeleteDeploymentsDseqError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            DeleteDeploymentsDseqSchema,
            DeleteDeploymentsDseqBody,
            DeleteDeploymentsDseqData,
            DeleteDeploymentsDseqParameters,
            DeleteDeploymentsDseqError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          DeleteDeploymentsDseqData,
          DeleteDeploymentsDseqError | Error,
          MutationVariables<DeleteDeploymentsDseqBody, DeleteDeploymentsDseqParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: DeleteDeploymentsDseqSchema;
    types: {
      parameters: DeleteDeploymentsDseqParameters;
      data: DeleteDeploymentsDseqData;
      error: DeleteDeploymentsDseqError;
      body: DeleteDeploymentsDseqBody;
    };
  };
  /** @summary Update a deployment */
  putDeploymentsDseq: {
    /** @summary Update a deployment */
    getMutationKey(
      parameters: DeepReadonly<PutDeploymentsDseqParameters> | void
    ): ServiceOperationMutationKey<PutDeploymentsDseqSchema, PutDeploymentsDseqParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Update a deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.putDeploymentsDseq.useMutation({
     *     path: {
     *         dseq: dseq
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.putDeploymentsDseq.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         dseq: dseq
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends PutDeploymentsDseqBody, TContext = unknown>(
      parameters: DeepReadonly<PutDeploymentsDseqParameters>,
      options?: ServiceOperationUseMutationOptions<
        PutDeploymentsDseqSchema,
        PutDeploymentsDseqData,
        PutDeploymentsDseqParameters,
        TVariables,
        PutDeploymentsDseqError | Error,
        TContext
      >
    ): UseMutationResult<PutDeploymentsDseqData, PutDeploymentsDseqError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Update a deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.putDeploymentsDseq.useMutation({
     *     path: {
     *         dseq: dseq
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.putDeploymentsDseq.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         dseq: dseq
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PutDeploymentsDseqBody, PutDeploymentsDseqParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PutDeploymentsDseqSchema,
        PutDeploymentsDseqData,
        PutDeploymentsDseqParameters,
        TVariables,
        PutDeploymentsDseqError | Error,
        TContext
      >
    ): UseMutationResult<PutDeploymentsDseqData, PutDeploymentsDseqError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Update a deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const putDeploymentsDseqTotal = qraft.v1Service.putDeploymentsDseq.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const putDeploymentsDseqTotal = qraft.v1Service.putDeploymentsDseq.useIsMutating({
     *     parameters: {
     *         path: {
     *             dseq: dseq
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<PutDeploymentsDseqBody, PutDeploymentsDseqData, PutDeploymentsDseqParameters, PutDeploymentsDseqError | Error, TContext>
        | MutationFiltersByMutationKey<
            PutDeploymentsDseqSchema,
            PutDeploymentsDseqBody,
            PutDeploymentsDseqData,
            PutDeploymentsDseqParameters,
            PutDeploymentsDseqError | Error,
            TContext
          >
    ): number;
    /** @summary Update a deployment */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<PutDeploymentsDseqBody, PutDeploymentsDseqData, PutDeploymentsDseqParameters, PutDeploymentsDseqError | Error, TContext>
        | MutationFiltersByMutationKey<
            PutDeploymentsDseqSchema,
            PutDeploymentsDseqBody,
            PutDeploymentsDseqData,
            PutDeploymentsDseqParameters,
            PutDeploymentsDseqError | Error,
            TContext
          >
    ): number;
    /** @summary Update a deployment */
    (
      options: ServiceOperationMutationFnOptions<PutDeploymentsDseqBody, PutDeploymentsDseqParameters>,
      client?: (
        schema: PutDeploymentsDseqSchema,
        options: ServiceOperationMutationFnOptions<PutDeploymentsDseqBody, PutDeploymentsDseqParameters>
      ) => Promise<RequestFnResponse<PutDeploymentsDseqData, PutDeploymentsDseqError>>
    ): Promise<RequestFnResponse<PutDeploymentsDseqData, PutDeploymentsDseqError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Update a deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const putDeploymentsDseqPendingMutationVariables = qraft.v1Service.putDeploymentsDseq.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const putDeploymentsDseqMutationData = qraft.v1Service.putDeploymentsDseq.useMutationState({
     *     filters: {
     *         parameters: {
     *             path: {
     *                 dseq: dseq
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        PutDeploymentsDseqData,
        PutDeploymentsDseqError | Error,
        MutationVariables<PutDeploymentsDseqBody, PutDeploymentsDseqParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<PutDeploymentsDseqBody, PutDeploymentsDseqData, PutDeploymentsDseqParameters, PutDeploymentsDseqError | Error, TContext>
        | MutationFiltersByMutationKey<
            PutDeploymentsDseqSchema,
            PutDeploymentsDseqBody,
            PutDeploymentsDseqData,
            PutDeploymentsDseqParameters,
            PutDeploymentsDseqError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          PutDeploymentsDseqData,
          PutDeploymentsDseqError | Error,
          MutationVariables<PutDeploymentsDseqBody, PutDeploymentsDseqParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: PutDeploymentsDseqSchema;
    types: {
      parameters: PutDeploymentsDseqParameters;
      data: PutDeploymentsDseqData;
      error: PutDeploymentsDseqError;
      body: PutDeploymentsDseqBody;
    };
  };
  /** @summary Create new deployment */
  postDeployments: {
    /** @summary Create new deployment */
    getMutationKey(parameters: DeepReadonly<PostDeploymentsParameters> | void): ServiceOperationMutationKey<PostDeploymentsSchema, PostDeploymentsParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Create new deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postDeployments.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postDeployments.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends PostDeploymentsBody, TContext = unknown>(
      parameters: DeepReadonly<PostDeploymentsParameters>,
      options?: ServiceOperationUseMutationOptions<
        PostDeploymentsSchema,
        PostDeploymentsData,
        PostDeploymentsParameters,
        TVariables,
        PostDeploymentsError | Error,
        TContext
      >
    ): UseMutationResult<PostDeploymentsData, PostDeploymentsError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Create new deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postDeployments.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postDeployments.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PostDeploymentsBody, PostDeploymentsParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PostDeploymentsSchema,
        PostDeploymentsData,
        PostDeploymentsParameters,
        TVariables,
        PostDeploymentsError | Error,
        TContext
      >
    ): UseMutationResult<PostDeploymentsData, PostDeploymentsError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Create new deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const postDeploymentsTotal = qraft.v1Service.postDeployments.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const postDeploymentsTotal = qraft.v1Service.postDeployments.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<PostDeploymentsBody, PostDeploymentsData, PostDeploymentsParameters, PostDeploymentsError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostDeploymentsSchema,
            PostDeploymentsBody,
            PostDeploymentsData,
            PostDeploymentsParameters,
            PostDeploymentsError | Error,
            TContext
          >
    ): number;
    /** @summary Create new deployment */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<PostDeploymentsBody, PostDeploymentsData, PostDeploymentsParameters, PostDeploymentsError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostDeploymentsSchema,
            PostDeploymentsBody,
            PostDeploymentsData,
            PostDeploymentsParameters,
            PostDeploymentsError | Error,
            TContext
          >
    ): number;
    /** @summary Create new deployment */
    (
      options: ServiceOperationMutationFnOptions<PostDeploymentsBody, PostDeploymentsParameters>,
      client?: (
        schema: PostDeploymentsSchema,
        options: ServiceOperationMutationFnOptions<PostDeploymentsBody, PostDeploymentsParameters>
      ) => Promise<RequestFnResponse<PostDeploymentsData, PostDeploymentsError>>
    ): Promise<RequestFnResponse<PostDeploymentsData, PostDeploymentsError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Create new deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const postDeploymentsPendingMutationVariables = qraft.v1Service.postDeployments.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const postDeploymentsMutationData = qraft.v1Service.postDeployments.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<PostDeploymentsData, PostDeploymentsError | Error, MutationVariables<PostDeploymentsBody, PostDeploymentsParameters>, TContext>
    >(options?: {
      filters?:
        | MutationFiltersByParameters<PostDeploymentsBody, PostDeploymentsData, PostDeploymentsParameters, PostDeploymentsError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostDeploymentsSchema,
            PostDeploymentsBody,
            PostDeploymentsData,
            PostDeploymentsParameters,
            PostDeploymentsError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<PostDeploymentsData, PostDeploymentsError | Error, MutationVariables<PostDeploymentsBody, PostDeploymentsParameters>, TContext>
      ) => TResult;
    }): Array<TResult>;
    schema: PostDeploymentsSchema;
    types: {
      parameters: PostDeploymentsParameters;
      data: PostDeploymentsData;
      error: PostDeploymentsError;
      body: PostDeploymentsBody;
    };
  };
  /** @summary List deployments with pagination and filtering */
  getDeployments: {
    /** @summary List deployments with pagination and filtering */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentsSchema, GetDeploymentsData, TInfinite, GetDeploymentsParameters, GetDeploymentsError>
        | QueryFiltersByQueryKey<GetDeploymentsSchema, GetDeploymentsData, TInfinite, GetDeploymentsParameters, GetDeploymentsError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary List deployments with pagination and filtering */
    getQueryKey(parameters: DeepReadonly<GetDeploymentsParameters> | void): ServiceOperationQueryKey<GetDeploymentsSchema, GetDeploymentsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary List deployments with pagination and filtering
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeployments.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeployments.useQuery({
     *     query: {
     *         skip: skip
     *     }
     * })
     * ```
     */
    useQuery<TData = GetDeploymentsData>(
      parameters: ServiceOperationQueryKey<GetDeploymentsSchema, GetDeploymentsParameters> | (DeepReadonly<GetDeploymentsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetDeploymentsData, GetDeploymentsError, TData, ServiceOperationQueryKey<GetDeploymentsSchema, GetDeploymentsParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetDeploymentsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary List deployments with pagination and filtering
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeployments.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeployments.useQuery({
     *     query: {
     *         skip: skip
     *     }
     * })
     * ```
     */
    useQuery<TData = GetDeploymentsData>(
      parameters: ServiceOperationQueryKey<GetDeploymentsSchema, GetDeploymentsParameters> | (DeepReadonly<GetDeploymentsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetDeploymentsData, GetDeploymentsError, TData, ServiceOperationQueryKey<GetDeploymentsSchema, GetDeploymentsParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetDeploymentsError | Error>;
    /** @summary List deployments with pagination and filtering */
    fetchInfiniteQuery<TPageParam extends GetDeploymentsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetDeploymentsSchema,
        GetDeploymentsData,
        GetDeploymentsParameters,
        DeepReadonly<TPageParam>,
        GetDeploymentsError
      > | void
    ): Promise<OperationInfiniteData<GetDeploymentsData, GetDeploymentsParameters>>;
    /** @summary List deployments with pagination and filtering */
    prefetchInfiniteQuery<TPageParam extends GetDeploymentsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetDeploymentsSchema,
        GetDeploymentsData,
        GetDeploymentsParameters,
        DeepReadonly<TPageParam>,
        GetDeploymentsError
      > | void
    ): Promise<void>;
    /** @summary List deployments with pagination and filtering */
    ensureInfiniteQueryData<TPageParam extends GetDeploymentsParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetDeploymentsSchema,
        GetDeploymentsData,
        GetDeploymentsParameters,
        DeepReadonly<TPageParam>,
        GetDeploymentsError
      > | void
    ): Promise<OperationInfiniteData<GetDeploymentsData, GetDeploymentsParameters>>;
    /** @summary List deployments with pagination and filtering */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetDeploymentsSchema, GetDeploymentsData, GetDeploymentsParameters, GetDeploymentsError> | void
    ): Promise<GetDeploymentsData>;
    /** @summary List deployments with pagination and filtering */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetDeploymentsSchema, GetDeploymentsData, GetDeploymentsParameters, GetDeploymentsError> | void
    ): Promise<void>;
    /** @summary List deployments with pagination and filtering */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetDeploymentsSchema, GetDeploymentsData, GetDeploymentsParameters, GetDeploymentsError> | void
    ): Promise<GetDeploymentsData>;
    /** @summary List deployments with pagination and filtering */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetDeploymentsSchema, GetDeploymentsParameters> | (DeepReadonly<GetDeploymentsParameters> | void)
    ): OperationInfiniteData<GetDeploymentsData, GetDeploymentsParameters> | undefined;
    /** @summary List deployments with pagination and filtering */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentsSchema, GetDeploymentsData, TInfinite, GetDeploymentsParameters, GetDeploymentsError>
        | QueryFiltersByQueryKey<GetDeploymentsSchema, GetDeploymentsData, TInfinite, GetDeploymentsParameters, GetDeploymentsError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetDeploymentsSchema, GetDeploymentsParameters>,
            data: NoInfer<OperationInfiniteData<GetDeploymentsData, GetDeploymentsParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetDeploymentsSchema, GetDeploymentsParameters>, data: GetDeploymentsData | undefined]>;
    /** @summary List deployments with pagination and filtering */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetDeploymentsSchema, GetDeploymentsParameters> | (DeepReadonly<GetDeploymentsParameters> | void)
    ): GetDeploymentsData | undefined;
    /** @summary List deployments with pagination and filtering */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetDeploymentsSchema, GetDeploymentsParameters> | (DeepReadonly<GetDeploymentsParameters> | void)
    ): QueryState<GetDeploymentsData, GetDeploymentsError> | undefined;
    /** @summary List deployments with pagination and filtering */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetDeploymentsParameters> | ServiceOperationInfiniteQueryKey<GetDeploymentsSchema, GetDeploymentsParameters> | void
    ): QueryState<OperationInfiniteData<GetDeploymentsData, GetDeploymentsParameters>, GetDeploymentsError> | undefined;
    /** @summary List deployments with pagination and filtering */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetDeploymentsSchema, GetDeploymentsData, TInfinite, GetDeploymentsParameters, GetDeploymentsError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary List deployments with pagination and filtering */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentsSchema, GetDeploymentsData, TInfinite, GetDeploymentsParameters, GetDeploymentsError>
        | QueryFiltersByQueryKey<GetDeploymentsSchema, GetDeploymentsData, TInfinite, GetDeploymentsParameters, GetDeploymentsError>
    ): number;
    /** @summary List deployments with pagination and filtering */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetDeploymentsSchema, GetDeploymentsParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetDeploymentsParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetDeploymentsSchema,
        options: {
          parameters: GetDeploymentsParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetDeploymentsData, GetDeploymentsError>>
    ): Promise<RequestFnResponse<GetDeploymentsData, GetDeploymentsError>>;
    /** @summary List deployments with pagination and filtering */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentsSchema, GetDeploymentsData, TInfinite, GetDeploymentsParameters, GetDeploymentsError>
        | QueryFiltersByQueryKey<GetDeploymentsSchema, GetDeploymentsData, TInfinite, GetDeploymentsParameters, GetDeploymentsError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary List deployments with pagination and filtering */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentsSchema, GetDeploymentsData, TInfinite, GetDeploymentsParameters, GetDeploymentsError>
        | QueryFiltersByQueryKey<GetDeploymentsSchema, GetDeploymentsData, TInfinite, GetDeploymentsParameters, GetDeploymentsError>
    ): void;
    /** @summary List deployments with pagination and filtering */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentsSchema, GetDeploymentsData, TInfinite, GetDeploymentsParameters, GetDeploymentsError>
        | QueryFiltersByQueryKey<GetDeploymentsSchema, GetDeploymentsData, TInfinite, GetDeploymentsParameters, GetDeploymentsError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary List deployments with pagination and filtering */
    setInfiniteQueryData(
      parameters: (DeepReadonly<GetDeploymentsParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetDeploymentsSchema, GetDeploymentsParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetDeploymentsData, GetDeploymentsParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetDeploymentsData, GetDeploymentsParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetDeploymentsData, GetDeploymentsParameters> | undefined;
    /** @summary List deployments with pagination and filtering */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetDeploymentsSchema, GetDeploymentsData, TInfinite, GetDeploymentsParameters, GetDeploymentsError>
        | QueryFiltersByQueryKey<GetDeploymentsSchema, GetDeploymentsData, TInfinite, GetDeploymentsParameters, GetDeploymentsError>,
      updater: Updater<NoInfer<GetDeploymentsData> | undefined, NoInfer<GetDeploymentsData> | undefined>,
      options?: SetDataOptions
    ): Array<GetDeploymentsData | undefined>;
    /** @summary List deployments with pagination and filtering */
    setQueryData(
      parameters: (DeepReadonly<GetDeploymentsParameters> | undefined) | ServiceOperationQueryKey<GetDeploymentsSchema, GetDeploymentsParameters>,
      updater: Updater<NoInfer<GetDeploymentsData> | undefined, NoInfer<DeepReadonly<GetDeploymentsData>> | undefined>,
      options?: SetDataOptions
    ): GetDeploymentsData | undefined;
    /** @summary List deployments with pagination and filtering */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetDeploymentsParameters> | void
    ): ServiceOperationInfiniteQueryKey<GetDeploymentsSchema, GetDeploymentsParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary List deployments with pagination and filtering
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getDeployments.useInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             skip: initialSkip
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetDeploymentsParameters,
      TQueryFnData = GetDeploymentsData,
      TData = OperationInfiniteData<TQueryFnData, GetDeploymentsParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetDeploymentsSchema, GetDeploymentsParameters> | (DeepReadonly<GetDeploymentsParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetDeploymentsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetDeploymentsSchema, GetDeploymentsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetDeploymentsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary List deployments with pagination and filtering
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getDeployments.useInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             skip: initialSkip
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetDeploymentsParameters,
      TQueryFnData = GetDeploymentsData,
      TData = OperationInfiniteData<TQueryFnData, GetDeploymentsParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetDeploymentsSchema, GetDeploymentsParameters> | (DeepReadonly<GetDeploymentsParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetDeploymentsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetDeploymentsSchema, GetDeploymentsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetDeploymentsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetDeploymentsError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary List deployments with pagination and filtering
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getDeploymentsTotal = qraft.v1Service.getDeployments.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getDeploymentsByParametersTotal = qraft.v1Service.getDeployments.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         query: {
     *             skip: skip
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentsSchema, GetDeploymentsData, TInfinite, GetDeploymentsParameters, GetDeploymentsError>
        | QueryFiltersByQueryKey<GetDeploymentsSchema, GetDeploymentsData, TInfinite, GetDeploymentsParameters, GetDeploymentsError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary List deployments with pagination and filtering
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getDeploymentsResults = qraft.v1Service.getDeployments.useQueries({
     *     queries: [
     *         {
     *             query: {
     *                 skip: skip1
     *             }
     *         },
     *         {
     *             query: {
     *                 skip: skip2
     *             }
     *         }
     *     ]
     * });
     * getDeploymentsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getDeploymentsCombinedResults = qraft.v1Service.getDeployments.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 skip: skip1
     *             }
     *         },
     *         {
     *             query: {
     *                 skip: skip2
     *             }
     *         }
     *     ]
     * });
     * getDeploymentsCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetDeploymentsSchema, GetDeploymentsParameters, GetDeploymentsData, GetDeploymentsError>>,
      TCombinedResult = Array<UseQueryResult<GetDeploymentsData, GetDeploymentsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetDeploymentsData, GetDeploymentsError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary List deployments with pagination and filtering */
    getQueryKey(parameters: DeepReadonly<GetDeploymentsParameters> | void): ServiceOperationQueryKey<GetDeploymentsSchema, GetDeploymentsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary List deployments with pagination and filtering
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeployments.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeployments.useQuery({
     *     query: {
     *         skip: skip
     *     }
     * })
     * ```
     */
    useQuery<TData = GetDeploymentsData>(
      parameters: ServiceOperationQueryKey<GetDeploymentsSchema, GetDeploymentsParameters> | (DeepReadonly<GetDeploymentsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetDeploymentsData, GetDeploymentsError, TData, ServiceOperationQueryKey<GetDeploymentsSchema, GetDeploymentsParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetDeploymentsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary List deployments with pagination and filtering
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeployments.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeployments.useQuery({
     *     query: {
     *         skip: skip
     *     }
     * })
     * ```
     */
    useQuery<TData = GetDeploymentsData>(
      parameters: ServiceOperationQueryKey<GetDeploymentsSchema, GetDeploymentsParameters> | (DeepReadonly<GetDeploymentsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetDeploymentsData, GetDeploymentsError, TData, ServiceOperationQueryKey<GetDeploymentsSchema, GetDeploymentsParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetDeploymentsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary List deployments with pagination and filtering
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getDeployments.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             skip: initialSkip
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetDeploymentsParameters, TData = GetDeploymentsData>(
      parameters: ServiceOperationInfiniteQueryKey<GetDeploymentsSchema, GetDeploymentsParameters> | (DeepReadonly<GetDeploymentsParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetDeploymentsData,
          GetDeploymentsError,
          OperationInfiniteData<TData, GetDeploymentsParameters>,
          GetDeploymentsData,
          ServiceOperationInfiniteQueryKey<GetDeploymentsSchema, GetDeploymentsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetDeploymentsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetDeploymentsParameters>, GetDeploymentsError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary List deployments with pagination and filtering
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getDeploymentsData = qraft.v1Service.getDeployments.useSuspenseQueries({
     *     queries: [
     *         {
     *             query: {
     *                 skip: skip1
     *             }
     *         },
     *         {
     *             query: {
     *                 skip: skip2
     *             }
     *         }
     *     ]
     * });
     * getDeploymentsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getDeploymentsCombinedData = qraft.v1Service.getDeployments.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 skip: skip1
     *             }
     *         },
     *         {
     *             query: {
     *                 skip: skip2
     *             }
     *         }
     *     ]
     * });
     * getDeploymentsCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetDeploymentsSchema, GetDeploymentsParameters, GetDeploymentsData, GetDeploymentsError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetDeploymentsData, GetDeploymentsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetDeploymentsData, GetDeploymentsError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary List deployments with pagination and filtering
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getDeployments.useSuspenseQuery()
     * ```
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getDeployments.useSuspenseQuery({
     *     query: {
     *         skip: skip
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetDeploymentsData>(
      parameters: ServiceOperationQueryKey<GetDeploymentsSchema, GetDeploymentsParameters> | (DeepReadonly<GetDeploymentsParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<GetDeploymentsData, GetDeploymentsError, TData, ServiceOperationQueryKey<GetDeploymentsSchema, GetDeploymentsParameters>>,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetDeploymentsError | Error>;
    schema: GetDeploymentsSchema;
    types: {
      parameters: GetDeploymentsParameters;
      data: GetDeploymentsData;
      error: GetDeploymentsError;
    };
  };
  /** @summary Deposit into a deployment */
  postDepositDeployment: {
    /** @summary Deposit into a deployment */
    getMutationKey(
      parameters: DeepReadonly<PostDepositDeploymentParameters> | void
    ): ServiceOperationMutationKey<PostDepositDeploymentSchema, PostDepositDeploymentParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Deposit into a deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postDepositDeployment.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postDepositDeployment.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends PostDepositDeploymentBody, TContext = unknown>(
      parameters: DeepReadonly<PostDepositDeploymentParameters>,
      options?: ServiceOperationUseMutationOptions<
        PostDepositDeploymentSchema,
        PostDepositDeploymentData,
        PostDepositDeploymentParameters,
        TVariables,
        PostDepositDeploymentError | Error,
        TContext
      >
    ): UseMutationResult<PostDepositDeploymentData, PostDepositDeploymentError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Deposit into a deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postDepositDeployment.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postDepositDeployment.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PostDepositDeploymentBody, PostDepositDeploymentParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PostDepositDeploymentSchema,
        PostDepositDeploymentData,
        PostDepositDeploymentParameters,
        TVariables,
        PostDepositDeploymentError | Error,
        TContext
      >
    ): UseMutationResult<PostDepositDeploymentData, PostDepositDeploymentError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Deposit into a deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const postDepositDeploymentTotal = qraft.v1Service.postDepositDeployment.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const postDepositDeploymentTotal = qraft.v1Service.postDepositDeployment.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<
            PostDepositDeploymentBody,
            PostDepositDeploymentData,
            PostDepositDeploymentParameters,
            PostDepositDeploymentError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PostDepositDeploymentSchema,
            PostDepositDeploymentBody,
            PostDepositDeploymentData,
            PostDepositDeploymentParameters,
            PostDepositDeploymentError | Error,
            TContext
          >
    ): number;
    /** @summary Deposit into a deployment */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<
            PostDepositDeploymentBody,
            PostDepositDeploymentData,
            PostDepositDeploymentParameters,
            PostDepositDeploymentError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PostDepositDeploymentSchema,
            PostDepositDeploymentBody,
            PostDepositDeploymentData,
            PostDepositDeploymentParameters,
            PostDepositDeploymentError | Error,
            TContext
          >
    ): number;
    /** @summary Deposit into a deployment */
    (
      options: ServiceOperationMutationFnOptions<PostDepositDeploymentBody, PostDepositDeploymentParameters>,
      client?: (
        schema: PostDepositDeploymentSchema,
        options: ServiceOperationMutationFnOptions<PostDepositDeploymentBody, PostDepositDeploymentParameters>
      ) => Promise<RequestFnResponse<PostDepositDeploymentData, PostDepositDeploymentError>>
    ): Promise<RequestFnResponse<PostDepositDeploymentData, PostDepositDeploymentError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Deposit into a deployment
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const postDepositDeploymentPendingMutationVariables = qraft.v1Service.postDepositDeployment.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const postDepositDeploymentMutationData = qraft.v1Service.postDepositDeployment.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        PostDepositDeploymentData,
        PostDepositDeploymentError | Error,
        MutationVariables<PostDepositDeploymentBody, PostDepositDeploymentParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<
            PostDepositDeploymentBody,
            PostDepositDeploymentData,
            PostDepositDeploymentParameters,
            PostDepositDeploymentError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PostDepositDeploymentSchema,
            PostDepositDeploymentBody,
            PostDepositDeploymentData,
            PostDepositDeploymentParameters,
            PostDepositDeploymentError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          PostDepositDeploymentData,
          PostDepositDeploymentError | Error,
          MutationVariables<PostDepositDeploymentBody, PostDepositDeploymentParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: PostDepositDeploymentSchema;
    types: {
      parameters: PostDepositDeploymentParameters;
      data: PostDepositDeploymentData;
      error: PostDepositDeploymentError;
      body: PostDepositDeploymentBody;
    };
  };
  /** @summary Get a list of deployments by owner address. */
  getAddressesAddressDeploymentsSkipLimit: {
    /** @summary Get a list of deployments by owner address. */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetAddressesAddressDeploymentsSkipLimitSchema,
            GetAddressesAddressDeploymentsSkipLimitData,
            TInfinite,
            GetAddressesAddressDeploymentsSkipLimitParameters,
            GetAddressesAddressDeploymentsSkipLimitError
          >
        | QueryFiltersByQueryKey<
            GetAddressesAddressDeploymentsSkipLimitSchema,
            GetAddressesAddressDeploymentsSkipLimitData,
            TInfinite,
            GetAddressesAddressDeploymentsSkipLimitParameters,
            GetAddressesAddressDeploymentsSkipLimitError
          >,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get a list of deployments by owner address. */
    getQueryKey(
      parameters: DeepReadonly<GetAddressesAddressDeploymentsSkipLimitParameters>
    ): ServiceOperationQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of deployments by owner address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAddressesAddressDeploymentsSkipLimit.useQuery({
     *     path: {
     *         address: address,
     *         limit: limit
     *     },
     *     query: {
     *         status: status
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAddressesAddressDeploymentsSkipLimitData>(
      parameters:
        | ServiceOperationQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>
        | DeepReadonly<GetAddressesAddressDeploymentsSkipLimitParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetAddressesAddressDeploymentsSkipLimitData,
          GetAddressesAddressDeploymentsSkipLimitError,
          TData,
          ServiceOperationQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetAddressesAddressDeploymentsSkipLimitError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of deployments by owner address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAddressesAddressDeploymentsSkipLimit.useQuery({
     *     path: {
     *         address: address,
     *         limit: limit
     *     },
     *     query: {
     *         status: status
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAddressesAddressDeploymentsSkipLimitData>(
      parameters:
        | ServiceOperationQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>
        | DeepReadonly<GetAddressesAddressDeploymentsSkipLimitParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetAddressesAddressDeploymentsSkipLimitData,
          GetAddressesAddressDeploymentsSkipLimitError,
          TData,
          ServiceOperationQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetAddressesAddressDeploymentsSkipLimitError | Error>;
    /** @summary Get a list of deployments by owner address. */
    fetchInfiniteQuery<TPageParam extends GetAddressesAddressDeploymentsSkipLimitParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetAddressesAddressDeploymentsSkipLimitSchema,
        GetAddressesAddressDeploymentsSkipLimitData,
        GetAddressesAddressDeploymentsSkipLimitParameters,
        DeepReadonly<TPageParam>,
        GetAddressesAddressDeploymentsSkipLimitError
      >
    ): Promise<OperationInfiniteData<GetAddressesAddressDeploymentsSkipLimitData, GetAddressesAddressDeploymentsSkipLimitParameters>>;
    /** @summary Get a list of deployments by owner address. */
    prefetchInfiniteQuery<TPageParam extends GetAddressesAddressDeploymentsSkipLimitParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetAddressesAddressDeploymentsSkipLimitSchema,
        GetAddressesAddressDeploymentsSkipLimitData,
        GetAddressesAddressDeploymentsSkipLimitParameters,
        DeepReadonly<TPageParam>,
        GetAddressesAddressDeploymentsSkipLimitError
      >
    ): Promise<void>;
    /** @summary Get a list of deployments by owner address. */
    ensureInfiniteQueryData<TPageParam extends GetAddressesAddressDeploymentsSkipLimitParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetAddressesAddressDeploymentsSkipLimitSchema,
        GetAddressesAddressDeploymentsSkipLimitData,
        GetAddressesAddressDeploymentsSkipLimitParameters,
        DeepReadonly<TPageParam>,
        GetAddressesAddressDeploymentsSkipLimitError
      >
    ): Promise<OperationInfiniteData<GetAddressesAddressDeploymentsSkipLimitData, GetAddressesAddressDeploymentsSkipLimitParameters>>;
    /** @summary Get a list of deployments by owner address. */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetAddressesAddressDeploymentsSkipLimitSchema,
        GetAddressesAddressDeploymentsSkipLimitData,
        GetAddressesAddressDeploymentsSkipLimitParameters,
        GetAddressesAddressDeploymentsSkipLimitError
      >
    ): Promise<GetAddressesAddressDeploymentsSkipLimitData>;
    /** @summary Get a list of deployments by owner address. */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetAddressesAddressDeploymentsSkipLimitSchema,
        GetAddressesAddressDeploymentsSkipLimitData,
        GetAddressesAddressDeploymentsSkipLimitParameters,
        GetAddressesAddressDeploymentsSkipLimitError
      >
    ): Promise<void>;
    /** @summary Get a list of deployments by owner address. */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetAddressesAddressDeploymentsSkipLimitSchema,
        GetAddressesAddressDeploymentsSkipLimitData,
        GetAddressesAddressDeploymentsSkipLimitParameters,
        GetAddressesAddressDeploymentsSkipLimitError
      >
    ): Promise<GetAddressesAddressDeploymentsSkipLimitData>;
    /** @summary Get a list of deployments by owner address. */
    getInfiniteQueryData(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>
        | DeepReadonly<GetAddressesAddressDeploymentsSkipLimitParameters>
    ): OperationInfiniteData<GetAddressesAddressDeploymentsSkipLimitData, GetAddressesAddressDeploymentsSkipLimitParameters> | undefined;
    /** @summary Get a list of deployments by owner address. */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetAddressesAddressDeploymentsSkipLimitSchema,
            GetAddressesAddressDeploymentsSkipLimitData,
            TInfinite,
            GetAddressesAddressDeploymentsSkipLimitParameters,
            GetAddressesAddressDeploymentsSkipLimitError
          >
        | QueryFiltersByQueryKey<
            GetAddressesAddressDeploymentsSkipLimitSchema,
            GetAddressesAddressDeploymentsSkipLimitData,
            TInfinite,
            GetAddressesAddressDeploymentsSkipLimitParameters,
            GetAddressesAddressDeploymentsSkipLimitError
          >
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>,
            data: NoInfer<OperationInfiniteData<GetAddressesAddressDeploymentsSkipLimitData, GetAddressesAddressDeploymentsSkipLimitParameters>> | undefined
          ]
        >
      : Array<
          [
            queryKey: ServiceOperationQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>,
            data: GetAddressesAddressDeploymentsSkipLimitData | undefined
          ]
        >;
    /** @summary Get a list of deployments by owner address. */
    getQueryData(
      parameters:
        | ServiceOperationQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>
        | DeepReadonly<GetAddressesAddressDeploymentsSkipLimitParameters>
    ): GetAddressesAddressDeploymentsSkipLimitData | undefined;
    /** @summary Get a list of deployments by owner address. */
    getQueryState(
      parameters:
        | ServiceOperationQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>
        | DeepReadonly<GetAddressesAddressDeploymentsSkipLimitParameters>
    ): QueryState<GetAddressesAddressDeploymentsSkipLimitData, GetAddressesAddressDeploymentsSkipLimitError> | undefined;
    /** @summary Get a list of deployments by owner address. */
    getInfiniteQueryState(
      parameters:
        | DeepReadonly<GetAddressesAddressDeploymentsSkipLimitParameters>
        | ServiceOperationInfiniteQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>
    ):
      | QueryState<
          OperationInfiniteData<GetAddressesAddressDeploymentsSkipLimitData, GetAddressesAddressDeploymentsSkipLimitParameters>,
          GetAddressesAddressDeploymentsSkipLimitError
        >
      | undefined;
    /** @summary Get a list of deployments by owner address. */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<
        GetAddressesAddressDeploymentsSkipLimitSchema,
        GetAddressesAddressDeploymentsSkipLimitData,
        TInfinite,
        GetAddressesAddressDeploymentsSkipLimitParameters,
        GetAddressesAddressDeploymentsSkipLimitError
      >,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get a list of deployments by owner address. */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetAddressesAddressDeploymentsSkipLimitSchema,
            GetAddressesAddressDeploymentsSkipLimitData,
            TInfinite,
            GetAddressesAddressDeploymentsSkipLimitParameters,
            GetAddressesAddressDeploymentsSkipLimitError
          >
        | QueryFiltersByQueryKey<
            GetAddressesAddressDeploymentsSkipLimitSchema,
            GetAddressesAddressDeploymentsSkipLimitData,
            TInfinite,
            GetAddressesAddressDeploymentsSkipLimitParameters,
            GetAddressesAddressDeploymentsSkipLimitError
          >
    ): number;
    /** @summary Get a list of deployments by owner address. */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetAddressesAddressDeploymentsSkipLimitParameters, TMeta, TSignal>,
      client?: (
        schema: GetAddressesAddressDeploymentsSkipLimitSchema,
        options: {
          parameters: GetAddressesAddressDeploymentsSkipLimitParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetAddressesAddressDeploymentsSkipLimitData, GetAddressesAddressDeploymentsSkipLimitError>>
    ): Promise<RequestFnResponse<GetAddressesAddressDeploymentsSkipLimitData, GetAddressesAddressDeploymentsSkipLimitError>>;
    /** @summary Get a list of deployments by owner address. */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetAddressesAddressDeploymentsSkipLimitSchema,
            GetAddressesAddressDeploymentsSkipLimitData,
            TInfinite,
            GetAddressesAddressDeploymentsSkipLimitParameters,
            GetAddressesAddressDeploymentsSkipLimitError
          >
        | QueryFiltersByQueryKey<
            GetAddressesAddressDeploymentsSkipLimitSchema,
            GetAddressesAddressDeploymentsSkipLimitData,
            TInfinite,
            GetAddressesAddressDeploymentsSkipLimitParameters,
            GetAddressesAddressDeploymentsSkipLimitError
          >,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get a list of deployments by owner address. */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetAddressesAddressDeploymentsSkipLimitSchema,
            GetAddressesAddressDeploymentsSkipLimitData,
            TInfinite,
            GetAddressesAddressDeploymentsSkipLimitParameters,
            GetAddressesAddressDeploymentsSkipLimitError
          >
        | QueryFiltersByQueryKey<
            GetAddressesAddressDeploymentsSkipLimitSchema,
            GetAddressesAddressDeploymentsSkipLimitData,
            TInfinite,
            GetAddressesAddressDeploymentsSkipLimitParameters,
            GetAddressesAddressDeploymentsSkipLimitError
          >
    ): void;
    /** @summary Get a list of deployments by owner address. */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetAddressesAddressDeploymentsSkipLimitSchema,
            GetAddressesAddressDeploymentsSkipLimitData,
            TInfinite,
            GetAddressesAddressDeploymentsSkipLimitParameters,
            GetAddressesAddressDeploymentsSkipLimitError
          >
        | QueryFiltersByQueryKey<
            GetAddressesAddressDeploymentsSkipLimitSchema,
            GetAddressesAddressDeploymentsSkipLimitData,
            TInfinite,
            GetAddressesAddressDeploymentsSkipLimitParameters,
            GetAddressesAddressDeploymentsSkipLimitError
          >,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get a list of deployments by owner address. */
    setInfiniteQueryData(
      parameters:
        | DeepReadonly<GetAddressesAddressDeploymentsSkipLimitParameters>
        | ServiceOperationInfiniteQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetAddressesAddressDeploymentsSkipLimitData, GetAddressesAddressDeploymentsSkipLimitParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetAddressesAddressDeploymentsSkipLimitData, GetAddressesAddressDeploymentsSkipLimitParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetAddressesAddressDeploymentsSkipLimitData, GetAddressesAddressDeploymentsSkipLimitParameters> | undefined;
    /** @summary Get a list of deployments by owner address. */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<
            GetAddressesAddressDeploymentsSkipLimitSchema,
            GetAddressesAddressDeploymentsSkipLimitData,
            TInfinite,
            GetAddressesAddressDeploymentsSkipLimitParameters,
            GetAddressesAddressDeploymentsSkipLimitError
          >
        | QueryFiltersByQueryKey<
            GetAddressesAddressDeploymentsSkipLimitSchema,
            GetAddressesAddressDeploymentsSkipLimitData,
            TInfinite,
            GetAddressesAddressDeploymentsSkipLimitParameters,
            GetAddressesAddressDeploymentsSkipLimitError
          >,
      updater: Updater<NoInfer<GetAddressesAddressDeploymentsSkipLimitData> | undefined, NoInfer<GetAddressesAddressDeploymentsSkipLimitData> | undefined>,
      options?: SetDataOptions
    ): Array<GetAddressesAddressDeploymentsSkipLimitData | undefined>;
    /** @summary Get a list of deployments by owner address. */
    setQueryData(
      parameters:
        | DeepReadonly<GetAddressesAddressDeploymentsSkipLimitParameters>
        | ServiceOperationQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>,
      updater: Updater<
        NoInfer<GetAddressesAddressDeploymentsSkipLimitData> | undefined,
        NoInfer<DeepReadonly<GetAddressesAddressDeploymentsSkipLimitData>> | undefined
      >,
      options?: SetDataOptions
    ): GetAddressesAddressDeploymentsSkipLimitData | undefined;
    /** @summary Get a list of deployments by owner address. */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetAddressesAddressDeploymentsSkipLimitParameters>
    ): ServiceOperationInfiniteQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of deployments by owner address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAddressesAddressDeploymentsSkipLimit.useInfiniteQuery({
     *     path: {
     *         address: address,
     *         limit: limit
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             status: initialStatus
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetAddressesAddressDeploymentsSkipLimitParameters,
      TQueryFnData = GetAddressesAddressDeploymentsSkipLimitData,
      TData = OperationInfiniteData<TQueryFnData, GetAddressesAddressDeploymentsSkipLimitParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>
        | DeepReadonly<GetAddressesAddressDeploymentsSkipLimitParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetAddressesAddressDeploymentsSkipLimitError,
          TData,
          ServiceOperationInfiniteQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetAddressesAddressDeploymentsSkipLimitError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of deployments by owner address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAddressesAddressDeploymentsSkipLimit.useInfiniteQuery({
     *     path: {
     *         address: address,
     *         limit: limit
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             status: initialStatus
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetAddressesAddressDeploymentsSkipLimitParameters,
      TQueryFnData = GetAddressesAddressDeploymentsSkipLimitData,
      TData = OperationInfiniteData<TQueryFnData, GetAddressesAddressDeploymentsSkipLimitParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>
        | DeepReadonly<GetAddressesAddressDeploymentsSkipLimitParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetAddressesAddressDeploymentsSkipLimitError,
          TData,
          ServiceOperationInfiniteQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetAddressesAddressDeploymentsSkipLimitData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetAddressesAddressDeploymentsSkipLimitError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get a list of deployments by owner address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getAddressesAddressDeploymentsSkipLimitTotal = qraft.v1Service.getAddressesAddressDeploymentsSkipLimit.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getAddressesAddressDeploymentsSkipLimitByParametersTotal = qraft.v1Service.getAddressesAddressDeploymentsSkipLimit.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             address: address,
     *             limit: limit
     *         },
     *         query: {
     *             status: status
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetAddressesAddressDeploymentsSkipLimitSchema,
            GetAddressesAddressDeploymentsSkipLimitData,
            TInfinite,
            GetAddressesAddressDeploymentsSkipLimitParameters,
            GetAddressesAddressDeploymentsSkipLimitError
          >
        | QueryFiltersByQueryKey<
            GetAddressesAddressDeploymentsSkipLimitSchema,
            GetAddressesAddressDeploymentsSkipLimitData,
            TInfinite,
            GetAddressesAddressDeploymentsSkipLimitParameters,
            GetAddressesAddressDeploymentsSkipLimitError
          >
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get a list of deployments by owner address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getAddressesAddressDeploymentsSkipLimitResults = qraft.v1Service.getAddressesAddressDeploymentsSkipLimit.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 address: address1,
     *                 limit: limit1
     *             },
     *             query: {
     *                 status: status1
     *             }
     *         },
     *         {
     *             path: {
     *                 address: address2,
     *                 limit: limit2
     *             },
     *             query: {
     *                 status: status2
     *             }
     *         }
     *     ]
     * });
     * getAddressesAddressDeploymentsSkipLimitResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getAddressesAddressDeploymentsSkipLimitCombinedResults = qraft.v1Service.getAddressesAddressDeploymentsSkipLimit.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 address: address1,
     *                 limit: limit1
     *             },
     *             query: {
     *                 status: status1
     *             }
     *         },
     *         {
     *             path: {
     *                 address: address2,
     *                 limit: limit2
     *             },
     *             query: {
     *                 status: status2
     *             }
     *         }
     *     ]
     * });
     * getAddressesAddressDeploymentsSkipLimitCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<
          GetAddressesAddressDeploymentsSkipLimitSchema,
          GetAddressesAddressDeploymentsSkipLimitParameters,
          GetAddressesAddressDeploymentsSkipLimitData,
          GetAddressesAddressDeploymentsSkipLimitError
        >
      >,
      TCombinedResult = Array<UseQueryResult<GetAddressesAddressDeploymentsSkipLimitData, GetAddressesAddressDeploymentsSkipLimitError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetAddressesAddressDeploymentsSkipLimitData, GetAddressesAddressDeploymentsSkipLimitError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get a list of deployments by owner address. */
    getQueryKey(
      parameters: DeepReadonly<GetAddressesAddressDeploymentsSkipLimitParameters>
    ): ServiceOperationQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of deployments by owner address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAddressesAddressDeploymentsSkipLimit.useQuery({
     *     path: {
     *         address: address,
     *         limit: limit
     *     },
     *     query: {
     *         status: status
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAddressesAddressDeploymentsSkipLimitData>(
      parameters:
        | ServiceOperationQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>
        | DeepReadonly<GetAddressesAddressDeploymentsSkipLimitParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetAddressesAddressDeploymentsSkipLimitData,
          GetAddressesAddressDeploymentsSkipLimitError,
          TData,
          ServiceOperationQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetAddressesAddressDeploymentsSkipLimitError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of deployments by owner address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAddressesAddressDeploymentsSkipLimit.useQuery({
     *     path: {
     *         address: address,
     *         limit: limit
     *     },
     *     query: {
     *         status: status
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAddressesAddressDeploymentsSkipLimitData>(
      parameters:
        | ServiceOperationQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>
        | DeepReadonly<GetAddressesAddressDeploymentsSkipLimitParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetAddressesAddressDeploymentsSkipLimitData,
          GetAddressesAddressDeploymentsSkipLimitError,
          TData,
          ServiceOperationQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetAddressesAddressDeploymentsSkipLimitError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get a list of deployments by owner address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAddressesAddressDeploymentsSkipLimit.useSuspenseInfiniteQuery({
     *     path: {
     *         address: address,
     *         limit: limit
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             status: initialStatus
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetAddressesAddressDeploymentsSkipLimitParameters, TData = GetAddressesAddressDeploymentsSkipLimitData>(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>
        | DeepReadonly<GetAddressesAddressDeploymentsSkipLimitParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetAddressesAddressDeploymentsSkipLimitData,
          GetAddressesAddressDeploymentsSkipLimitError,
          OperationInfiniteData<TData, GetAddressesAddressDeploymentsSkipLimitParameters>,
          GetAddressesAddressDeploymentsSkipLimitData,
          ServiceOperationInfiniteQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetAddressesAddressDeploymentsSkipLimitData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<
      OperationInfiniteData<TData, GetAddressesAddressDeploymentsSkipLimitParameters>,
      GetAddressesAddressDeploymentsSkipLimitError | Error
    >;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get a list of deployments by owner address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getAddressesAddressDeploymentsSkipLimitData = qraft.v1Service.getAddressesAddressDeploymentsSkipLimit.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 address: address1,
     *                 limit: limit1
     *             },
     *             query: {
     *                 status: status1
     *             }
     *         },
     *         {
     *             path: {
     *                 address: address2,
     *                 limit: limit2
     *             },
     *             query: {
     *                 status: status2
     *             }
     *         }
     *     ]
     * });
     * getAddressesAddressDeploymentsSkipLimitResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getAddressesAddressDeploymentsSkipLimitCombinedData = qraft.v1Service.getAddressesAddressDeploymentsSkipLimit.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 address: address1,
     *                 limit: limit1
     *             },
     *             query: {
     *                 status: status1
     *             }
     *         },
     *         {
     *             path: {
     *                 address: address2,
     *                 limit: limit2
     *             },
     *             query: {
     *                 status: status2
     *             }
     *         }
     *     ]
     * });
     * getAddressesAddressDeploymentsSkipLimitCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<
          GetAddressesAddressDeploymentsSkipLimitSchema,
          GetAddressesAddressDeploymentsSkipLimitParameters,
          GetAddressesAddressDeploymentsSkipLimitData,
          GetAddressesAddressDeploymentsSkipLimitError
        >
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetAddressesAddressDeploymentsSkipLimitData, GetAddressesAddressDeploymentsSkipLimitError>>
    >(options: {
      queries: T;
      combine?: (
        results: Array<WithOptional<UseSuspenseQueryResult<GetAddressesAddressDeploymentsSkipLimitData, GetAddressesAddressDeploymentsSkipLimitError>, "data">>
      ) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get a list of deployments by owner address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getAddressesAddressDeploymentsSkipLimit.useSuspenseQuery({
     *     path: {
     *         address: address,
     *         limit: limit
     *     },
     *     query: {
     *         status: status
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetAddressesAddressDeploymentsSkipLimitData>(
      parameters:
        | ServiceOperationQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>
        | DeepReadonly<GetAddressesAddressDeploymentsSkipLimitParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<
          GetAddressesAddressDeploymentsSkipLimitData,
          GetAddressesAddressDeploymentsSkipLimitError,
          TData,
          ServiceOperationQueryKey<GetAddressesAddressDeploymentsSkipLimitSchema, GetAddressesAddressDeploymentsSkipLimitParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetAddressesAddressDeploymentsSkipLimitError | Error>;
    schema: GetAddressesAddressDeploymentsSkipLimitSchema;
    types: {
      parameters: GetAddressesAddressDeploymentsSkipLimitParameters;
      data: GetAddressesAddressDeploymentsSkipLimitData;
      error: GetAddressesAddressDeploymentsSkipLimitError;
    };
  };
  /** @summary Get deployment details */
  getDeploymentOwnerDseq: {
    /** @summary Get deployment details */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetDeploymentOwnerDseqSchema,
            GetDeploymentOwnerDseqData,
            TInfinite,
            GetDeploymentOwnerDseqParameters,
            GetDeploymentOwnerDseqError
          >
        | QueryFiltersByQueryKey<
            GetDeploymentOwnerDseqSchema,
            GetDeploymentOwnerDseqData,
            TInfinite,
            GetDeploymentOwnerDseqParameters,
            GetDeploymentOwnerDseqError
          >,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get deployment details */
    getQueryKey(
      parameters: DeepReadonly<GetDeploymentOwnerDseqParameters>
    ): ServiceOperationQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get deployment details
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeploymentOwnerDseq.useQuery({
     *     path: {
     *         owner: owner,
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useQuery<TData = GetDeploymentOwnerDseqData>(
      parameters: ServiceOperationQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters> | DeepReadonly<GetDeploymentOwnerDseqParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetDeploymentOwnerDseqData,
          GetDeploymentOwnerDseqError,
          TData,
          ServiceOperationQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetDeploymentOwnerDseqError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get deployment details
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeploymentOwnerDseq.useQuery({
     *     path: {
     *         owner: owner,
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useQuery<TData = GetDeploymentOwnerDseqData>(
      parameters: ServiceOperationQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters> | DeepReadonly<GetDeploymentOwnerDseqParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetDeploymentOwnerDseqData,
          GetDeploymentOwnerDseqError,
          TData,
          ServiceOperationQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetDeploymentOwnerDseqError | Error>;
    /** @summary Get deployment details */
    fetchInfiniteQuery<TPageParam extends GetDeploymentOwnerDseqParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetDeploymentOwnerDseqSchema,
        GetDeploymentOwnerDseqData,
        GetDeploymentOwnerDseqParameters,
        DeepReadonly<TPageParam>,
        GetDeploymentOwnerDseqError
      >
    ): Promise<OperationInfiniteData<GetDeploymentOwnerDseqData, GetDeploymentOwnerDseqParameters>>;
    /** @summary Get deployment details */
    prefetchInfiniteQuery<TPageParam extends GetDeploymentOwnerDseqParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetDeploymentOwnerDseqSchema,
        GetDeploymentOwnerDseqData,
        GetDeploymentOwnerDseqParameters,
        DeepReadonly<TPageParam>,
        GetDeploymentOwnerDseqError
      >
    ): Promise<void>;
    /** @summary Get deployment details */
    ensureInfiniteQueryData<TPageParam extends GetDeploymentOwnerDseqParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetDeploymentOwnerDseqSchema,
        GetDeploymentOwnerDseqData,
        GetDeploymentOwnerDseqParameters,
        DeepReadonly<TPageParam>,
        GetDeploymentOwnerDseqError
      >
    ): Promise<OperationInfiniteData<GetDeploymentOwnerDseqData, GetDeploymentOwnerDseqParameters>>;
    /** @summary Get deployment details */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetDeploymentOwnerDseqSchema,
        GetDeploymentOwnerDseqData,
        GetDeploymentOwnerDseqParameters,
        GetDeploymentOwnerDseqError
      >
    ): Promise<GetDeploymentOwnerDseqData>;
    /** @summary Get deployment details */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetDeploymentOwnerDseqSchema,
        GetDeploymentOwnerDseqData,
        GetDeploymentOwnerDseqParameters,
        GetDeploymentOwnerDseqError
      >
    ): Promise<void>;
    /** @summary Get deployment details */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetDeploymentOwnerDseqSchema,
        GetDeploymentOwnerDseqData,
        GetDeploymentOwnerDseqParameters,
        GetDeploymentOwnerDseqError
      >
    ): Promise<GetDeploymentOwnerDseqData>;
    /** @summary Get deployment details */
    getInfiniteQueryData(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters>
        | DeepReadonly<GetDeploymentOwnerDseqParameters>
    ): OperationInfiniteData<GetDeploymentOwnerDseqData, GetDeploymentOwnerDseqParameters> | undefined;
    /** @summary Get deployment details */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetDeploymentOwnerDseqSchema,
            GetDeploymentOwnerDseqData,
            TInfinite,
            GetDeploymentOwnerDseqParameters,
            GetDeploymentOwnerDseqError
          >
        | QueryFiltersByQueryKey<
            GetDeploymentOwnerDseqSchema,
            GetDeploymentOwnerDseqData,
            TInfinite,
            GetDeploymentOwnerDseqParameters,
            GetDeploymentOwnerDseqError
          >
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters>,
            data: NoInfer<OperationInfiniteData<GetDeploymentOwnerDseqData, GetDeploymentOwnerDseqParameters>> | undefined
          ]
        >
      : Array<
          [queryKey: ServiceOperationQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters>, data: GetDeploymentOwnerDseqData | undefined]
        >;
    /** @summary Get deployment details */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters> | DeepReadonly<GetDeploymentOwnerDseqParameters>
    ): GetDeploymentOwnerDseqData | undefined;
    /** @summary Get deployment details */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters> | DeepReadonly<GetDeploymentOwnerDseqParameters>
    ): QueryState<GetDeploymentOwnerDseqData, GetDeploymentOwnerDseqError> | undefined;
    /** @summary Get deployment details */
    getInfiniteQueryState(
      parameters:
        | DeepReadonly<GetDeploymentOwnerDseqParameters>
        | ServiceOperationInfiniteQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters>
    ): QueryState<OperationInfiniteData<GetDeploymentOwnerDseqData, GetDeploymentOwnerDseqParameters>, GetDeploymentOwnerDseqError> | undefined;
    /** @summary Get deployment details */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<
        GetDeploymentOwnerDseqSchema,
        GetDeploymentOwnerDseqData,
        TInfinite,
        GetDeploymentOwnerDseqParameters,
        GetDeploymentOwnerDseqError
      >,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get deployment details */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetDeploymentOwnerDseqSchema,
            GetDeploymentOwnerDseqData,
            TInfinite,
            GetDeploymentOwnerDseqParameters,
            GetDeploymentOwnerDseqError
          >
        | QueryFiltersByQueryKey<
            GetDeploymentOwnerDseqSchema,
            GetDeploymentOwnerDseqData,
            TInfinite,
            GetDeploymentOwnerDseqParameters,
            GetDeploymentOwnerDseqError
          >
    ): number;
    /** @summary Get deployment details */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetDeploymentOwnerDseqParameters, TMeta, TSignal>,
      client?: (
        schema: GetDeploymentOwnerDseqSchema,
        options: {
          parameters: GetDeploymentOwnerDseqParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetDeploymentOwnerDseqData, GetDeploymentOwnerDseqError>>
    ): Promise<RequestFnResponse<GetDeploymentOwnerDseqData, GetDeploymentOwnerDseqError>>;
    /** @summary Get deployment details */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetDeploymentOwnerDseqSchema,
            GetDeploymentOwnerDseqData,
            TInfinite,
            GetDeploymentOwnerDseqParameters,
            GetDeploymentOwnerDseqError
          >
        | QueryFiltersByQueryKey<
            GetDeploymentOwnerDseqSchema,
            GetDeploymentOwnerDseqData,
            TInfinite,
            GetDeploymentOwnerDseqParameters,
            GetDeploymentOwnerDseqError
          >,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get deployment details */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetDeploymentOwnerDseqSchema,
            GetDeploymentOwnerDseqData,
            TInfinite,
            GetDeploymentOwnerDseqParameters,
            GetDeploymentOwnerDseqError
          >
        | QueryFiltersByQueryKey<
            GetDeploymentOwnerDseqSchema,
            GetDeploymentOwnerDseqData,
            TInfinite,
            GetDeploymentOwnerDseqParameters,
            GetDeploymentOwnerDseqError
          >
    ): void;
    /** @summary Get deployment details */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetDeploymentOwnerDseqSchema,
            GetDeploymentOwnerDseqData,
            TInfinite,
            GetDeploymentOwnerDseqParameters,
            GetDeploymentOwnerDseqError
          >
        | QueryFiltersByQueryKey<
            GetDeploymentOwnerDseqSchema,
            GetDeploymentOwnerDseqData,
            TInfinite,
            GetDeploymentOwnerDseqParameters,
            GetDeploymentOwnerDseqError
          >,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get deployment details */
    setInfiniteQueryData(
      parameters:
        | DeepReadonly<GetDeploymentOwnerDseqParameters>
        | ServiceOperationInfiniteQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetDeploymentOwnerDseqData, GetDeploymentOwnerDseqParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetDeploymentOwnerDseqData, GetDeploymentOwnerDseqParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetDeploymentOwnerDseqData, GetDeploymentOwnerDseqParameters> | undefined;
    /** @summary Get deployment details */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<
            GetDeploymentOwnerDseqSchema,
            GetDeploymentOwnerDseqData,
            TInfinite,
            GetDeploymentOwnerDseqParameters,
            GetDeploymentOwnerDseqError
          >
        | QueryFiltersByQueryKey<
            GetDeploymentOwnerDseqSchema,
            GetDeploymentOwnerDseqData,
            TInfinite,
            GetDeploymentOwnerDseqParameters,
            GetDeploymentOwnerDseqError
          >,
      updater: Updater<NoInfer<GetDeploymentOwnerDseqData> | undefined, NoInfer<GetDeploymentOwnerDseqData> | undefined>,
      options?: SetDataOptions
    ): Array<GetDeploymentOwnerDseqData | undefined>;
    /** @summary Get deployment details */
    setQueryData(
      parameters: DeepReadonly<GetDeploymentOwnerDseqParameters> | ServiceOperationQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters>,
      updater: Updater<NoInfer<GetDeploymentOwnerDseqData> | undefined, NoInfer<DeepReadonly<GetDeploymentOwnerDseqData>> | undefined>,
      options?: SetDataOptions
    ): GetDeploymentOwnerDseqData | undefined;
    /** @summary Get deployment details */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetDeploymentOwnerDseqParameters>
    ): ServiceOperationInfiniteQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get deployment details
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getDeploymentOwnerDseq.useInfiniteQuery({
     *     path: {
     *         owner: owner,
     *         dseq: dseq
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetDeploymentOwnerDseqParameters,
      TQueryFnData = GetDeploymentOwnerDseqData,
      TData = OperationInfiniteData<TQueryFnData, GetDeploymentOwnerDseqParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters>
        | DeepReadonly<GetDeploymentOwnerDseqParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetDeploymentOwnerDseqError,
          TData,
          ServiceOperationInfiniteQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetDeploymentOwnerDseqError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get deployment details
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getDeploymentOwnerDseq.useInfiniteQuery({
     *     path: {
     *         owner: owner,
     *         dseq: dseq
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetDeploymentOwnerDseqParameters,
      TQueryFnData = GetDeploymentOwnerDseqData,
      TData = OperationInfiniteData<TQueryFnData, GetDeploymentOwnerDseqParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters>
        | DeepReadonly<GetDeploymentOwnerDseqParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetDeploymentOwnerDseqError,
          TData,
          ServiceOperationInfiniteQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetDeploymentOwnerDseqData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetDeploymentOwnerDseqError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get deployment details
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getDeploymentOwnerDseqTotal = qraft.v1Service.getDeploymentOwnerDseq.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getDeploymentOwnerDseqByParametersTotal = qraft.v1Service.getDeploymentOwnerDseq.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             owner: owner,
     *             dseq: dseq
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetDeploymentOwnerDseqSchema,
            GetDeploymentOwnerDseqData,
            TInfinite,
            GetDeploymentOwnerDseqParameters,
            GetDeploymentOwnerDseqError
          >
        | QueryFiltersByQueryKey<
            GetDeploymentOwnerDseqSchema,
            GetDeploymentOwnerDseqData,
            TInfinite,
            GetDeploymentOwnerDseqParameters,
            GetDeploymentOwnerDseqError
          >
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get deployment details
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getDeploymentOwnerDseqResults = qraft.v1Service.getDeploymentOwnerDseq.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 owner: owner1,
     *                 dseq: dseq1
     *             }
     *         },
     *         {
     *             path: {
     *                 owner: owner2,
     *                 dseq: dseq2
     *             }
     *         }
     *     ]
     * });
     * getDeploymentOwnerDseqResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getDeploymentOwnerDseqCombinedResults = qraft.v1Service.getDeploymentOwnerDseq.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 owner: owner1,
     *                 dseq: dseq1
     *             }
     *         },
     *         {
     *             path: {
     *                 owner: owner2,
     *                 dseq: dseq2
     *             }
     *         }
     *     ]
     * });
     * getDeploymentOwnerDseqCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters, GetDeploymentOwnerDseqData, GetDeploymentOwnerDseqError>
      >,
      TCombinedResult = Array<UseQueryResult<GetDeploymentOwnerDseqData, GetDeploymentOwnerDseqError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetDeploymentOwnerDseqData, GetDeploymentOwnerDseqError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get deployment details */
    getQueryKey(
      parameters: DeepReadonly<GetDeploymentOwnerDseqParameters>
    ): ServiceOperationQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get deployment details
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeploymentOwnerDseq.useQuery({
     *     path: {
     *         owner: owner,
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useQuery<TData = GetDeploymentOwnerDseqData>(
      parameters: ServiceOperationQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters> | DeepReadonly<GetDeploymentOwnerDseqParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetDeploymentOwnerDseqData,
          GetDeploymentOwnerDseqError,
          TData,
          ServiceOperationQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetDeploymentOwnerDseqError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get deployment details
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeploymentOwnerDseq.useQuery({
     *     path: {
     *         owner: owner,
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useQuery<TData = GetDeploymentOwnerDseqData>(
      parameters: ServiceOperationQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters> | DeepReadonly<GetDeploymentOwnerDseqParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetDeploymentOwnerDseqData,
          GetDeploymentOwnerDseqError,
          TData,
          ServiceOperationQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetDeploymentOwnerDseqError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get deployment details
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getDeploymentOwnerDseq.useSuspenseInfiniteQuery({
     *     path: {
     *         owner: owner,
     *         dseq: dseq
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetDeploymentOwnerDseqParameters, TData = GetDeploymentOwnerDseqData>(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters>
        | DeepReadonly<GetDeploymentOwnerDseqParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetDeploymentOwnerDseqData,
          GetDeploymentOwnerDseqError,
          OperationInfiniteData<TData, GetDeploymentOwnerDseqParameters>,
          GetDeploymentOwnerDseqData,
          ServiceOperationInfiniteQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetDeploymentOwnerDseqData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetDeploymentOwnerDseqParameters>, GetDeploymentOwnerDseqError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get deployment details
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getDeploymentOwnerDseqData = qraft.v1Service.getDeploymentOwnerDseq.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 owner: owner1,
     *                 dseq: dseq1
     *             }
     *         },
     *         {
     *             path: {
     *                 owner: owner2,
     *                 dseq: dseq2
     *             }
     *         }
     *     ]
     * });
     * getDeploymentOwnerDseqResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getDeploymentOwnerDseqCombinedData = qraft.v1Service.getDeploymentOwnerDseq.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 owner: owner1,
     *                 dseq: dseq1
     *             }
     *         },
     *         {
     *             path: {
     *                 owner: owner2,
     *                 dseq: dseq2
     *             }
     *         }
     *     ]
     * });
     * getDeploymentOwnerDseqCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<
          GetDeploymentOwnerDseqSchema,
          GetDeploymentOwnerDseqParameters,
          GetDeploymentOwnerDseqData,
          GetDeploymentOwnerDseqError
        >
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetDeploymentOwnerDseqData, GetDeploymentOwnerDseqError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetDeploymentOwnerDseqData, GetDeploymentOwnerDseqError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get deployment details
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getDeploymentOwnerDseq.useSuspenseQuery({
     *     path: {
     *         owner: owner,
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetDeploymentOwnerDseqData>(
      parameters: ServiceOperationQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters> | DeepReadonly<GetDeploymentOwnerDseqParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<
          GetDeploymentOwnerDseqData,
          GetDeploymentOwnerDseqError,
          TData,
          ServiceOperationQueryKey<GetDeploymentOwnerDseqSchema, GetDeploymentOwnerDseqParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetDeploymentOwnerDseqError | Error>;
    schema: GetDeploymentOwnerDseqSchema;
    types: {
      parameters: GetDeploymentOwnerDseqParameters;
      data: GetDeploymentOwnerDseqData;
      error: GetDeploymentOwnerDseqError;
    };
  };
  /** @summary Get weekly deployment cost */
  getWeeklyCost: {
    /** @summary Get weekly deployment cost */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetWeeklyCostSchema, GetWeeklyCostData, TInfinite, GetWeeklyCostParameters, GetWeeklyCostError>
        | QueryFiltersByQueryKey<GetWeeklyCostSchema, GetWeeklyCostData, TInfinite, GetWeeklyCostParameters, GetWeeklyCostError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get weekly deployment cost */
    getQueryKey(parameters: DeepReadonly<GetWeeklyCostParameters> | void): ServiceOperationQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get weekly deployment cost
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getWeeklyCost.useQuery()
     * ```
     */
    useQuery<TData = GetWeeklyCostData>(
      parameters: ServiceOperationQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters> | (DeepReadonly<GetWeeklyCostParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetWeeklyCostData, GetWeeklyCostError, TData, ServiceOperationQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetWeeklyCostError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get weekly deployment cost
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getWeeklyCost.useQuery()
     * ```
     */
    useQuery<TData = GetWeeklyCostData>(
      parameters: ServiceOperationQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters> | (DeepReadonly<GetWeeklyCostParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetWeeklyCostData, GetWeeklyCostError, TData, ServiceOperationQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetWeeklyCostError | Error>;
    /** @summary Get weekly deployment cost */
    fetchInfiniteQuery<TPageParam extends GetWeeklyCostParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetWeeklyCostSchema,
        GetWeeklyCostData,
        GetWeeklyCostParameters,
        DeepReadonly<TPageParam>,
        GetWeeklyCostError
      > | void
    ): Promise<OperationInfiniteData<GetWeeklyCostData, GetWeeklyCostParameters>>;
    /** @summary Get weekly deployment cost */
    prefetchInfiniteQuery<TPageParam extends GetWeeklyCostParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetWeeklyCostSchema,
        GetWeeklyCostData,
        GetWeeklyCostParameters,
        DeepReadonly<TPageParam>,
        GetWeeklyCostError
      > | void
    ): Promise<void>;
    /** @summary Get weekly deployment cost */
    ensureInfiniteQueryData<TPageParam extends GetWeeklyCostParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetWeeklyCostSchema,
        GetWeeklyCostData,
        GetWeeklyCostParameters,
        DeepReadonly<TPageParam>,
        GetWeeklyCostError
      > | void
    ): Promise<OperationInfiniteData<GetWeeklyCostData, GetWeeklyCostParameters>>;
    /** @summary Get weekly deployment cost */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetWeeklyCostSchema, GetWeeklyCostData, GetWeeklyCostParameters, GetWeeklyCostError> | void
    ): Promise<GetWeeklyCostData>;
    /** @summary Get weekly deployment cost */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetWeeklyCostSchema, GetWeeklyCostData, GetWeeklyCostParameters, GetWeeklyCostError> | void
    ): Promise<void>;
    /** @summary Get weekly deployment cost */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetWeeklyCostSchema, GetWeeklyCostData, GetWeeklyCostParameters, GetWeeklyCostError> | void
    ): Promise<GetWeeklyCostData>;
    /** @summary Get weekly deployment cost */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters> | (DeepReadonly<GetWeeklyCostParameters> | void)
    ): OperationInfiniteData<GetWeeklyCostData, GetWeeklyCostParameters> | undefined;
    /** @summary Get weekly deployment cost */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetWeeklyCostSchema, GetWeeklyCostData, TInfinite, GetWeeklyCostParameters, GetWeeklyCostError>
        | QueryFiltersByQueryKey<GetWeeklyCostSchema, GetWeeklyCostData, TInfinite, GetWeeklyCostParameters, GetWeeklyCostError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters>,
            data: NoInfer<OperationInfiniteData<GetWeeklyCostData, GetWeeklyCostParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters>, data: GetWeeklyCostData | undefined]>;
    /** @summary Get weekly deployment cost */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters> | (DeepReadonly<GetWeeklyCostParameters> | void)
    ): GetWeeklyCostData | undefined;
    /** @summary Get weekly deployment cost */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters> | (DeepReadonly<GetWeeklyCostParameters> | void)
    ): QueryState<GetWeeklyCostData, GetWeeklyCostError> | undefined;
    /** @summary Get weekly deployment cost */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetWeeklyCostParameters> | ServiceOperationInfiniteQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters> | void
    ): QueryState<OperationInfiniteData<GetWeeklyCostData, GetWeeklyCostParameters>, GetWeeklyCostError> | undefined;
    /** @summary Get weekly deployment cost */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetWeeklyCostSchema, GetWeeklyCostData, TInfinite, GetWeeklyCostParameters, GetWeeklyCostError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get weekly deployment cost */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetWeeklyCostSchema, GetWeeklyCostData, TInfinite, GetWeeklyCostParameters, GetWeeklyCostError>
        | QueryFiltersByQueryKey<GetWeeklyCostSchema, GetWeeklyCostData, TInfinite, GetWeeklyCostParameters, GetWeeklyCostError>
    ): number;
    /** @summary Get weekly deployment cost */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetWeeklyCostParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetWeeklyCostSchema,
        options: {
          parameters: GetWeeklyCostParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetWeeklyCostData, GetWeeklyCostError>>
    ): Promise<RequestFnResponse<GetWeeklyCostData, GetWeeklyCostError>>;
    /** @summary Get weekly deployment cost */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetWeeklyCostSchema, GetWeeklyCostData, TInfinite, GetWeeklyCostParameters, GetWeeklyCostError>
        | QueryFiltersByQueryKey<GetWeeklyCostSchema, GetWeeklyCostData, TInfinite, GetWeeklyCostParameters, GetWeeklyCostError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get weekly deployment cost */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetWeeklyCostSchema, GetWeeklyCostData, TInfinite, GetWeeklyCostParameters, GetWeeklyCostError>
        | QueryFiltersByQueryKey<GetWeeklyCostSchema, GetWeeklyCostData, TInfinite, GetWeeklyCostParameters, GetWeeklyCostError>
    ): void;
    /** @summary Get weekly deployment cost */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetWeeklyCostSchema, GetWeeklyCostData, TInfinite, GetWeeklyCostParameters, GetWeeklyCostError>
        | QueryFiltersByQueryKey<GetWeeklyCostSchema, GetWeeklyCostData, TInfinite, GetWeeklyCostParameters, GetWeeklyCostError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get weekly deployment cost */
    setInfiniteQueryData(
      parameters: (DeepReadonly<GetWeeklyCostParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetWeeklyCostData, GetWeeklyCostParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetWeeklyCostData, GetWeeklyCostParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetWeeklyCostData, GetWeeklyCostParameters> | undefined;
    /** @summary Get weekly deployment cost */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetWeeklyCostSchema, GetWeeklyCostData, TInfinite, GetWeeklyCostParameters, GetWeeklyCostError>
        | QueryFiltersByQueryKey<GetWeeklyCostSchema, GetWeeklyCostData, TInfinite, GetWeeklyCostParameters, GetWeeklyCostError>,
      updater: Updater<NoInfer<GetWeeklyCostData> | undefined, NoInfer<GetWeeklyCostData> | undefined>,
      options?: SetDataOptions
    ): Array<GetWeeklyCostData | undefined>;
    /** @summary Get weekly deployment cost */
    setQueryData(
      parameters: (DeepReadonly<GetWeeklyCostParameters> | undefined) | ServiceOperationQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters>,
      updater: Updater<NoInfer<GetWeeklyCostData> | undefined, NoInfer<DeepReadonly<GetWeeklyCostData>> | undefined>,
      options?: SetDataOptions
    ): GetWeeklyCostData | undefined;
    /** @summary Get weekly deployment cost */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetWeeklyCostParameters> | void
    ): ServiceOperationInfiniteQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get weekly deployment cost
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getWeeklyCost.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetWeeklyCostParameters,
      TQueryFnData = GetWeeklyCostData,
      TData = OperationInfiniteData<TQueryFnData, GetWeeklyCostParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters> | (DeepReadonly<GetWeeklyCostParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetWeeklyCostError,
          TData,
          ServiceOperationInfiniteQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetWeeklyCostError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get weekly deployment cost
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getWeeklyCost.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetWeeklyCostParameters,
      TQueryFnData = GetWeeklyCostData,
      TData = OperationInfiniteData<TQueryFnData, GetWeeklyCostParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters> | (DeepReadonly<GetWeeklyCostParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetWeeklyCostError,
          TData,
          ServiceOperationInfiniteQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetWeeklyCostData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetWeeklyCostError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get weekly deployment cost
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getWeeklyCostTotal = qraft.v1Service.getWeeklyCost.useIsFetching()
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetWeeklyCostSchema, GetWeeklyCostData, TInfinite, GetWeeklyCostParameters, GetWeeklyCostError>
        | QueryFiltersByQueryKey<GetWeeklyCostSchema, GetWeeklyCostData, TInfinite, GetWeeklyCostParameters, GetWeeklyCostError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get weekly deployment cost
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getWeeklyCostResults = qraft.v1Service.getWeeklyCost.useQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getWeeklyCostResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getWeeklyCostCombinedResults = qraft.v1Service.getWeeklyCost.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getWeeklyCostCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetWeeklyCostSchema, GetWeeklyCostParameters, GetWeeklyCostData, GetWeeklyCostError>>,
      TCombinedResult = Array<UseQueryResult<GetWeeklyCostData, GetWeeklyCostError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetWeeklyCostData, GetWeeklyCostError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get weekly deployment cost */
    getQueryKey(parameters: DeepReadonly<GetWeeklyCostParameters> | void): ServiceOperationQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get weekly deployment cost
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getWeeklyCost.useQuery()
     * ```
     */
    useQuery<TData = GetWeeklyCostData>(
      parameters: ServiceOperationQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters> | (DeepReadonly<GetWeeklyCostParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetWeeklyCostData, GetWeeklyCostError, TData, ServiceOperationQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetWeeklyCostError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get weekly deployment cost
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getWeeklyCost.useQuery()
     * ```
     */
    useQuery<TData = GetWeeklyCostData>(
      parameters: ServiceOperationQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters> | (DeepReadonly<GetWeeklyCostParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetWeeklyCostData, GetWeeklyCostError, TData, ServiceOperationQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetWeeklyCostError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get weekly deployment cost
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getWeeklyCost.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetWeeklyCostParameters, TData = GetWeeklyCostData>(
      parameters: ServiceOperationInfiniteQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters> | (DeepReadonly<GetWeeklyCostParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetWeeklyCostData,
          GetWeeklyCostError,
          OperationInfiniteData<TData, GetWeeklyCostParameters>,
          GetWeeklyCostData,
          ServiceOperationInfiniteQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetWeeklyCostData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetWeeklyCostParameters>, GetWeeklyCostError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get weekly deployment cost
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getWeeklyCostData = qraft.v1Service.getWeeklyCost.useSuspenseQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getWeeklyCostResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getWeeklyCostCombinedData = qraft.v1Service.getWeeklyCost.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getWeeklyCostCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetWeeklyCostSchema, GetWeeklyCostParameters, GetWeeklyCostData, GetWeeklyCostError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetWeeklyCostData, GetWeeklyCostError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetWeeklyCostData, GetWeeklyCostError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get weekly deployment cost
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getWeeklyCost.useSuspenseQuery()
     * ```
     */
    useSuspenseQuery<TData = GetWeeklyCostData>(
      parameters: ServiceOperationQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters> | (DeepReadonly<GetWeeklyCostParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<GetWeeklyCostData, GetWeeklyCostError, TData, ServiceOperationQueryKey<GetWeeklyCostSchema, GetWeeklyCostParameters>>,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetWeeklyCostError | Error>;
    schema: GetWeeklyCostSchema;
    types: {
      parameters: GetWeeklyCostParameters;
      data: GetWeeklyCostData;
      error: GetWeeklyCostError;
    };
  };
  /** @summary Create leases and send manifest */
  postLeases: {
    /** @summary Create leases and send manifest */
    getMutationKey(parameters: DeepReadonly<PostLeasesParameters> | void): ServiceOperationMutationKey<PostLeasesSchema, PostLeasesParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Create leases and send manifest
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postLeases.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postLeases.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends PostLeasesBody, TContext = unknown>(
      parameters: DeepReadonly<PostLeasesParameters>,
      options?: ServiceOperationUseMutationOptions<PostLeasesSchema, PostLeasesData, PostLeasesParameters, TVariables, PostLeasesError | Error, TContext>
    ): UseMutationResult<PostLeasesData, PostLeasesError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Create leases and send manifest
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postLeases.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postLeases.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PostLeasesBody, PostLeasesParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<PostLeasesSchema, PostLeasesData, PostLeasesParameters, TVariables, PostLeasesError | Error, TContext>
    ): UseMutationResult<PostLeasesData, PostLeasesError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Create leases and send manifest
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const postLeasesTotal = qraft.v1Service.postLeases.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const postLeasesTotal = qraft.v1Service.postLeases.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<PostLeasesBody, PostLeasesData, PostLeasesParameters, PostLeasesError | Error, TContext>
        | MutationFiltersByMutationKey<PostLeasesSchema, PostLeasesBody, PostLeasesData, PostLeasesParameters, PostLeasesError | Error, TContext>
    ): number;
    /** @summary Create leases and send manifest */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<PostLeasesBody, PostLeasesData, PostLeasesParameters, PostLeasesError | Error, TContext>
        | MutationFiltersByMutationKey<PostLeasesSchema, PostLeasesBody, PostLeasesData, PostLeasesParameters, PostLeasesError | Error, TContext>
    ): number;
    /** @summary Create leases and send manifest */
    (
      options: ServiceOperationMutationFnOptions<PostLeasesBody, PostLeasesParameters>,
      client?: (
        schema: PostLeasesSchema,
        options: ServiceOperationMutationFnOptions<PostLeasesBody, PostLeasesParameters>
      ) => Promise<RequestFnResponse<PostLeasesData, PostLeasesError>>
    ): Promise<RequestFnResponse<PostLeasesData, PostLeasesError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Create leases and send manifest
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const postLeasesPendingMutationVariables = qraft.v1Service.postLeases.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const postLeasesMutationData = qraft.v1Service.postLeases.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<PostLeasesData, PostLeasesError | Error, MutationVariables<PostLeasesBody, PostLeasesParameters>, TContext>
    >(options?: {
      filters?:
        | MutationFiltersByParameters<PostLeasesBody, PostLeasesData, PostLeasesParameters, PostLeasesError | Error, TContext>
        | MutationFiltersByMutationKey<PostLeasesSchema, PostLeasesBody, PostLeasesData, PostLeasesParameters, PostLeasesError | Error, TContext>;
      select?: (mutation: Mutation<PostLeasesData, PostLeasesError | Error, MutationVariables<PostLeasesBody, PostLeasesParameters>, TContext>) => TResult;
    }): Array<TResult>;
    schema: PostLeasesSchema;
    types: {
      parameters: PostLeasesParameters;
      data: PostLeasesData;
      error: PostLeasesError;
      body: PostLeasesBody;
    };
  };
  /** @summary List all API keys */
  getApiKeys: {
    /** @summary List all API keys */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetApiKeysSchema, GetApiKeysData, TInfinite, GetApiKeysParameters, GetApiKeysError>
        | QueryFiltersByQueryKey<GetApiKeysSchema, GetApiKeysData, TInfinite, GetApiKeysParameters, GetApiKeysError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary List all API keys */
    getQueryKey(parameters: DeepReadonly<GetApiKeysParameters> | void): ServiceOperationQueryKey<GetApiKeysSchema, GetApiKeysParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary List all API keys
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getApiKeys.useQuery()
     * ```
     */
    useQuery<TData = GetApiKeysData>(
      parameters: ServiceOperationQueryKey<GetApiKeysSchema, GetApiKeysParameters> | (DeepReadonly<GetApiKeysParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetApiKeysData, GetApiKeysError, TData, ServiceOperationQueryKey<GetApiKeysSchema, GetApiKeysParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetApiKeysError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary List all API keys
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getApiKeys.useQuery()
     * ```
     */
    useQuery<TData = GetApiKeysData>(
      parameters: ServiceOperationQueryKey<GetApiKeysSchema, GetApiKeysParameters> | (DeepReadonly<GetApiKeysParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetApiKeysData, GetApiKeysError, TData, ServiceOperationQueryKey<GetApiKeysSchema, GetApiKeysParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetApiKeysError | Error>;
    /** @summary List all API keys */
    fetchInfiniteQuery<TPageParam extends GetApiKeysParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetApiKeysSchema,
        GetApiKeysData,
        GetApiKeysParameters,
        DeepReadonly<TPageParam>,
        GetApiKeysError
      > | void
    ): Promise<OperationInfiniteData<GetApiKeysData, GetApiKeysParameters>>;
    /** @summary List all API keys */
    prefetchInfiniteQuery<TPageParam extends GetApiKeysParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetApiKeysSchema,
        GetApiKeysData,
        GetApiKeysParameters,
        DeepReadonly<TPageParam>,
        GetApiKeysError
      > | void
    ): Promise<void>;
    /** @summary List all API keys */
    ensureInfiniteQueryData<TPageParam extends GetApiKeysParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetApiKeysSchema,
        GetApiKeysData,
        GetApiKeysParameters,
        DeepReadonly<TPageParam>,
        GetApiKeysError
      > | void
    ): Promise<OperationInfiniteData<GetApiKeysData, GetApiKeysParameters>>;
    /** @summary List all API keys */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetApiKeysSchema, GetApiKeysData, GetApiKeysParameters, GetApiKeysError> | void
    ): Promise<GetApiKeysData>;
    /** @summary List all API keys */
    prefetchQuery(options: ServiceOperationFetchQueryOptions<GetApiKeysSchema, GetApiKeysData, GetApiKeysParameters, GetApiKeysError> | void): Promise<void>;
    /** @summary List all API keys */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetApiKeysSchema, GetApiKeysData, GetApiKeysParameters, GetApiKeysError> | void
    ): Promise<GetApiKeysData>;
    /** @summary List all API keys */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetApiKeysSchema, GetApiKeysParameters> | (DeepReadonly<GetApiKeysParameters> | void)
    ): OperationInfiniteData<GetApiKeysData, GetApiKeysParameters> | undefined;
    /** @summary List all API keys */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetApiKeysSchema, GetApiKeysData, TInfinite, GetApiKeysParameters, GetApiKeysError>
        | QueryFiltersByQueryKey<GetApiKeysSchema, GetApiKeysData, TInfinite, GetApiKeysParameters, GetApiKeysError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetApiKeysSchema, GetApiKeysParameters>,
            data: NoInfer<OperationInfiniteData<GetApiKeysData, GetApiKeysParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetApiKeysSchema, GetApiKeysParameters>, data: GetApiKeysData | undefined]>;
    /** @summary List all API keys */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetApiKeysSchema, GetApiKeysParameters> | (DeepReadonly<GetApiKeysParameters> | void)
    ): GetApiKeysData | undefined;
    /** @summary List all API keys */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetApiKeysSchema, GetApiKeysParameters> | (DeepReadonly<GetApiKeysParameters> | void)
    ): QueryState<GetApiKeysData, GetApiKeysError> | undefined;
    /** @summary List all API keys */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetApiKeysParameters> | ServiceOperationInfiniteQueryKey<GetApiKeysSchema, GetApiKeysParameters> | void
    ): QueryState<OperationInfiniteData<GetApiKeysData, GetApiKeysParameters>, GetApiKeysError> | undefined;
    /** @summary List all API keys */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetApiKeysSchema, GetApiKeysData, TInfinite, GetApiKeysParameters, GetApiKeysError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary List all API keys */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetApiKeysSchema, GetApiKeysData, TInfinite, GetApiKeysParameters, GetApiKeysError>
        | QueryFiltersByQueryKey<GetApiKeysSchema, GetApiKeysData, TInfinite, GetApiKeysParameters, GetApiKeysError>
    ): number;
    /** @summary List all API keys */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetApiKeysSchema, GetApiKeysParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetApiKeysParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetApiKeysSchema,
        options: {
          parameters: GetApiKeysParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetApiKeysData, GetApiKeysError>>
    ): Promise<RequestFnResponse<GetApiKeysData, GetApiKeysError>>;
    /** @summary List all API keys */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetApiKeysSchema, GetApiKeysData, TInfinite, GetApiKeysParameters, GetApiKeysError>
        | QueryFiltersByQueryKey<GetApiKeysSchema, GetApiKeysData, TInfinite, GetApiKeysParameters, GetApiKeysError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary List all API keys */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetApiKeysSchema, GetApiKeysData, TInfinite, GetApiKeysParameters, GetApiKeysError>
        | QueryFiltersByQueryKey<GetApiKeysSchema, GetApiKeysData, TInfinite, GetApiKeysParameters, GetApiKeysError>
    ): void;
    /** @summary List all API keys */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetApiKeysSchema, GetApiKeysData, TInfinite, GetApiKeysParameters, GetApiKeysError>
        | QueryFiltersByQueryKey<GetApiKeysSchema, GetApiKeysData, TInfinite, GetApiKeysParameters, GetApiKeysError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary List all API keys */
    setInfiniteQueryData(
      parameters: (DeepReadonly<GetApiKeysParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetApiKeysSchema, GetApiKeysParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetApiKeysData, GetApiKeysParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetApiKeysData, GetApiKeysParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetApiKeysData, GetApiKeysParameters> | undefined;
    /** @summary List all API keys */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetApiKeysSchema, GetApiKeysData, TInfinite, GetApiKeysParameters, GetApiKeysError>
        | QueryFiltersByQueryKey<GetApiKeysSchema, GetApiKeysData, TInfinite, GetApiKeysParameters, GetApiKeysError>,
      updater: Updater<NoInfer<GetApiKeysData> | undefined, NoInfer<GetApiKeysData> | undefined>,
      options?: SetDataOptions
    ): Array<GetApiKeysData | undefined>;
    /** @summary List all API keys */
    setQueryData(
      parameters: (DeepReadonly<GetApiKeysParameters> | undefined) | ServiceOperationQueryKey<GetApiKeysSchema, GetApiKeysParameters>,
      updater: Updater<NoInfer<GetApiKeysData> | undefined, NoInfer<DeepReadonly<GetApiKeysData>> | undefined>,
      options?: SetDataOptions
    ): GetApiKeysData | undefined;
    /** @summary List all API keys */
    getInfiniteQueryKey(parameters: DeepReadonly<GetApiKeysParameters> | void): ServiceOperationInfiniteQueryKey<GetApiKeysSchema, GetApiKeysParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary List all API keys
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getApiKeys.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<TPageParam extends GetApiKeysParameters, TQueryFnData = GetApiKeysData, TData = OperationInfiniteData<TQueryFnData, GetApiKeysParameters>>(
      parameters: ServiceOperationInfiniteQueryKey<GetApiKeysSchema, GetApiKeysParameters> | (DeepReadonly<GetApiKeysParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetApiKeysError,
          TData,
          ServiceOperationInfiniteQueryKey<GetApiKeysSchema, GetApiKeysParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetApiKeysError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary List all API keys
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getApiKeys.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<TPageParam extends GetApiKeysParameters, TQueryFnData = GetApiKeysData, TData = OperationInfiniteData<TQueryFnData, GetApiKeysParameters>>(
      parameters: ServiceOperationInfiniteQueryKey<GetApiKeysSchema, GetApiKeysParameters> | (DeepReadonly<GetApiKeysParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetApiKeysError,
          TData,
          ServiceOperationInfiniteQueryKey<GetApiKeysSchema, GetApiKeysParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetApiKeysData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetApiKeysError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary List all API keys
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getApiKeysTotal = qraft.v1Service.getApiKeys.useIsFetching()
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetApiKeysSchema, GetApiKeysData, TInfinite, GetApiKeysParameters, GetApiKeysError>
        | QueryFiltersByQueryKey<GetApiKeysSchema, GetApiKeysData, TInfinite, GetApiKeysParameters, GetApiKeysError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary List all API keys
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getApiKeysResults = qraft.v1Service.getApiKeys.useQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getApiKeysResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getApiKeysCombinedResults = qraft.v1Service.getApiKeys.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getApiKeysCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetApiKeysSchema, GetApiKeysParameters, GetApiKeysData, GetApiKeysError>>,
      TCombinedResult = Array<UseQueryResult<GetApiKeysData, GetApiKeysError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetApiKeysData, GetApiKeysError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary List all API keys */
    getQueryKey(parameters: DeepReadonly<GetApiKeysParameters> | void): ServiceOperationQueryKey<GetApiKeysSchema, GetApiKeysParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary List all API keys
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getApiKeys.useQuery()
     * ```
     */
    useQuery<TData = GetApiKeysData>(
      parameters: ServiceOperationQueryKey<GetApiKeysSchema, GetApiKeysParameters> | (DeepReadonly<GetApiKeysParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetApiKeysData, GetApiKeysError, TData, ServiceOperationQueryKey<GetApiKeysSchema, GetApiKeysParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetApiKeysError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary List all API keys
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getApiKeys.useQuery()
     * ```
     */
    useQuery<TData = GetApiKeysData>(
      parameters: ServiceOperationQueryKey<GetApiKeysSchema, GetApiKeysParameters> | (DeepReadonly<GetApiKeysParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetApiKeysData, GetApiKeysError, TData, ServiceOperationQueryKey<GetApiKeysSchema, GetApiKeysParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetApiKeysError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary List all API keys
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getApiKeys.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetApiKeysParameters, TData = GetApiKeysData>(
      parameters: ServiceOperationInfiniteQueryKey<GetApiKeysSchema, GetApiKeysParameters> | (DeepReadonly<GetApiKeysParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetApiKeysData,
          GetApiKeysError,
          OperationInfiniteData<TData, GetApiKeysParameters>,
          GetApiKeysData,
          ServiceOperationInfiniteQueryKey<GetApiKeysSchema, GetApiKeysParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetApiKeysData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetApiKeysParameters>, GetApiKeysError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary List all API keys
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getApiKeysData = qraft.v1Service.getApiKeys.useSuspenseQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getApiKeysResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getApiKeysCombinedData = qraft.v1Service.getApiKeys.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getApiKeysCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetApiKeysSchema, GetApiKeysParameters, GetApiKeysData, GetApiKeysError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetApiKeysData, GetApiKeysError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetApiKeysData, GetApiKeysError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary List all API keys
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getApiKeys.useSuspenseQuery()
     * ```
     */
    useSuspenseQuery<TData = GetApiKeysData>(
      parameters: ServiceOperationQueryKey<GetApiKeysSchema, GetApiKeysParameters> | (DeepReadonly<GetApiKeysParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<GetApiKeysData, GetApiKeysError, TData, ServiceOperationQueryKey<GetApiKeysSchema, GetApiKeysParameters>>,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetApiKeysError | Error>;
    schema: GetApiKeysSchema;
    types: {
      parameters: GetApiKeysParameters;
      data: GetApiKeysData;
      error: GetApiKeysError;
    };
  };
  /** @summary Create new API key */
  postApiKeys: {
    /** @summary Create new API key */
    getMutationKey(parameters: DeepReadonly<PostApiKeysParameters> | void): ServiceOperationMutationKey<PostApiKeysSchema, PostApiKeysParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Create new API key
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postApiKeys.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postApiKeys.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends PostApiKeysBody, TContext = unknown>(
      parameters: DeepReadonly<PostApiKeysParameters>,
      options?: ServiceOperationUseMutationOptions<PostApiKeysSchema, PostApiKeysData, PostApiKeysParameters, TVariables, PostApiKeysError | Error, TContext>
    ): UseMutationResult<PostApiKeysData, PostApiKeysError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Create new API key
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postApiKeys.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postApiKeys.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PostApiKeysBody, PostApiKeysParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<PostApiKeysSchema, PostApiKeysData, PostApiKeysParameters, TVariables, PostApiKeysError | Error, TContext>
    ): UseMutationResult<PostApiKeysData, PostApiKeysError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Create new API key
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const postApiKeysTotal = qraft.v1Service.postApiKeys.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const postApiKeysTotal = qraft.v1Service.postApiKeys.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<PostApiKeysBody, PostApiKeysData, PostApiKeysParameters, PostApiKeysError | Error, TContext>
        | MutationFiltersByMutationKey<PostApiKeysSchema, PostApiKeysBody, PostApiKeysData, PostApiKeysParameters, PostApiKeysError | Error, TContext>
    ): number;
    /** @summary Create new API key */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<PostApiKeysBody, PostApiKeysData, PostApiKeysParameters, PostApiKeysError | Error, TContext>
        | MutationFiltersByMutationKey<PostApiKeysSchema, PostApiKeysBody, PostApiKeysData, PostApiKeysParameters, PostApiKeysError | Error, TContext>
    ): number;
    /** @summary Create new API key */
    (
      options: ServiceOperationMutationFnOptions<PostApiKeysBody, PostApiKeysParameters>,
      client?: (
        schema: PostApiKeysSchema,
        options: ServiceOperationMutationFnOptions<PostApiKeysBody, PostApiKeysParameters>
      ) => Promise<RequestFnResponse<PostApiKeysData, PostApiKeysError>>
    ): Promise<RequestFnResponse<PostApiKeysData, PostApiKeysError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Create new API key
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const postApiKeysPendingMutationVariables = qraft.v1Service.postApiKeys.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const postApiKeysMutationData = qraft.v1Service.postApiKeys.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<PostApiKeysData, PostApiKeysError | Error, MutationVariables<PostApiKeysBody, PostApiKeysParameters>, TContext>
    >(options?: {
      filters?:
        | MutationFiltersByParameters<PostApiKeysBody, PostApiKeysData, PostApiKeysParameters, PostApiKeysError | Error, TContext>
        | MutationFiltersByMutationKey<PostApiKeysSchema, PostApiKeysBody, PostApiKeysData, PostApiKeysParameters, PostApiKeysError | Error, TContext>;
      select?: (mutation: Mutation<PostApiKeysData, PostApiKeysError | Error, MutationVariables<PostApiKeysBody, PostApiKeysParameters>, TContext>) => TResult;
    }): Array<TResult>;
    schema: PostApiKeysSchema;
    types: {
      parameters: PostApiKeysParameters;
      data: PostApiKeysData;
      error: PostApiKeysError;
      body: PostApiKeysBody;
    };
  };
  /** @summary Get API key by ID */
  getApiKeysId: {
    /** @summary Get API key by ID */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetApiKeysIdSchema, GetApiKeysIdData, TInfinite, GetApiKeysIdParameters, GetApiKeysIdError>
        | QueryFiltersByQueryKey<GetApiKeysIdSchema, GetApiKeysIdData, TInfinite, GetApiKeysIdParameters, GetApiKeysIdError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get API key by ID */
    getQueryKey(parameters: DeepReadonly<GetApiKeysIdParameters>): ServiceOperationQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get API key by ID
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getApiKeysId.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetApiKeysIdData>(
      parameters: ServiceOperationQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters> | DeepReadonly<GetApiKeysIdParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<GetApiKeysIdData, GetApiKeysIdError, TData, ServiceOperationQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetApiKeysIdError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get API key by ID
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getApiKeysId.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetApiKeysIdData>(
      parameters: ServiceOperationQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters> | DeepReadonly<GetApiKeysIdParameters>,
      options: Omit<
        DefinedInitialDataOptions<GetApiKeysIdData, GetApiKeysIdError, TData, ServiceOperationQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetApiKeysIdError | Error>;
    /** @summary Get API key by ID */
    fetchInfiniteQuery<TPageParam extends GetApiKeysIdParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetApiKeysIdSchema,
        GetApiKeysIdData,
        GetApiKeysIdParameters,
        DeepReadonly<TPageParam>,
        GetApiKeysIdError
      >
    ): Promise<OperationInfiniteData<GetApiKeysIdData, GetApiKeysIdParameters>>;
    /** @summary Get API key by ID */
    prefetchInfiniteQuery<TPageParam extends GetApiKeysIdParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetApiKeysIdSchema,
        GetApiKeysIdData,
        GetApiKeysIdParameters,
        DeepReadonly<TPageParam>,
        GetApiKeysIdError
      >
    ): Promise<void>;
    /** @summary Get API key by ID */
    ensureInfiniteQueryData<TPageParam extends GetApiKeysIdParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetApiKeysIdSchema,
        GetApiKeysIdData,
        GetApiKeysIdParameters,
        DeepReadonly<TPageParam>,
        GetApiKeysIdError
      >
    ): Promise<OperationInfiniteData<GetApiKeysIdData, GetApiKeysIdParameters>>;
    /** @summary Get API key by ID */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetApiKeysIdSchema, GetApiKeysIdData, GetApiKeysIdParameters, GetApiKeysIdError>
    ): Promise<GetApiKeysIdData>;
    /** @summary Get API key by ID */
    prefetchQuery(options: ServiceOperationFetchQueryOptions<GetApiKeysIdSchema, GetApiKeysIdData, GetApiKeysIdParameters, GetApiKeysIdError>): Promise<void>;
    /** @summary Get API key by ID */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetApiKeysIdSchema, GetApiKeysIdData, GetApiKeysIdParameters, GetApiKeysIdError>
    ): Promise<GetApiKeysIdData>;
    /** @summary Get API key by ID */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters> | DeepReadonly<GetApiKeysIdParameters>
    ): OperationInfiniteData<GetApiKeysIdData, GetApiKeysIdParameters> | undefined;
    /** @summary Get API key by ID */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetApiKeysIdSchema, GetApiKeysIdData, TInfinite, GetApiKeysIdParameters, GetApiKeysIdError>
        | QueryFiltersByQueryKey<GetApiKeysIdSchema, GetApiKeysIdData, TInfinite, GetApiKeysIdParameters, GetApiKeysIdError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters>,
            data: NoInfer<OperationInfiniteData<GetApiKeysIdData, GetApiKeysIdParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters>, data: GetApiKeysIdData | undefined]>;
    /** @summary Get API key by ID */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters> | DeepReadonly<GetApiKeysIdParameters>
    ): GetApiKeysIdData | undefined;
    /** @summary Get API key by ID */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters> | DeepReadonly<GetApiKeysIdParameters>
    ): QueryState<GetApiKeysIdData, GetApiKeysIdError> | undefined;
    /** @summary Get API key by ID */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetApiKeysIdParameters> | ServiceOperationInfiniteQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters>
    ): QueryState<OperationInfiniteData<GetApiKeysIdData, GetApiKeysIdParameters>, GetApiKeysIdError> | undefined;
    /** @summary Get API key by ID */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetApiKeysIdSchema, GetApiKeysIdData, TInfinite, GetApiKeysIdParameters, GetApiKeysIdError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get API key by ID */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetApiKeysIdSchema, GetApiKeysIdData, TInfinite, GetApiKeysIdParameters, GetApiKeysIdError>
        | QueryFiltersByQueryKey<GetApiKeysIdSchema, GetApiKeysIdData, TInfinite, GetApiKeysIdParameters, GetApiKeysIdError>
    ): number;
    /** @summary Get API key by ID */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetApiKeysIdParameters, TMeta, TSignal>,
      client?: (
        schema: GetApiKeysIdSchema,
        options: {
          parameters: GetApiKeysIdParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetApiKeysIdData, GetApiKeysIdError>>
    ): Promise<RequestFnResponse<GetApiKeysIdData, GetApiKeysIdError>>;
    /** @summary Get API key by ID */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetApiKeysIdSchema, GetApiKeysIdData, TInfinite, GetApiKeysIdParameters, GetApiKeysIdError>
        | QueryFiltersByQueryKey<GetApiKeysIdSchema, GetApiKeysIdData, TInfinite, GetApiKeysIdParameters, GetApiKeysIdError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get API key by ID */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetApiKeysIdSchema, GetApiKeysIdData, TInfinite, GetApiKeysIdParameters, GetApiKeysIdError>
        | QueryFiltersByQueryKey<GetApiKeysIdSchema, GetApiKeysIdData, TInfinite, GetApiKeysIdParameters, GetApiKeysIdError>
    ): void;
    /** @summary Get API key by ID */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetApiKeysIdSchema, GetApiKeysIdData, TInfinite, GetApiKeysIdParameters, GetApiKeysIdError>
        | QueryFiltersByQueryKey<GetApiKeysIdSchema, GetApiKeysIdData, TInfinite, GetApiKeysIdParameters, GetApiKeysIdError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get API key by ID */
    setInfiniteQueryData(
      parameters: DeepReadonly<GetApiKeysIdParameters> | ServiceOperationInfiniteQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetApiKeysIdData, GetApiKeysIdParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetApiKeysIdData, GetApiKeysIdParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetApiKeysIdData, GetApiKeysIdParameters> | undefined;
    /** @summary Get API key by ID */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetApiKeysIdSchema, GetApiKeysIdData, TInfinite, GetApiKeysIdParameters, GetApiKeysIdError>
        | QueryFiltersByQueryKey<GetApiKeysIdSchema, GetApiKeysIdData, TInfinite, GetApiKeysIdParameters, GetApiKeysIdError>,
      updater: Updater<NoInfer<GetApiKeysIdData> | undefined, NoInfer<GetApiKeysIdData> | undefined>,
      options?: SetDataOptions
    ): Array<GetApiKeysIdData | undefined>;
    /** @summary Get API key by ID */
    setQueryData(
      parameters: DeepReadonly<GetApiKeysIdParameters> | ServiceOperationQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters>,
      updater: Updater<NoInfer<GetApiKeysIdData> | undefined, NoInfer<DeepReadonly<GetApiKeysIdData>> | undefined>,
      options?: SetDataOptions
    ): GetApiKeysIdData | undefined;
    /** @summary Get API key by ID */
    getInfiniteQueryKey(parameters: DeepReadonly<GetApiKeysIdParameters>): ServiceOperationInfiniteQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get API key by ID
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getApiKeysId.useInfiniteQuery({
     *     path: {
     *         id: id
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetApiKeysIdParameters,
      TQueryFnData = GetApiKeysIdData,
      TData = OperationInfiniteData<TQueryFnData, GetApiKeysIdParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters> | DeepReadonly<GetApiKeysIdParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetApiKeysIdError,
          TData,
          ServiceOperationInfiniteQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetApiKeysIdError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get API key by ID
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getApiKeysId.useInfiniteQuery({
     *     path: {
     *         id: id
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetApiKeysIdParameters,
      TQueryFnData = GetApiKeysIdData,
      TData = OperationInfiniteData<TQueryFnData, GetApiKeysIdParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters> | DeepReadonly<GetApiKeysIdParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetApiKeysIdError,
          TData,
          ServiceOperationInfiniteQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetApiKeysIdData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetApiKeysIdError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get API key by ID
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getApiKeysIdTotal = qraft.v1Service.getApiKeysId.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getApiKeysIdByParametersTotal = qraft.v1Service.getApiKeysId.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             id: id
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetApiKeysIdSchema, GetApiKeysIdData, TInfinite, GetApiKeysIdParameters, GetApiKeysIdError>
        | QueryFiltersByQueryKey<GetApiKeysIdSchema, GetApiKeysIdData, TInfinite, GetApiKeysIdParameters, GetApiKeysIdError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get API key by ID
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getApiKeysIdResults = qraft.v1Service.getApiKeysId.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getApiKeysIdResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getApiKeysIdCombinedResults = qraft.v1Service.getApiKeysId.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getApiKeysIdCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetApiKeysIdSchema, GetApiKeysIdParameters, GetApiKeysIdData, GetApiKeysIdError>>,
      TCombinedResult = Array<UseQueryResult<GetApiKeysIdData, GetApiKeysIdError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetApiKeysIdData, GetApiKeysIdError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get API key by ID */
    getQueryKey(parameters: DeepReadonly<GetApiKeysIdParameters>): ServiceOperationQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get API key by ID
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getApiKeysId.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetApiKeysIdData>(
      parameters: ServiceOperationQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters> | DeepReadonly<GetApiKeysIdParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<GetApiKeysIdData, GetApiKeysIdError, TData, ServiceOperationQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetApiKeysIdError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get API key by ID
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getApiKeysId.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetApiKeysIdData>(
      parameters: ServiceOperationQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters> | DeepReadonly<GetApiKeysIdParameters>,
      options: Omit<
        DefinedInitialDataOptions<GetApiKeysIdData, GetApiKeysIdError, TData, ServiceOperationQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetApiKeysIdError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get API key by ID
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getApiKeysId.useSuspenseInfiniteQuery({
     *     path: {
     *         id: id
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetApiKeysIdParameters, TData = GetApiKeysIdData>(
      parameters: ServiceOperationInfiniteQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters> | DeepReadonly<GetApiKeysIdParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetApiKeysIdData,
          GetApiKeysIdError,
          OperationInfiniteData<TData, GetApiKeysIdParameters>,
          GetApiKeysIdData,
          ServiceOperationInfiniteQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetApiKeysIdData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetApiKeysIdParameters>, GetApiKeysIdError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get API key by ID
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getApiKeysIdData = qraft.v1Service.getApiKeysId.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getApiKeysIdResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getApiKeysIdCombinedData = qraft.v1Service.getApiKeysId.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getApiKeysIdCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetApiKeysIdSchema, GetApiKeysIdParameters, GetApiKeysIdData, GetApiKeysIdError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetApiKeysIdData, GetApiKeysIdError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetApiKeysIdData, GetApiKeysIdError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get API key by ID
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getApiKeysId.useSuspenseQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetApiKeysIdData>(
      parameters: ServiceOperationQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters> | DeepReadonly<GetApiKeysIdParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<GetApiKeysIdData, GetApiKeysIdError, TData, ServiceOperationQueryKey<GetApiKeysIdSchema, GetApiKeysIdParameters>>,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetApiKeysIdError | Error>;
    schema: GetApiKeysIdSchema;
    types: {
      parameters: GetApiKeysIdParameters;
      data: GetApiKeysIdData;
      error: GetApiKeysIdError;
    };
  };
  /** @summary Update API key */
  patchApiKeysId: {
    /** @summary Update API key */
    getMutationKey(parameters: DeepReadonly<PatchApiKeysIdParameters> | void): ServiceOperationMutationKey<PatchApiKeysIdSchema, PatchApiKeysIdParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Update API key
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchApiKeysId.useMutation({
     *     path: {
     *         id: id
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchApiKeysId.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends PatchApiKeysIdBody, TContext = unknown>(
      parameters: DeepReadonly<PatchApiKeysIdParameters>,
      options?: ServiceOperationUseMutationOptions<
        PatchApiKeysIdSchema,
        PatchApiKeysIdData,
        PatchApiKeysIdParameters,
        TVariables,
        PatchApiKeysIdError | Error,
        TContext
      >
    ): UseMutationResult<PatchApiKeysIdData, PatchApiKeysIdError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Update API key
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchApiKeysId.useMutation({
     *     path: {
     *         id: id
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchApiKeysId.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PatchApiKeysIdBody, PatchApiKeysIdParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PatchApiKeysIdSchema,
        PatchApiKeysIdData,
        PatchApiKeysIdParameters,
        TVariables,
        PatchApiKeysIdError | Error,
        TContext
      >
    ): UseMutationResult<PatchApiKeysIdData, PatchApiKeysIdError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Update API key
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const patchApiKeysIdTotal = qraft.v1Service.patchApiKeysId.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const patchApiKeysIdTotal = qraft.v1Service.patchApiKeysId.useIsMutating({
     *     parameters: {
     *         path: {
     *             id: id
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<PatchApiKeysIdBody, PatchApiKeysIdData, PatchApiKeysIdParameters, PatchApiKeysIdError | Error, TContext>
        | MutationFiltersByMutationKey<
            PatchApiKeysIdSchema,
            PatchApiKeysIdBody,
            PatchApiKeysIdData,
            PatchApiKeysIdParameters,
            PatchApiKeysIdError | Error,
            TContext
          >
    ): number;
    /** @summary Update API key */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<PatchApiKeysIdBody, PatchApiKeysIdData, PatchApiKeysIdParameters, PatchApiKeysIdError | Error, TContext>
        | MutationFiltersByMutationKey<
            PatchApiKeysIdSchema,
            PatchApiKeysIdBody,
            PatchApiKeysIdData,
            PatchApiKeysIdParameters,
            PatchApiKeysIdError | Error,
            TContext
          >
    ): number;
    /** @summary Update API key */
    (
      options: ServiceOperationMutationFnOptions<PatchApiKeysIdBody, PatchApiKeysIdParameters>,
      client?: (
        schema: PatchApiKeysIdSchema,
        options: ServiceOperationMutationFnOptions<PatchApiKeysIdBody, PatchApiKeysIdParameters>
      ) => Promise<RequestFnResponse<PatchApiKeysIdData, PatchApiKeysIdError>>
    ): Promise<RequestFnResponse<PatchApiKeysIdData, PatchApiKeysIdError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Update API key
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const patchApiKeysIdPendingMutationVariables = qraft.v1Service.patchApiKeysId.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const patchApiKeysIdMutationData = qraft.v1Service.patchApiKeysId.useMutationState({
     *     filters: {
     *         parameters: {
     *             path: {
     *                 id: id
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<PatchApiKeysIdData, PatchApiKeysIdError | Error, MutationVariables<PatchApiKeysIdBody, PatchApiKeysIdParameters>, TContext>
    >(options?: {
      filters?:
        | MutationFiltersByParameters<PatchApiKeysIdBody, PatchApiKeysIdData, PatchApiKeysIdParameters, PatchApiKeysIdError | Error, TContext>
        | MutationFiltersByMutationKey<
            PatchApiKeysIdSchema,
            PatchApiKeysIdBody,
            PatchApiKeysIdData,
            PatchApiKeysIdParameters,
            PatchApiKeysIdError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<PatchApiKeysIdData, PatchApiKeysIdError | Error, MutationVariables<PatchApiKeysIdBody, PatchApiKeysIdParameters>, TContext>
      ) => TResult;
    }): Array<TResult>;
    schema: PatchApiKeysIdSchema;
    types: {
      parameters: PatchApiKeysIdParameters;
      data: PatchApiKeysIdData;
      error: PatchApiKeysIdError;
      body: PatchApiKeysIdBody;
    };
  };
  /** @summary Delete API key */
  deleteApiKeysId: {
    /** @summary Delete API key */
    getMutationKey(parameters: DeepReadonly<DeleteApiKeysIdParameters> | void): ServiceOperationMutationKey<DeleteApiKeysIdSchema, DeleteApiKeysIdParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Delete API key
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteApiKeysId.useMutation({
     *     path: {
     *         id: id
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteApiKeysId.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends DeleteApiKeysIdBody, TContext = unknown>(
      parameters: DeepReadonly<DeleteApiKeysIdParameters>,
      options?: ServiceOperationUseMutationOptions<
        DeleteApiKeysIdSchema,
        DeleteApiKeysIdData,
        DeleteApiKeysIdParameters,
        TVariables,
        DeleteApiKeysIdError | Error,
        TContext
      >
    ): UseMutationResult<DeleteApiKeysIdData, DeleteApiKeysIdError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Delete API key
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteApiKeysId.useMutation({
     *     path: {
     *         id: id
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteApiKeysId.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<DeleteApiKeysIdBody, DeleteApiKeysIdParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        DeleteApiKeysIdSchema,
        DeleteApiKeysIdData,
        DeleteApiKeysIdParameters,
        TVariables,
        DeleteApiKeysIdError | Error,
        TContext
      >
    ): UseMutationResult<DeleteApiKeysIdData, DeleteApiKeysIdError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Delete API key
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const deleteApiKeysIdTotal = qraft.v1Service.deleteApiKeysId.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const deleteApiKeysIdTotal = qraft.v1Service.deleteApiKeysId.useIsMutating({
     *     parameters: {
     *         path: {
     *             id: id
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<DeleteApiKeysIdBody, DeleteApiKeysIdData, DeleteApiKeysIdParameters, DeleteApiKeysIdError | Error, TContext>
        | MutationFiltersByMutationKey<
            DeleteApiKeysIdSchema,
            DeleteApiKeysIdBody,
            DeleteApiKeysIdData,
            DeleteApiKeysIdParameters,
            DeleteApiKeysIdError | Error,
            TContext
          >
    ): number;
    /** @summary Delete API key */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<DeleteApiKeysIdBody, DeleteApiKeysIdData, DeleteApiKeysIdParameters, DeleteApiKeysIdError | Error, TContext>
        | MutationFiltersByMutationKey<
            DeleteApiKeysIdSchema,
            DeleteApiKeysIdBody,
            DeleteApiKeysIdData,
            DeleteApiKeysIdParameters,
            DeleteApiKeysIdError | Error,
            TContext
          >
    ): number;
    /** @summary Delete API key */
    (
      options: ServiceOperationMutationFnOptions<DeleteApiKeysIdBody, DeleteApiKeysIdParameters>,
      client?: (
        schema: DeleteApiKeysIdSchema,
        options: ServiceOperationMutationFnOptions<DeleteApiKeysIdBody, DeleteApiKeysIdParameters>
      ) => Promise<RequestFnResponse<DeleteApiKeysIdData, DeleteApiKeysIdError>>
    ): Promise<RequestFnResponse<DeleteApiKeysIdData, DeleteApiKeysIdError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Delete API key
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const deleteApiKeysIdPendingMutationVariables = qraft.v1Service.deleteApiKeysId.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const deleteApiKeysIdMutationData = qraft.v1Service.deleteApiKeysId.useMutationState({
     *     filters: {
     *         parameters: {
     *             path: {
     *                 id: id
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<DeleteApiKeysIdData, DeleteApiKeysIdError | Error, MutationVariables<DeleteApiKeysIdBody, DeleteApiKeysIdParameters>, TContext>
    >(options?: {
      filters?:
        | MutationFiltersByParameters<DeleteApiKeysIdBody, DeleteApiKeysIdData, DeleteApiKeysIdParameters, DeleteApiKeysIdError | Error, TContext>
        | MutationFiltersByMutationKey<
            DeleteApiKeysIdSchema,
            DeleteApiKeysIdBody,
            DeleteApiKeysIdData,
            DeleteApiKeysIdParameters,
            DeleteApiKeysIdError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<DeleteApiKeysIdData, DeleteApiKeysIdError | Error, MutationVariables<DeleteApiKeysIdBody, DeleteApiKeysIdParameters>, TContext>
      ) => TResult;
    }): Array<TResult>;
    schema: DeleteApiKeysIdSchema;
    types: {
      parameters: DeleteApiKeysIdParameters;
      data: DeleteApiKeysIdData;
      error: DeleteApiKeysIdError;
      body: DeleteApiKeysIdBody;
    };
  };
  /** @summary List bids */
  getBids: {
    /** @summary List bids */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBidsSchema, GetBidsData, TInfinite, GetBidsParameters, GetBidsError>
        | QueryFiltersByQueryKey<GetBidsSchema, GetBidsData, TInfinite, GetBidsParameters, GetBidsError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary List bids */
    getQueryKey(parameters: DeepReadonly<GetBidsParameters>): ServiceOperationQueryKey<GetBidsSchema, GetBidsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary List bids
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBids.useQuery({
     *     query: {
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useQuery<TData = GetBidsData>(
      parameters: ServiceOperationQueryKey<GetBidsSchema, GetBidsParameters> | DeepReadonly<GetBidsParameters>,
      options?: Omit<UndefinedInitialDataOptions<GetBidsData, GetBidsError, TData, ServiceOperationQueryKey<GetBidsSchema, GetBidsParameters>>, "queryKey">
    ): UseQueryResult<TData, GetBidsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary List bids
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBids.useQuery({
     *     query: {
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useQuery<TData = GetBidsData>(
      parameters: ServiceOperationQueryKey<GetBidsSchema, GetBidsParameters> | DeepReadonly<GetBidsParameters>,
      options: Omit<DefinedInitialDataOptions<GetBidsData, GetBidsError, TData, ServiceOperationQueryKey<GetBidsSchema, GetBidsParameters>>, "queryKey">
    ): DefinedUseQueryResult<TData, GetBidsError | Error>;
    /** @summary List bids */
    fetchInfiniteQuery<TPageParam extends GetBidsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<GetBidsSchema, GetBidsData, GetBidsParameters, DeepReadonly<TPageParam>, GetBidsError>
    ): Promise<OperationInfiniteData<GetBidsData, GetBidsParameters>>;
    /** @summary List bids */
    prefetchInfiniteQuery<TPageParam extends GetBidsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<GetBidsSchema, GetBidsData, GetBidsParameters, DeepReadonly<TPageParam>, GetBidsError>
    ): Promise<void>;
    /** @summary List bids */
    ensureInfiniteQueryData<TPageParam extends GetBidsParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<GetBidsSchema, GetBidsData, GetBidsParameters, DeepReadonly<TPageParam>, GetBidsError>
    ): Promise<OperationInfiniteData<GetBidsData, GetBidsParameters>>;
    /** @summary List bids */
    fetchQuery(options: ServiceOperationFetchQueryOptions<GetBidsSchema, GetBidsData, GetBidsParameters, GetBidsError>): Promise<GetBidsData>;
    /** @summary List bids */
    prefetchQuery(options: ServiceOperationFetchQueryOptions<GetBidsSchema, GetBidsData, GetBidsParameters, GetBidsError>): Promise<void>;
    /** @summary List bids */
    ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetBidsSchema, GetBidsData, GetBidsParameters, GetBidsError>): Promise<GetBidsData>;
    /** @summary List bids */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetBidsSchema, GetBidsParameters> | DeepReadonly<GetBidsParameters>
    ): OperationInfiniteData<GetBidsData, GetBidsParameters> | undefined;
    /** @summary List bids */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBidsSchema, GetBidsData, TInfinite, GetBidsParameters, GetBidsError>
        | QueryFiltersByQueryKey<GetBidsSchema, GetBidsData, TInfinite, GetBidsParameters, GetBidsError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetBidsSchema, GetBidsParameters>,
            data: NoInfer<OperationInfiniteData<GetBidsData, GetBidsParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetBidsSchema, GetBidsParameters>, data: GetBidsData | undefined]>;
    /** @summary List bids */
    getQueryData(parameters: ServiceOperationQueryKey<GetBidsSchema, GetBidsParameters> | DeepReadonly<GetBidsParameters>): GetBidsData | undefined;
    /** @summary List bids */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetBidsSchema, GetBidsParameters> | DeepReadonly<GetBidsParameters>
    ): QueryState<GetBidsData, GetBidsError> | undefined;
    /** @summary List bids */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetBidsParameters> | ServiceOperationInfiniteQueryKey<GetBidsSchema, GetBidsParameters>
    ): QueryState<OperationInfiniteData<GetBidsData, GetBidsParameters>, GetBidsError> | undefined;
    /** @summary List bids */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetBidsSchema, GetBidsData, TInfinite, GetBidsParameters, GetBidsError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary List bids */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBidsSchema, GetBidsData, TInfinite, GetBidsParameters, GetBidsError>
        | QueryFiltersByQueryKey<GetBidsSchema, GetBidsData, TInfinite, GetBidsParameters, GetBidsError>
    ): number;
    /** @summary List bids */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options: QueryFnOptionsByQueryKey<GetBidsSchema, GetBidsParameters, TMeta, TSignal> | QueryFnOptionsByParameters<GetBidsParameters, TMeta, TSignal>,
      client?: (
        schema: GetBidsSchema,
        options: {
          parameters: GetBidsParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetBidsData, GetBidsError>>
    ): Promise<RequestFnResponse<GetBidsData, GetBidsError>>;
    /** @summary List bids */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBidsSchema, GetBidsData, TInfinite, GetBidsParameters, GetBidsError>
        | QueryFiltersByQueryKey<GetBidsSchema, GetBidsData, TInfinite, GetBidsParameters, GetBidsError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary List bids */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBidsSchema, GetBidsData, TInfinite, GetBidsParameters, GetBidsError>
        | QueryFiltersByQueryKey<GetBidsSchema, GetBidsData, TInfinite, GetBidsParameters, GetBidsError>
    ): void;
    /** @summary List bids */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBidsSchema, GetBidsData, TInfinite, GetBidsParameters, GetBidsError>
        | QueryFiltersByQueryKey<GetBidsSchema, GetBidsData, TInfinite, GetBidsParameters, GetBidsError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary List bids */
    setInfiniteQueryData(
      parameters: DeepReadonly<GetBidsParameters> | ServiceOperationInfiniteQueryKey<GetBidsSchema, GetBidsParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetBidsData, GetBidsParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetBidsData, GetBidsParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetBidsData, GetBidsParameters> | undefined;
    /** @summary List bids */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetBidsSchema, GetBidsData, TInfinite, GetBidsParameters, GetBidsError>
        | QueryFiltersByQueryKey<GetBidsSchema, GetBidsData, TInfinite, GetBidsParameters, GetBidsError>,
      updater: Updater<NoInfer<GetBidsData> | undefined, NoInfer<GetBidsData> | undefined>,
      options?: SetDataOptions
    ): Array<GetBidsData | undefined>;
    /** @summary List bids */
    setQueryData(
      parameters: DeepReadonly<GetBidsParameters> | ServiceOperationQueryKey<GetBidsSchema, GetBidsParameters>,
      updater: Updater<NoInfer<GetBidsData> | undefined, NoInfer<DeepReadonly<GetBidsData>> | undefined>,
      options?: SetDataOptions
    ): GetBidsData | undefined;
    /** @summary List bids */
    getInfiniteQueryKey(parameters: DeepReadonly<GetBidsParameters>): ServiceOperationInfiniteQueryKey<GetBidsSchema, GetBidsParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary List bids
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getBids.useInfiniteQuery({
     *     query: {
     *         dseq: dseq
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             dseq: initialDseq
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<TPageParam extends GetBidsParameters, TQueryFnData = GetBidsData, TData = OperationInfiniteData<TQueryFnData, GetBidsParameters>>(
      parameters: ServiceOperationInfiniteQueryKey<GetBidsSchema, GetBidsParameters> | DeepReadonly<GetBidsParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetBidsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetBidsSchema, GetBidsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetBidsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary List bids
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getBids.useInfiniteQuery({
     *     query: {
     *         dseq: dseq
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             dseq: initialDseq
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<TPageParam extends GetBidsParameters, TQueryFnData = GetBidsData, TData = OperationInfiniteData<TQueryFnData, GetBidsParameters>>(
      parameters: ServiceOperationInfiniteQueryKey<GetBidsSchema, GetBidsParameters> | DeepReadonly<GetBidsParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetBidsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetBidsSchema, GetBidsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetBidsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetBidsError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary List bids
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getBidsTotal = qraft.v1Service.getBids.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getBidsByParametersTotal = qraft.v1Service.getBids.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         query: {
     *             dseq: dseq
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBidsSchema, GetBidsData, TInfinite, GetBidsParameters, GetBidsError>
        | QueryFiltersByQueryKey<GetBidsSchema, GetBidsData, TInfinite, GetBidsParameters, GetBidsError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary List bids
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getBidsResults = qraft.v1Service.getBids.useQueries({
     *     queries: [
     *         {
     *             query: {
     *                 dseq: dseq1
     *             }
     *         },
     *         {
     *             query: {
     *                 dseq: dseq2
     *             }
     *         }
     *     ]
     * });
     * getBidsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getBidsCombinedResults = qraft.v1Service.getBids.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 dseq: dseq1
     *             }
     *         },
     *         {
     *             query: {
     *                 dseq: dseq2
     *             }
     *         }
     *     ]
     * });
     * getBidsCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetBidsSchema, GetBidsParameters, GetBidsData, GetBidsError>>,
      TCombinedResult = Array<UseQueryResult<GetBidsData, GetBidsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetBidsData, GetBidsError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary List bids */
    getQueryKey(parameters: DeepReadonly<GetBidsParameters>): ServiceOperationQueryKey<GetBidsSchema, GetBidsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary List bids
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBids.useQuery({
     *     query: {
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useQuery<TData = GetBidsData>(
      parameters: ServiceOperationQueryKey<GetBidsSchema, GetBidsParameters> | DeepReadonly<GetBidsParameters>,
      options?: Omit<UndefinedInitialDataOptions<GetBidsData, GetBidsError, TData, ServiceOperationQueryKey<GetBidsSchema, GetBidsParameters>>, "queryKey">
    ): UseQueryResult<TData, GetBidsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary List bids
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBids.useQuery({
     *     query: {
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useQuery<TData = GetBidsData>(
      parameters: ServiceOperationQueryKey<GetBidsSchema, GetBidsParameters> | DeepReadonly<GetBidsParameters>,
      options: Omit<DefinedInitialDataOptions<GetBidsData, GetBidsError, TData, ServiceOperationQueryKey<GetBidsSchema, GetBidsParameters>>, "queryKey">
    ): DefinedUseQueryResult<TData, GetBidsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary List bids
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getBids.useSuspenseInfiniteQuery({
     *     query: {
     *         dseq: dseq
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             dseq: initialDseq
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetBidsParameters, TData = GetBidsData>(
      parameters: ServiceOperationInfiniteQueryKey<GetBidsSchema, GetBidsParameters> | DeepReadonly<GetBidsParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetBidsData,
          GetBidsError,
          OperationInfiniteData<TData, GetBidsParameters>,
          GetBidsData,
          ServiceOperationInfiniteQueryKey<GetBidsSchema, GetBidsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetBidsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetBidsParameters>, GetBidsError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary List bids
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getBidsData = qraft.v1Service.getBids.useSuspenseQueries({
     *     queries: [
     *         {
     *             query: {
     *                 dseq: dseq1
     *             }
     *         },
     *         {
     *             query: {
     *                 dseq: dseq2
     *             }
     *         }
     *     ]
     * });
     * getBidsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getBidsCombinedData = qraft.v1Service.getBids.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 dseq: dseq1
     *             }
     *         },
     *         {
     *             query: {
     *                 dseq: dseq2
     *             }
     *         }
     *     ]
     * });
     * getBidsCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetBidsSchema, GetBidsParameters, GetBidsData, GetBidsError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetBidsData, GetBidsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetBidsData, GetBidsError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary List bids
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getBids.useSuspenseQuery({
     *     query: {
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetBidsData>(
      parameters: ServiceOperationQueryKey<GetBidsSchema, GetBidsParameters> | DeepReadonly<GetBidsParameters>,
      options?: Omit<UseSuspenseQueryOptions<GetBidsData, GetBidsError, TData, ServiceOperationQueryKey<GetBidsSchema, GetBidsParameters>>, "queryKey">
    ): UseSuspenseQueryResult<TData, GetBidsError | Error>;
    schema: GetBidsSchema;
    types: {
      parameters: GetBidsParameters;
      data: GetBidsData;
      error: GetBidsError;
    };
  };
  /** @summary List bids by dseq */
  getBidsDseq: {
    /** @summary List bids by dseq */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBidsDseqSchema, GetBidsDseqData, TInfinite, GetBidsDseqParameters, GetBidsDseqError>
        | QueryFiltersByQueryKey<GetBidsDseqSchema, GetBidsDseqData, TInfinite, GetBidsDseqParameters, GetBidsDseqError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary List bids by dseq */
    getQueryKey(parameters: DeepReadonly<GetBidsDseqParameters>): ServiceOperationQueryKey<GetBidsDseqSchema, GetBidsDseqParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary List bids by dseq
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBidsDseq.useQuery({
     *     path: {
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useQuery<TData = GetBidsDseqData>(
      parameters: ServiceOperationQueryKey<GetBidsDseqSchema, GetBidsDseqParameters> | DeepReadonly<GetBidsDseqParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<GetBidsDseqData, GetBidsDseqError, TData, ServiceOperationQueryKey<GetBidsDseqSchema, GetBidsDseqParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetBidsDseqError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary List bids by dseq
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBidsDseq.useQuery({
     *     path: {
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useQuery<TData = GetBidsDseqData>(
      parameters: ServiceOperationQueryKey<GetBidsDseqSchema, GetBidsDseqParameters> | DeepReadonly<GetBidsDseqParameters>,
      options: Omit<
        DefinedInitialDataOptions<GetBidsDseqData, GetBidsDseqError, TData, ServiceOperationQueryKey<GetBidsDseqSchema, GetBidsDseqParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetBidsDseqError | Error>;
    /** @summary List bids by dseq */
    fetchInfiniteQuery<TPageParam extends GetBidsDseqParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<GetBidsDseqSchema, GetBidsDseqData, GetBidsDseqParameters, DeepReadonly<TPageParam>, GetBidsDseqError>
    ): Promise<OperationInfiniteData<GetBidsDseqData, GetBidsDseqParameters>>;
    /** @summary List bids by dseq */
    prefetchInfiniteQuery<TPageParam extends GetBidsDseqParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<GetBidsDseqSchema, GetBidsDseqData, GetBidsDseqParameters, DeepReadonly<TPageParam>, GetBidsDseqError>
    ): Promise<void>;
    /** @summary List bids by dseq */
    ensureInfiniteQueryData<TPageParam extends GetBidsDseqParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetBidsDseqSchema,
        GetBidsDseqData,
        GetBidsDseqParameters,
        DeepReadonly<TPageParam>,
        GetBidsDseqError
      >
    ): Promise<OperationInfiniteData<GetBidsDseqData, GetBidsDseqParameters>>;
    /** @summary List bids by dseq */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetBidsDseqSchema, GetBidsDseqData, GetBidsDseqParameters, GetBidsDseqError>
    ): Promise<GetBidsDseqData>;
    /** @summary List bids by dseq */
    prefetchQuery(options: ServiceOperationFetchQueryOptions<GetBidsDseqSchema, GetBidsDseqData, GetBidsDseqParameters, GetBidsDseqError>): Promise<void>;
    /** @summary List bids by dseq */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetBidsDseqSchema, GetBidsDseqData, GetBidsDseqParameters, GetBidsDseqError>
    ): Promise<GetBidsDseqData>;
    /** @summary List bids by dseq */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetBidsDseqSchema, GetBidsDseqParameters> | DeepReadonly<GetBidsDseqParameters>
    ): OperationInfiniteData<GetBidsDseqData, GetBidsDseqParameters> | undefined;
    /** @summary List bids by dseq */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBidsDseqSchema, GetBidsDseqData, TInfinite, GetBidsDseqParameters, GetBidsDseqError>
        | QueryFiltersByQueryKey<GetBidsDseqSchema, GetBidsDseqData, TInfinite, GetBidsDseqParameters, GetBidsDseqError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetBidsDseqSchema, GetBidsDseqParameters>,
            data: NoInfer<OperationInfiniteData<GetBidsDseqData, GetBidsDseqParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetBidsDseqSchema, GetBidsDseqParameters>, data: GetBidsDseqData | undefined]>;
    /** @summary List bids by dseq */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetBidsDseqSchema, GetBidsDseqParameters> | DeepReadonly<GetBidsDseqParameters>
    ): GetBidsDseqData | undefined;
    /** @summary List bids by dseq */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetBidsDseqSchema, GetBidsDseqParameters> | DeepReadonly<GetBidsDseqParameters>
    ): QueryState<GetBidsDseqData, GetBidsDseqError> | undefined;
    /** @summary List bids by dseq */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetBidsDseqParameters> | ServiceOperationInfiniteQueryKey<GetBidsDseqSchema, GetBidsDseqParameters>
    ): QueryState<OperationInfiniteData<GetBidsDseqData, GetBidsDseqParameters>, GetBidsDseqError> | undefined;
    /** @summary List bids by dseq */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetBidsDseqSchema, GetBidsDseqData, TInfinite, GetBidsDseqParameters, GetBidsDseqError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary List bids by dseq */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBidsDseqSchema, GetBidsDseqData, TInfinite, GetBidsDseqParameters, GetBidsDseqError>
        | QueryFiltersByQueryKey<GetBidsDseqSchema, GetBidsDseqData, TInfinite, GetBidsDseqParameters, GetBidsDseqError>
    ): number;
    /** @summary List bids by dseq */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetBidsDseqSchema, GetBidsDseqParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetBidsDseqParameters, TMeta, TSignal>,
      client?: (
        schema: GetBidsDseqSchema,
        options: {
          parameters: GetBidsDseqParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetBidsDseqData, GetBidsDseqError>>
    ): Promise<RequestFnResponse<GetBidsDseqData, GetBidsDseqError>>;
    /** @summary List bids by dseq */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBidsDseqSchema, GetBidsDseqData, TInfinite, GetBidsDseqParameters, GetBidsDseqError>
        | QueryFiltersByQueryKey<GetBidsDseqSchema, GetBidsDseqData, TInfinite, GetBidsDseqParameters, GetBidsDseqError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary List bids by dseq */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBidsDseqSchema, GetBidsDseqData, TInfinite, GetBidsDseqParameters, GetBidsDseqError>
        | QueryFiltersByQueryKey<GetBidsDseqSchema, GetBidsDseqData, TInfinite, GetBidsDseqParameters, GetBidsDseqError>
    ): void;
    /** @summary List bids by dseq */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBidsDseqSchema, GetBidsDseqData, TInfinite, GetBidsDseqParameters, GetBidsDseqError>
        | QueryFiltersByQueryKey<GetBidsDseqSchema, GetBidsDseqData, TInfinite, GetBidsDseqParameters, GetBidsDseqError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary List bids by dseq */
    setInfiniteQueryData(
      parameters: DeepReadonly<GetBidsDseqParameters> | ServiceOperationInfiniteQueryKey<GetBidsDseqSchema, GetBidsDseqParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetBidsDseqData, GetBidsDseqParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetBidsDseqData, GetBidsDseqParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetBidsDseqData, GetBidsDseqParameters> | undefined;
    /** @summary List bids by dseq */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetBidsDseqSchema, GetBidsDseqData, TInfinite, GetBidsDseqParameters, GetBidsDseqError>
        | QueryFiltersByQueryKey<GetBidsDseqSchema, GetBidsDseqData, TInfinite, GetBidsDseqParameters, GetBidsDseqError>,
      updater: Updater<NoInfer<GetBidsDseqData> | undefined, NoInfer<GetBidsDseqData> | undefined>,
      options?: SetDataOptions
    ): Array<GetBidsDseqData | undefined>;
    /** @summary List bids by dseq */
    setQueryData(
      parameters: DeepReadonly<GetBidsDseqParameters> | ServiceOperationQueryKey<GetBidsDseqSchema, GetBidsDseqParameters>,
      updater: Updater<NoInfer<GetBidsDseqData> | undefined, NoInfer<DeepReadonly<GetBidsDseqData>> | undefined>,
      options?: SetDataOptions
    ): GetBidsDseqData | undefined;
    /** @summary List bids by dseq */
    getInfiniteQueryKey(parameters: DeepReadonly<GetBidsDseqParameters>): ServiceOperationInfiniteQueryKey<GetBidsDseqSchema, GetBidsDseqParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary List bids by dseq
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getBidsDseq.useInfiniteQuery({
     *     path: {
     *         dseq: dseq
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetBidsDseqParameters,
      TQueryFnData = GetBidsDseqData,
      TData = OperationInfiniteData<TQueryFnData, GetBidsDseqParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetBidsDseqSchema, GetBidsDseqParameters> | DeepReadonly<GetBidsDseqParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetBidsDseqError,
          TData,
          ServiceOperationInfiniteQueryKey<GetBidsDseqSchema, GetBidsDseqParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetBidsDseqError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary List bids by dseq
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getBidsDseq.useInfiniteQuery({
     *     path: {
     *         dseq: dseq
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetBidsDseqParameters,
      TQueryFnData = GetBidsDseqData,
      TData = OperationInfiniteData<TQueryFnData, GetBidsDseqParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetBidsDseqSchema, GetBidsDseqParameters> | DeepReadonly<GetBidsDseqParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetBidsDseqError,
          TData,
          ServiceOperationInfiniteQueryKey<GetBidsDseqSchema, GetBidsDseqParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetBidsDseqData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetBidsDseqError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary List bids by dseq
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getBidsDseqTotal = qraft.v1Service.getBidsDseq.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getBidsDseqByParametersTotal = qraft.v1Service.getBidsDseq.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             dseq: dseq
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBidsDseqSchema, GetBidsDseqData, TInfinite, GetBidsDseqParameters, GetBidsDseqError>
        | QueryFiltersByQueryKey<GetBidsDseqSchema, GetBidsDseqData, TInfinite, GetBidsDseqParameters, GetBidsDseqError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary List bids by dseq
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getBidsDseqResults = qraft.v1Service.getBidsDseq.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 dseq: dseq1
     *             }
     *         },
     *         {
     *             path: {
     *                 dseq: dseq2
     *             }
     *         }
     *     ]
     * });
     * getBidsDseqResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getBidsDseqCombinedResults = qraft.v1Service.getBidsDseq.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 dseq: dseq1
     *             }
     *         },
     *         {
     *             path: {
     *                 dseq: dseq2
     *             }
     *         }
     *     ]
     * });
     * getBidsDseqCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetBidsDseqSchema, GetBidsDseqParameters, GetBidsDseqData, GetBidsDseqError>>,
      TCombinedResult = Array<UseQueryResult<GetBidsDseqData, GetBidsDseqError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetBidsDseqData, GetBidsDseqError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary List bids by dseq */
    getQueryKey(parameters: DeepReadonly<GetBidsDseqParameters>): ServiceOperationQueryKey<GetBidsDseqSchema, GetBidsDseqParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary List bids by dseq
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBidsDseq.useQuery({
     *     path: {
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useQuery<TData = GetBidsDseqData>(
      parameters: ServiceOperationQueryKey<GetBidsDseqSchema, GetBidsDseqParameters> | DeepReadonly<GetBidsDseqParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<GetBidsDseqData, GetBidsDseqError, TData, ServiceOperationQueryKey<GetBidsDseqSchema, GetBidsDseqParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetBidsDseqError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary List bids by dseq
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBidsDseq.useQuery({
     *     path: {
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useQuery<TData = GetBidsDseqData>(
      parameters: ServiceOperationQueryKey<GetBidsDseqSchema, GetBidsDseqParameters> | DeepReadonly<GetBidsDseqParameters>,
      options: Omit<
        DefinedInitialDataOptions<GetBidsDseqData, GetBidsDseqError, TData, ServiceOperationQueryKey<GetBidsDseqSchema, GetBidsDseqParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetBidsDseqError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary List bids by dseq
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getBidsDseq.useSuspenseInfiniteQuery({
     *     path: {
     *         dseq: dseq
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetBidsDseqParameters, TData = GetBidsDseqData>(
      parameters: ServiceOperationInfiniteQueryKey<GetBidsDseqSchema, GetBidsDseqParameters> | DeepReadonly<GetBidsDseqParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetBidsDseqData,
          GetBidsDseqError,
          OperationInfiniteData<TData, GetBidsDseqParameters>,
          GetBidsDseqData,
          ServiceOperationInfiniteQueryKey<GetBidsDseqSchema, GetBidsDseqParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetBidsDseqData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetBidsDseqParameters>, GetBidsDseqError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary List bids by dseq
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getBidsDseqData = qraft.v1Service.getBidsDseq.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 dseq: dseq1
     *             }
     *         },
     *         {
     *             path: {
     *                 dseq: dseq2
     *             }
     *         }
     *     ]
     * });
     * getBidsDseqResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getBidsDseqCombinedData = qraft.v1Service.getBidsDseq.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 dseq: dseq1
     *             }
     *         },
     *         {
     *             path: {
     *                 dseq: dseq2
     *             }
     *         }
     *     ]
     * });
     * getBidsDseqCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetBidsDseqSchema, GetBidsDseqParameters, GetBidsDseqData, GetBidsDseqError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetBidsDseqData, GetBidsDseqError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetBidsDseqData, GetBidsDseqError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary List bids by dseq
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getBidsDseq.useSuspenseQuery({
     *     path: {
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetBidsDseqData>(
      parameters: ServiceOperationQueryKey<GetBidsDseqSchema, GetBidsDseqParameters> | DeepReadonly<GetBidsDseqParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<GetBidsDseqData, GetBidsDseqError, TData, ServiceOperationQueryKey<GetBidsDseqSchema, GetBidsDseqParameters>>,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetBidsDseqError | Error>;
    schema: GetBidsDseqSchema;
    types: {
      parameters: GetBidsDseqParameters;
      data: GetBidsDseqData;
      error: GetBidsDseqError;
    };
  };
  /** @summary Create certificate */
  postCertificates: {
    /** @summary Create certificate */
    getMutationKey(
      parameters: DeepReadonly<PostCertificatesParameters> | void
    ): ServiceOperationMutationKey<PostCertificatesSchema, PostCertificatesParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Create certificate
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postCertificates.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postCertificates.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends PostCertificatesBody, TContext = unknown>(
      parameters: DeepReadonly<PostCertificatesParameters>,
      options?: ServiceOperationUseMutationOptions<
        PostCertificatesSchema,
        PostCertificatesData,
        PostCertificatesParameters,
        TVariables,
        PostCertificatesError | Error,
        TContext
      >
    ): UseMutationResult<PostCertificatesData, PostCertificatesError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Create certificate
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postCertificates.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postCertificates.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PostCertificatesBody, PostCertificatesParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PostCertificatesSchema,
        PostCertificatesData,
        PostCertificatesParameters,
        TVariables,
        PostCertificatesError | Error,
        TContext
      >
    ): UseMutationResult<PostCertificatesData, PostCertificatesError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Create certificate
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const postCertificatesTotal = qraft.v1Service.postCertificates.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const postCertificatesTotal = qraft.v1Service.postCertificates.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<PostCertificatesBody, PostCertificatesData, PostCertificatesParameters, PostCertificatesError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostCertificatesSchema,
            PostCertificatesBody,
            PostCertificatesData,
            PostCertificatesParameters,
            PostCertificatesError | Error,
            TContext
          >
    ): number;
    /** @summary Create certificate */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<PostCertificatesBody, PostCertificatesData, PostCertificatesParameters, PostCertificatesError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostCertificatesSchema,
            PostCertificatesBody,
            PostCertificatesData,
            PostCertificatesParameters,
            PostCertificatesError | Error,
            TContext
          >
    ): number;
    /** @summary Create certificate */
    (
      options: ServiceOperationMutationFnOptions<PostCertificatesBody, PostCertificatesParameters>,
      client?: (
        schema: PostCertificatesSchema,
        options: ServiceOperationMutationFnOptions<PostCertificatesBody, PostCertificatesParameters>
      ) => Promise<RequestFnResponse<PostCertificatesData, PostCertificatesError>>
    ): Promise<RequestFnResponse<PostCertificatesData, PostCertificatesError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Create certificate
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const postCertificatesPendingMutationVariables = qraft.v1Service.postCertificates.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const postCertificatesMutationData = qraft.v1Service.postCertificates.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        PostCertificatesData,
        PostCertificatesError | Error,
        MutationVariables<PostCertificatesBody, PostCertificatesParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<PostCertificatesBody, PostCertificatesData, PostCertificatesParameters, PostCertificatesError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostCertificatesSchema,
            PostCertificatesBody,
            PostCertificatesData,
            PostCertificatesParameters,
            PostCertificatesError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<PostCertificatesData, PostCertificatesError | Error, MutationVariables<PostCertificatesBody, PostCertificatesParameters>, TContext>
      ) => TResult;
    }): Array<TResult>;
    schema: PostCertificatesSchema;
    types: {
      parameters: PostCertificatesParameters;
      data: PostCertificatesData;
      error: PostCertificatesError;
      body: PostCertificatesBody;
    };
  };
  /** @summary Get user balances */
  getBalances: {
    /** @summary Get user balances */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBalancesSchema, GetBalancesData, TInfinite, GetBalancesParameters, GetBalancesError>
        | QueryFiltersByQueryKey<GetBalancesSchema, GetBalancesData, TInfinite, GetBalancesParameters, GetBalancesError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get user balances */
    getQueryKey(parameters: DeepReadonly<GetBalancesParameters> | void): ServiceOperationQueryKey<GetBalancesSchema, GetBalancesParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get user balances
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBalances.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBalances.useQuery({
     *     query: {
     *         address: address
     *     }
     * })
     * ```
     */
    useQuery<TData = GetBalancesData>(
      parameters: ServiceOperationQueryKey<GetBalancesSchema, GetBalancesParameters> | (DeepReadonly<GetBalancesParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetBalancesData, GetBalancesError, TData, ServiceOperationQueryKey<GetBalancesSchema, GetBalancesParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetBalancesError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get user balances
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBalances.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBalances.useQuery({
     *     query: {
     *         address: address
     *     }
     * })
     * ```
     */
    useQuery<TData = GetBalancesData>(
      parameters: ServiceOperationQueryKey<GetBalancesSchema, GetBalancesParameters> | (DeepReadonly<GetBalancesParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetBalancesData, GetBalancesError, TData, ServiceOperationQueryKey<GetBalancesSchema, GetBalancesParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetBalancesError | Error>;
    /** @summary Get user balances */
    fetchInfiniteQuery<TPageParam extends GetBalancesParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetBalancesSchema,
        GetBalancesData,
        GetBalancesParameters,
        DeepReadonly<TPageParam>,
        GetBalancesError
      > | void
    ): Promise<OperationInfiniteData<GetBalancesData, GetBalancesParameters>>;
    /** @summary Get user balances */
    prefetchInfiniteQuery<TPageParam extends GetBalancesParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetBalancesSchema,
        GetBalancesData,
        GetBalancesParameters,
        DeepReadonly<TPageParam>,
        GetBalancesError
      > | void
    ): Promise<void>;
    /** @summary Get user balances */
    ensureInfiniteQueryData<TPageParam extends GetBalancesParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetBalancesSchema,
        GetBalancesData,
        GetBalancesParameters,
        DeepReadonly<TPageParam>,
        GetBalancesError
      > | void
    ): Promise<OperationInfiniteData<GetBalancesData, GetBalancesParameters>>;
    /** @summary Get user balances */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetBalancesSchema, GetBalancesData, GetBalancesParameters, GetBalancesError> | void
    ): Promise<GetBalancesData>;
    /** @summary Get user balances */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetBalancesSchema, GetBalancesData, GetBalancesParameters, GetBalancesError> | void
    ): Promise<void>;
    /** @summary Get user balances */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetBalancesSchema, GetBalancesData, GetBalancesParameters, GetBalancesError> | void
    ): Promise<GetBalancesData>;
    /** @summary Get user balances */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetBalancesSchema, GetBalancesParameters> | (DeepReadonly<GetBalancesParameters> | void)
    ): OperationInfiniteData<GetBalancesData, GetBalancesParameters> | undefined;
    /** @summary Get user balances */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBalancesSchema, GetBalancesData, TInfinite, GetBalancesParameters, GetBalancesError>
        | QueryFiltersByQueryKey<GetBalancesSchema, GetBalancesData, TInfinite, GetBalancesParameters, GetBalancesError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetBalancesSchema, GetBalancesParameters>,
            data: NoInfer<OperationInfiniteData<GetBalancesData, GetBalancesParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetBalancesSchema, GetBalancesParameters>, data: GetBalancesData | undefined]>;
    /** @summary Get user balances */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetBalancesSchema, GetBalancesParameters> | (DeepReadonly<GetBalancesParameters> | void)
    ): GetBalancesData | undefined;
    /** @summary Get user balances */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetBalancesSchema, GetBalancesParameters> | (DeepReadonly<GetBalancesParameters> | void)
    ): QueryState<GetBalancesData, GetBalancesError> | undefined;
    /** @summary Get user balances */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetBalancesParameters> | ServiceOperationInfiniteQueryKey<GetBalancesSchema, GetBalancesParameters> | void
    ): QueryState<OperationInfiniteData<GetBalancesData, GetBalancesParameters>, GetBalancesError> | undefined;
    /** @summary Get user balances */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetBalancesSchema, GetBalancesData, TInfinite, GetBalancesParameters, GetBalancesError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get user balances */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBalancesSchema, GetBalancesData, TInfinite, GetBalancesParameters, GetBalancesError>
        | QueryFiltersByQueryKey<GetBalancesSchema, GetBalancesData, TInfinite, GetBalancesParameters, GetBalancesError>
    ): number;
    /** @summary Get user balances */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetBalancesSchema, GetBalancesParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetBalancesParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetBalancesSchema,
        options: {
          parameters: GetBalancesParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetBalancesData, GetBalancesError>>
    ): Promise<RequestFnResponse<GetBalancesData, GetBalancesError>>;
    /** @summary Get user balances */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBalancesSchema, GetBalancesData, TInfinite, GetBalancesParameters, GetBalancesError>
        | QueryFiltersByQueryKey<GetBalancesSchema, GetBalancesData, TInfinite, GetBalancesParameters, GetBalancesError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get user balances */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBalancesSchema, GetBalancesData, TInfinite, GetBalancesParameters, GetBalancesError>
        | QueryFiltersByQueryKey<GetBalancesSchema, GetBalancesData, TInfinite, GetBalancesParameters, GetBalancesError>
    ): void;
    /** @summary Get user balances */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBalancesSchema, GetBalancesData, TInfinite, GetBalancesParameters, GetBalancesError>
        | QueryFiltersByQueryKey<GetBalancesSchema, GetBalancesData, TInfinite, GetBalancesParameters, GetBalancesError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get user balances */
    setInfiniteQueryData(
      parameters: (DeepReadonly<GetBalancesParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetBalancesSchema, GetBalancesParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetBalancesData, GetBalancesParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetBalancesData, GetBalancesParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetBalancesData, GetBalancesParameters> | undefined;
    /** @summary Get user balances */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetBalancesSchema, GetBalancesData, TInfinite, GetBalancesParameters, GetBalancesError>
        | QueryFiltersByQueryKey<GetBalancesSchema, GetBalancesData, TInfinite, GetBalancesParameters, GetBalancesError>,
      updater: Updater<NoInfer<GetBalancesData> | undefined, NoInfer<GetBalancesData> | undefined>,
      options?: SetDataOptions
    ): Array<GetBalancesData | undefined>;
    /** @summary Get user balances */
    setQueryData(
      parameters: (DeepReadonly<GetBalancesParameters> | undefined) | ServiceOperationQueryKey<GetBalancesSchema, GetBalancesParameters>,
      updater: Updater<NoInfer<GetBalancesData> | undefined, NoInfer<DeepReadonly<GetBalancesData>> | undefined>,
      options?: SetDataOptions
    ): GetBalancesData | undefined;
    /** @summary Get user balances */
    getInfiniteQueryKey(parameters: DeepReadonly<GetBalancesParameters> | void): ServiceOperationInfiniteQueryKey<GetBalancesSchema, GetBalancesParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get user balances
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getBalances.useInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             address: initialAddress
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetBalancesParameters,
      TQueryFnData = GetBalancesData,
      TData = OperationInfiniteData<TQueryFnData, GetBalancesParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetBalancesSchema, GetBalancesParameters> | (DeepReadonly<GetBalancesParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetBalancesError,
          TData,
          ServiceOperationInfiniteQueryKey<GetBalancesSchema, GetBalancesParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetBalancesError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get user balances
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getBalances.useInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             address: initialAddress
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetBalancesParameters,
      TQueryFnData = GetBalancesData,
      TData = OperationInfiniteData<TQueryFnData, GetBalancesParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetBalancesSchema, GetBalancesParameters> | (DeepReadonly<GetBalancesParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetBalancesError,
          TData,
          ServiceOperationInfiniteQueryKey<GetBalancesSchema, GetBalancesParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetBalancesData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetBalancesError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get user balances
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getBalancesTotal = qraft.v1Service.getBalances.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getBalancesByParametersTotal = qraft.v1Service.getBalances.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         query: {
     *             address: address
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBalancesSchema, GetBalancesData, TInfinite, GetBalancesParameters, GetBalancesError>
        | QueryFiltersByQueryKey<GetBalancesSchema, GetBalancesData, TInfinite, GetBalancesParameters, GetBalancesError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get user balances
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getBalancesResults = qraft.v1Service.getBalances.useQueries({
     *     queries: [
     *         {
     *             query: {
     *                 address: address1
     *             }
     *         },
     *         {
     *             query: {
     *                 address: address2
     *             }
     *         }
     *     ]
     * });
     * getBalancesResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getBalancesCombinedResults = qraft.v1Service.getBalances.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 address: address1
     *             }
     *         },
     *         {
     *             query: {
     *                 address: address2
     *             }
     *         }
     *     ]
     * });
     * getBalancesCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetBalancesSchema, GetBalancesParameters, GetBalancesData, GetBalancesError>>,
      TCombinedResult = Array<UseQueryResult<GetBalancesData, GetBalancesError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetBalancesData, GetBalancesError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get user balances */
    getQueryKey(parameters: DeepReadonly<GetBalancesParameters> | void): ServiceOperationQueryKey<GetBalancesSchema, GetBalancesParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get user balances
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBalances.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBalances.useQuery({
     *     query: {
     *         address: address
     *     }
     * })
     * ```
     */
    useQuery<TData = GetBalancesData>(
      parameters: ServiceOperationQueryKey<GetBalancesSchema, GetBalancesParameters> | (DeepReadonly<GetBalancesParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetBalancesData, GetBalancesError, TData, ServiceOperationQueryKey<GetBalancesSchema, GetBalancesParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetBalancesError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get user balances
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBalances.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBalances.useQuery({
     *     query: {
     *         address: address
     *     }
     * })
     * ```
     */
    useQuery<TData = GetBalancesData>(
      parameters: ServiceOperationQueryKey<GetBalancesSchema, GetBalancesParameters> | (DeepReadonly<GetBalancesParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetBalancesData, GetBalancesError, TData, ServiceOperationQueryKey<GetBalancesSchema, GetBalancesParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetBalancesError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get user balances
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getBalances.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             address: initialAddress
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetBalancesParameters, TData = GetBalancesData>(
      parameters: ServiceOperationInfiniteQueryKey<GetBalancesSchema, GetBalancesParameters> | (DeepReadonly<GetBalancesParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetBalancesData,
          GetBalancesError,
          OperationInfiniteData<TData, GetBalancesParameters>,
          GetBalancesData,
          ServiceOperationInfiniteQueryKey<GetBalancesSchema, GetBalancesParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetBalancesData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetBalancesParameters>, GetBalancesError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get user balances
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getBalancesData = qraft.v1Service.getBalances.useSuspenseQueries({
     *     queries: [
     *         {
     *             query: {
     *                 address: address1
     *             }
     *         },
     *         {
     *             query: {
     *                 address: address2
     *             }
     *         }
     *     ]
     * });
     * getBalancesResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getBalancesCombinedData = qraft.v1Service.getBalances.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 address: address1
     *             }
     *         },
     *         {
     *             query: {
     *                 address: address2
     *             }
     *         }
     *     ]
     * });
     * getBalancesCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetBalancesSchema, GetBalancesParameters, GetBalancesData, GetBalancesError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetBalancesData, GetBalancesError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetBalancesData, GetBalancesError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get user balances
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getBalances.useSuspenseQuery()
     * ```
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getBalances.useSuspenseQuery({
     *     query: {
     *         address: address
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetBalancesData>(
      parameters: ServiceOperationQueryKey<GetBalancesSchema, GetBalancesParameters> | (DeepReadonly<GetBalancesParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<GetBalancesData, GetBalancesError, TData, ServiceOperationQueryKey<GetBalancesSchema, GetBalancesParameters>>,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetBalancesError | Error>;
    schema: GetBalancesSchema;
    types: {
      parameters: GetBalancesParameters;
      data: GetBalancesData;
      error: GetBalancesError;
    };
  };
  /** @summary Get a list of providers. */
  getProviders: {
    /** @summary Get a list of providers. */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProvidersSchema, GetProvidersData, TInfinite, GetProvidersParameters, GetProvidersError>
        | QueryFiltersByQueryKey<GetProvidersSchema, GetProvidersData, TInfinite, GetProvidersParameters, GetProvidersError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get a list of providers. */
    getQueryKey(parameters: DeepReadonly<GetProvidersParameters> | void): ServiceOperationQueryKey<GetProvidersSchema, GetProvidersParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of providers.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviders.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviders.useQuery({
     *     query: {
     *         scope: scope
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProvidersData>(
      parameters: ServiceOperationQueryKey<GetProvidersSchema, GetProvidersParameters> | (DeepReadonly<GetProvidersParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetProvidersData, GetProvidersError, TData, ServiceOperationQueryKey<GetProvidersSchema, GetProvidersParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetProvidersError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of providers.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviders.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviders.useQuery({
     *     query: {
     *         scope: scope
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProvidersData>(
      parameters: ServiceOperationQueryKey<GetProvidersSchema, GetProvidersParameters> | (DeepReadonly<GetProvidersParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetProvidersData, GetProvidersError, TData, ServiceOperationQueryKey<GetProvidersSchema, GetProvidersParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetProvidersError | Error>;
    /** @summary Get a list of providers. */
    fetchInfiniteQuery<TPageParam extends GetProvidersParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetProvidersSchema,
        GetProvidersData,
        GetProvidersParameters,
        DeepReadonly<TPageParam>,
        GetProvidersError
      > | void
    ): Promise<OperationInfiniteData<GetProvidersData, GetProvidersParameters>>;
    /** @summary Get a list of providers. */
    prefetchInfiniteQuery<TPageParam extends GetProvidersParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetProvidersSchema,
        GetProvidersData,
        GetProvidersParameters,
        DeepReadonly<TPageParam>,
        GetProvidersError
      > | void
    ): Promise<void>;
    /** @summary Get a list of providers. */
    ensureInfiniteQueryData<TPageParam extends GetProvidersParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetProvidersSchema,
        GetProvidersData,
        GetProvidersParameters,
        DeepReadonly<TPageParam>,
        GetProvidersError
      > | void
    ): Promise<OperationInfiniteData<GetProvidersData, GetProvidersParameters>>;
    /** @summary Get a list of providers. */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetProvidersSchema, GetProvidersData, GetProvidersParameters, GetProvidersError> | void
    ): Promise<GetProvidersData>;
    /** @summary Get a list of providers. */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetProvidersSchema, GetProvidersData, GetProvidersParameters, GetProvidersError> | void
    ): Promise<void>;
    /** @summary Get a list of providers. */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetProvidersSchema, GetProvidersData, GetProvidersParameters, GetProvidersError> | void
    ): Promise<GetProvidersData>;
    /** @summary Get a list of providers. */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetProvidersSchema, GetProvidersParameters> | (DeepReadonly<GetProvidersParameters> | void)
    ): OperationInfiniteData<GetProvidersData, GetProvidersParameters> | undefined;
    /** @summary Get a list of providers. */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProvidersSchema, GetProvidersData, TInfinite, GetProvidersParameters, GetProvidersError>
        | QueryFiltersByQueryKey<GetProvidersSchema, GetProvidersData, TInfinite, GetProvidersParameters, GetProvidersError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetProvidersSchema, GetProvidersParameters>,
            data: NoInfer<OperationInfiniteData<GetProvidersData, GetProvidersParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetProvidersSchema, GetProvidersParameters>, data: GetProvidersData | undefined]>;
    /** @summary Get a list of providers. */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetProvidersSchema, GetProvidersParameters> | (DeepReadonly<GetProvidersParameters> | void)
    ): GetProvidersData | undefined;
    /** @summary Get a list of providers. */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetProvidersSchema, GetProvidersParameters> | (DeepReadonly<GetProvidersParameters> | void)
    ): QueryState<GetProvidersData, GetProvidersError> | undefined;
    /** @summary Get a list of providers. */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetProvidersParameters> | ServiceOperationInfiniteQueryKey<GetProvidersSchema, GetProvidersParameters> | void
    ): QueryState<OperationInfiniteData<GetProvidersData, GetProvidersParameters>, GetProvidersError> | undefined;
    /** @summary Get a list of providers. */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetProvidersSchema, GetProvidersData, TInfinite, GetProvidersParameters, GetProvidersError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get a list of providers. */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProvidersSchema, GetProvidersData, TInfinite, GetProvidersParameters, GetProvidersError>
        | QueryFiltersByQueryKey<GetProvidersSchema, GetProvidersData, TInfinite, GetProvidersParameters, GetProvidersError>
    ): number;
    /** @summary Get a list of providers. */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetProvidersSchema, GetProvidersParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetProvidersParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetProvidersSchema,
        options: {
          parameters: GetProvidersParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetProvidersData, GetProvidersError>>
    ): Promise<RequestFnResponse<GetProvidersData, GetProvidersError>>;
    /** @summary Get a list of providers. */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProvidersSchema, GetProvidersData, TInfinite, GetProvidersParameters, GetProvidersError>
        | QueryFiltersByQueryKey<GetProvidersSchema, GetProvidersData, TInfinite, GetProvidersParameters, GetProvidersError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get a list of providers. */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProvidersSchema, GetProvidersData, TInfinite, GetProvidersParameters, GetProvidersError>
        | QueryFiltersByQueryKey<GetProvidersSchema, GetProvidersData, TInfinite, GetProvidersParameters, GetProvidersError>
    ): void;
    /** @summary Get a list of providers. */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProvidersSchema, GetProvidersData, TInfinite, GetProvidersParameters, GetProvidersError>
        | QueryFiltersByQueryKey<GetProvidersSchema, GetProvidersData, TInfinite, GetProvidersParameters, GetProvidersError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get a list of providers. */
    setInfiniteQueryData(
      parameters: (DeepReadonly<GetProvidersParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetProvidersSchema, GetProvidersParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetProvidersData, GetProvidersParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetProvidersData, GetProvidersParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetProvidersData, GetProvidersParameters> | undefined;
    /** @summary Get a list of providers. */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetProvidersSchema, GetProvidersData, TInfinite, GetProvidersParameters, GetProvidersError>
        | QueryFiltersByQueryKey<GetProvidersSchema, GetProvidersData, TInfinite, GetProvidersParameters, GetProvidersError>,
      updater: Updater<NoInfer<GetProvidersData> | undefined, NoInfer<GetProvidersData> | undefined>,
      options?: SetDataOptions
    ): Array<GetProvidersData | undefined>;
    /** @summary Get a list of providers. */
    setQueryData(
      parameters: (DeepReadonly<GetProvidersParameters> | undefined) | ServiceOperationQueryKey<GetProvidersSchema, GetProvidersParameters>,
      updater: Updater<NoInfer<GetProvidersData> | undefined, NoInfer<DeepReadonly<GetProvidersData>> | undefined>,
      options?: SetDataOptions
    ): GetProvidersData | undefined;
    /** @summary Get a list of providers. */
    getInfiniteQueryKey(parameters: DeepReadonly<GetProvidersParameters> | void): ServiceOperationInfiniteQueryKey<GetProvidersSchema, GetProvidersParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of providers.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProviders.useInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             scope: initialScope
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetProvidersParameters,
      TQueryFnData = GetProvidersData,
      TData = OperationInfiniteData<TQueryFnData, GetProvidersParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetProvidersSchema, GetProvidersParameters> | (DeepReadonly<GetProvidersParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetProvidersError,
          TData,
          ServiceOperationInfiniteQueryKey<GetProvidersSchema, GetProvidersParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetProvidersError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of providers.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProviders.useInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             scope: initialScope
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetProvidersParameters,
      TQueryFnData = GetProvidersData,
      TData = OperationInfiniteData<TQueryFnData, GetProvidersParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetProvidersSchema, GetProvidersParameters> | (DeepReadonly<GetProvidersParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetProvidersError,
          TData,
          ServiceOperationInfiniteQueryKey<GetProvidersSchema, GetProvidersParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetProvidersData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetProvidersError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get a list of providers.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getProvidersTotal = qraft.v1Service.getProviders.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getProvidersByParametersTotal = qraft.v1Service.getProviders.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         query: {
     *             scope: scope
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProvidersSchema, GetProvidersData, TInfinite, GetProvidersParameters, GetProvidersError>
        | QueryFiltersByQueryKey<GetProvidersSchema, GetProvidersData, TInfinite, GetProvidersParameters, GetProvidersError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get a list of providers.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getProvidersResults = qraft.v1Service.getProviders.useQueries({
     *     queries: [
     *         {
     *             query: {
     *                 scope: scope1
     *             }
     *         },
     *         {
     *             query: {
     *                 scope: scope2
     *             }
     *         }
     *     ]
     * });
     * getProvidersResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getProvidersCombinedResults = qraft.v1Service.getProviders.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 scope: scope1
     *             }
     *         },
     *         {
     *             query: {
     *                 scope: scope2
     *             }
     *         }
     *     ]
     * });
     * getProvidersCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetProvidersSchema, GetProvidersParameters, GetProvidersData, GetProvidersError>>,
      TCombinedResult = Array<UseQueryResult<GetProvidersData, GetProvidersError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetProvidersData, GetProvidersError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get a list of providers. */
    getQueryKey(parameters: DeepReadonly<GetProvidersParameters> | void): ServiceOperationQueryKey<GetProvidersSchema, GetProvidersParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of providers.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviders.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviders.useQuery({
     *     query: {
     *         scope: scope
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProvidersData>(
      parameters: ServiceOperationQueryKey<GetProvidersSchema, GetProvidersParameters> | (DeepReadonly<GetProvidersParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetProvidersData, GetProvidersError, TData, ServiceOperationQueryKey<GetProvidersSchema, GetProvidersParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetProvidersError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of providers.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviders.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviders.useQuery({
     *     query: {
     *         scope: scope
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProvidersData>(
      parameters: ServiceOperationQueryKey<GetProvidersSchema, GetProvidersParameters> | (DeepReadonly<GetProvidersParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetProvidersData, GetProvidersError, TData, ServiceOperationQueryKey<GetProvidersSchema, GetProvidersParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetProvidersError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get a list of providers.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProviders.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             scope: initialScope
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetProvidersParameters, TData = GetProvidersData>(
      parameters: ServiceOperationInfiniteQueryKey<GetProvidersSchema, GetProvidersParameters> | (DeepReadonly<GetProvidersParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetProvidersData,
          GetProvidersError,
          OperationInfiniteData<TData, GetProvidersParameters>,
          GetProvidersData,
          ServiceOperationInfiniteQueryKey<GetProvidersSchema, GetProvidersParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetProvidersData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetProvidersParameters>, GetProvidersError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get a list of providers.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getProvidersData = qraft.v1Service.getProviders.useSuspenseQueries({
     *     queries: [
     *         {
     *             query: {
     *                 scope: scope1
     *             }
     *         },
     *         {
     *             query: {
     *                 scope: scope2
     *             }
     *         }
     *     ]
     * });
     * getProvidersResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getProvidersCombinedData = qraft.v1Service.getProviders.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 scope: scope1
     *             }
     *         },
     *         {
     *             query: {
     *                 scope: scope2
     *             }
     *         }
     *     ]
     * });
     * getProvidersCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetProvidersSchema, GetProvidersParameters, GetProvidersData, GetProvidersError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetProvidersData, GetProvidersError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetProvidersData, GetProvidersError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get a list of providers.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getProviders.useSuspenseQuery()
     * ```
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getProviders.useSuspenseQuery({
     *     query: {
     *         scope: scope
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetProvidersData>(
      parameters: ServiceOperationQueryKey<GetProvidersSchema, GetProvidersParameters> | (DeepReadonly<GetProvidersParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<GetProvidersData, GetProvidersError, TData, ServiceOperationQueryKey<GetProvidersSchema, GetProvidersParameters>>,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetProvidersError | Error>;
    schema: GetProvidersSchema;
    types: {
      parameters: GetProvidersParameters;
      data: GetProvidersData;
      error: GetProvidersError;
    };
  };
  /** @summary Get a provider details. */
  getProvidersAddress: {
    /** @summary Get a provider details. */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProvidersAddressSchema, GetProvidersAddressData, TInfinite, GetProvidersAddressParameters, GetProvidersAddressError>
        | QueryFiltersByQueryKey<GetProvidersAddressSchema, GetProvidersAddressData, TInfinite, GetProvidersAddressParameters, GetProvidersAddressError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get a provider details. */
    getQueryKey(parameters: DeepReadonly<GetProvidersAddressParameters>): ServiceOperationQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a provider details.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProvidersAddress.useQuery({
     *     path: {
     *         address: address
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProvidersAddressData>(
      parameters: ServiceOperationQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters> | DeepReadonly<GetProvidersAddressParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetProvidersAddressData,
          GetProvidersAddressError,
          TData,
          ServiceOperationQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetProvidersAddressError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a provider details.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProvidersAddress.useQuery({
     *     path: {
     *         address: address
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProvidersAddressData>(
      parameters: ServiceOperationQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters> | DeepReadonly<GetProvidersAddressParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetProvidersAddressData,
          GetProvidersAddressError,
          TData,
          ServiceOperationQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetProvidersAddressError | Error>;
    /** @summary Get a provider details. */
    fetchInfiniteQuery<TPageParam extends GetProvidersAddressParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetProvidersAddressSchema,
        GetProvidersAddressData,
        GetProvidersAddressParameters,
        DeepReadonly<TPageParam>,
        GetProvidersAddressError
      >
    ): Promise<OperationInfiniteData<GetProvidersAddressData, GetProvidersAddressParameters>>;
    /** @summary Get a provider details. */
    prefetchInfiniteQuery<TPageParam extends GetProvidersAddressParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetProvidersAddressSchema,
        GetProvidersAddressData,
        GetProvidersAddressParameters,
        DeepReadonly<TPageParam>,
        GetProvidersAddressError
      >
    ): Promise<void>;
    /** @summary Get a provider details. */
    ensureInfiniteQueryData<TPageParam extends GetProvidersAddressParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetProvidersAddressSchema,
        GetProvidersAddressData,
        GetProvidersAddressParameters,
        DeepReadonly<TPageParam>,
        GetProvidersAddressError
      >
    ): Promise<OperationInfiniteData<GetProvidersAddressData, GetProvidersAddressParameters>>;
    /** @summary Get a provider details. */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetProvidersAddressSchema, GetProvidersAddressData, GetProvidersAddressParameters, GetProvidersAddressError>
    ): Promise<GetProvidersAddressData>;
    /** @summary Get a provider details. */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetProvidersAddressSchema, GetProvidersAddressData, GetProvidersAddressParameters, GetProvidersAddressError>
    ): Promise<void>;
    /** @summary Get a provider details. */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetProvidersAddressSchema,
        GetProvidersAddressData,
        GetProvidersAddressParameters,
        GetProvidersAddressError
      >
    ): Promise<GetProvidersAddressData>;
    /** @summary Get a provider details. */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters> | DeepReadonly<GetProvidersAddressParameters>
    ): OperationInfiniteData<GetProvidersAddressData, GetProvidersAddressParameters> | undefined;
    /** @summary Get a provider details. */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProvidersAddressSchema, GetProvidersAddressData, TInfinite, GetProvidersAddressParameters, GetProvidersAddressError>
        | QueryFiltersByQueryKey<GetProvidersAddressSchema, GetProvidersAddressData, TInfinite, GetProvidersAddressParameters, GetProvidersAddressError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters>,
            data: NoInfer<OperationInfiniteData<GetProvidersAddressData, GetProvidersAddressParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters>, data: GetProvidersAddressData | undefined]>;
    /** @summary Get a provider details. */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters> | DeepReadonly<GetProvidersAddressParameters>
    ): GetProvidersAddressData | undefined;
    /** @summary Get a provider details. */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters> | DeepReadonly<GetProvidersAddressParameters>
    ): QueryState<GetProvidersAddressData, GetProvidersAddressError> | undefined;
    /** @summary Get a provider details. */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetProvidersAddressParameters> | ServiceOperationInfiniteQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters>
    ): QueryState<OperationInfiniteData<GetProvidersAddressData, GetProvidersAddressParameters>, GetProvidersAddressError> | undefined;
    /** @summary Get a provider details. */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetProvidersAddressSchema, GetProvidersAddressData, TInfinite, GetProvidersAddressParameters, GetProvidersAddressError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get a provider details. */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProvidersAddressSchema, GetProvidersAddressData, TInfinite, GetProvidersAddressParameters, GetProvidersAddressError>
        | QueryFiltersByQueryKey<GetProvidersAddressSchema, GetProvidersAddressData, TInfinite, GetProvidersAddressParameters, GetProvidersAddressError>
    ): number;
    /** @summary Get a provider details. */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetProvidersAddressParameters, TMeta, TSignal>,
      client?: (
        schema: GetProvidersAddressSchema,
        options: {
          parameters: GetProvidersAddressParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetProvidersAddressData, GetProvidersAddressError>>
    ): Promise<RequestFnResponse<GetProvidersAddressData, GetProvidersAddressError>>;
    /** @summary Get a provider details. */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProvidersAddressSchema, GetProvidersAddressData, TInfinite, GetProvidersAddressParameters, GetProvidersAddressError>
        | QueryFiltersByQueryKey<GetProvidersAddressSchema, GetProvidersAddressData, TInfinite, GetProvidersAddressParameters, GetProvidersAddressError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get a provider details. */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProvidersAddressSchema, GetProvidersAddressData, TInfinite, GetProvidersAddressParameters, GetProvidersAddressError>
        | QueryFiltersByQueryKey<GetProvidersAddressSchema, GetProvidersAddressData, TInfinite, GetProvidersAddressParameters, GetProvidersAddressError>
    ): void;
    /** @summary Get a provider details. */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProvidersAddressSchema, GetProvidersAddressData, TInfinite, GetProvidersAddressParameters, GetProvidersAddressError>
        | QueryFiltersByQueryKey<GetProvidersAddressSchema, GetProvidersAddressData, TInfinite, GetProvidersAddressParameters, GetProvidersAddressError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get a provider details. */
    setInfiniteQueryData(
      parameters: DeepReadonly<GetProvidersAddressParameters> | ServiceOperationInfiniteQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetProvidersAddressData, GetProvidersAddressParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetProvidersAddressData, GetProvidersAddressParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetProvidersAddressData, GetProvidersAddressParameters> | undefined;
    /** @summary Get a provider details. */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetProvidersAddressSchema, GetProvidersAddressData, TInfinite, GetProvidersAddressParameters, GetProvidersAddressError>
        | QueryFiltersByQueryKey<GetProvidersAddressSchema, GetProvidersAddressData, TInfinite, GetProvidersAddressParameters, GetProvidersAddressError>,
      updater: Updater<NoInfer<GetProvidersAddressData> | undefined, NoInfer<GetProvidersAddressData> | undefined>,
      options?: SetDataOptions
    ): Array<GetProvidersAddressData | undefined>;
    /** @summary Get a provider details. */
    setQueryData(
      parameters: DeepReadonly<GetProvidersAddressParameters> | ServiceOperationQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters>,
      updater: Updater<NoInfer<GetProvidersAddressData> | undefined, NoInfer<DeepReadonly<GetProvidersAddressData>> | undefined>,
      options?: SetDataOptions
    ): GetProvidersAddressData | undefined;
    /** @summary Get a provider details. */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetProvidersAddressParameters>
    ): ServiceOperationInfiniteQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a provider details.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProvidersAddress.useInfiniteQuery({
     *     path: {
     *         address: address
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetProvidersAddressParameters,
      TQueryFnData = GetProvidersAddressData,
      TData = OperationInfiniteData<TQueryFnData, GetProvidersAddressParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters> | DeepReadonly<GetProvidersAddressParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetProvidersAddressError,
          TData,
          ServiceOperationInfiniteQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetProvidersAddressError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a provider details.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProvidersAddress.useInfiniteQuery({
     *     path: {
     *         address: address
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetProvidersAddressParameters,
      TQueryFnData = GetProvidersAddressData,
      TData = OperationInfiniteData<TQueryFnData, GetProvidersAddressParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters> | DeepReadonly<GetProvidersAddressParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetProvidersAddressError,
          TData,
          ServiceOperationInfiniteQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetProvidersAddressData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetProvidersAddressError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get a provider details.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getProvidersAddressTotal = qraft.v1Service.getProvidersAddress.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getProvidersAddressByParametersTotal = qraft.v1Service.getProvidersAddress.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             address: address
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProvidersAddressSchema, GetProvidersAddressData, TInfinite, GetProvidersAddressParameters, GetProvidersAddressError>
        | QueryFiltersByQueryKey<GetProvidersAddressSchema, GetProvidersAddressData, TInfinite, GetProvidersAddressParameters, GetProvidersAddressError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get a provider details.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getProvidersAddressResults = qraft.v1Service.getProvidersAddress.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 address: address1
     *             }
     *         },
     *         {
     *             path: {
     *                 address: address2
     *             }
     *         }
     *     ]
     * });
     * getProvidersAddressResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getProvidersAddressCombinedResults = qraft.v1Service.getProvidersAddress.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 address: address1
     *             }
     *         },
     *         {
     *             path: {
     *                 address: address2
     *             }
     *         }
     *     ]
     * });
     * getProvidersAddressCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<GetProvidersAddressSchema, GetProvidersAddressParameters, GetProvidersAddressData, GetProvidersAddressError>
      >,
      TCombinedResult = Array<UseQueryResult<GetProvidersAddressData, GetProvidersAddressError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetProvidersAddressData, GetProvidersAddressError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get a provider details. */
    getQueryKey(parameters: DeepReadonly<GetProvidersAddressParameters>): ServiceOperationQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a provider details.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProvidersAddress.useQuery({
     *     path: {
     *         address: address
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProvidersAddressData>(
      parameters: ServiceOperationQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters> | DeepReadonly<GetProvidersAddressParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetProvidersAddressData,
          GetProvidersAddressError,
          TData,
          ServiceOperationQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetProvidersAddressError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a provider details.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProvidersAddress.useQuery({
     *     path: {
     *         address: address
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProvidersAddressData>(
      parameters: ServiceOperationQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters> | DeepReadonly<GetProvidersAddressParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetProvidersAddressData,
          GetProvidersAddressError,
          TData,
          ServiceOperationQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetProvidersAddressError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get a provider details.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProvidersAddress.useSuspenseInfiniteQuery({
     *     path: {
     *         address: address
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetProvidersAddressParameters, TData = GetProvidersAddressData>(
      parameters: ServiceOperationInfiniteQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters> | DeepReadonly<GetProvidersAddressParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetProvidersAddressData,
          GetProvidersAddressError,
          OperationInfiniteData<TData, GetProvidersAddressParameters>,
          GetProvidersAddressData,
          ServiceOperationInfiniteQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetProvidersAddressData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetProvidersAddressParameters>, GetProvidersAddressError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get a provider details.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getProvidersAddressData = qraft.v1Service.getProvidersAddress.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 address: address1
     *             }
     *         },
     *         {
     *             path: {
     *                 address: address2
     *             }
     *         }
     *     ]
     * });
     * getProvidersAddressResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getProvidersAddressCombinedData = qraft.v1Service.getProvidersAddress.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 address: address1
     *             }
     *         },
     *         {
     *             path: {
     *                 address: address2
     *             }
     *         }
     *     ]
     * });
     * getProvidersAddressCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<GetProvidersAddressSchema, GetProvidersAddressParameters, GetProvidersAddressData, GetProvidersAddressError>
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetProvidersAddressData, GetProvidersAddressError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetProvidersAddressData, GetProvidersAddressError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get a provider details.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getProvidersAddress.useSuspenseQuery({
     *     path: {
     *         address: address
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetProvidersAddressData>(
      parameters: ServiceOperationQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters> | DeepReadonly<GetProvidersAddressParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<
          GetProvidersAddressData,
          GetProvidersAddressError,
          TData,
          ServiceOperationQueryKey<GetProvidersAddressSchema, GetProvidersAddressParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetProvidersAddressError | Error>;
    schema: GetProvidersAddressSchema;
    types: {
      parameters: GetProvidersAddressParameters;
      data: GetProvidersAddressData;
      error: GetProvidersAddressError;
    };
  };
  getProvidersProviderAddressActiveLeasesGraphData: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProvidersProviderAddressActiveLeasesGraphDataSchema,
            GetProvidersProviderAddressActiveLeasesGraphDataData,
            TInfinite,
            GetProvidersProviderAddressActiveLeasesGraphDataParameters,
            GetProvidersProviderAddressActiveLeasesGraphDataError
          >
        | QueryFiltersByQueryKey<
            GetProvidersProviderAddressActiveLeasesGraphDataSchema,
            GetProvidersProviderAddressActiveLeasesGraphDataData,
            TInfinite,
            GetProvidersProviderAddressActiveLeasesGraphDataParameters,
            GetProvidersProviderAddressActiveLeasesGraphDataError
          >,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(
      parameters: DeepReadonly<GetProvidersProviderAddressActiveLeasesGraphDataParameters>
    ): ServiceOperationQueryKey<GetProvidersProviderAddressActiveLeasesGraphDataSchema, GetProvidersProviderAddressActiveLeasesGraphDataParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProvidersProviderAddressActiveLeasesGraphData.useQuery({
     *     path: {
     *         providerAddress: providerAddress
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProvidersProviderAddressActiveLeasesGraphDataData>(
      parameters:
        | ServiceOperationQueryKey<GetProvidersProviderAddressActiveLeasesGraphDataSchema, GetProvidersProviderAddressActiveLeasesGraphDataParameters>
        | DeepReadonly<GetProvidersProviderAddressActiveLeasesGraphDataParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetProvidersProviderAddressActiveLeasesGraphDataData,
          GetProvidersProviderAddressActiveLeasesGraphDataError,
          TData,
          ServiceOperationQueryKey<GetProvidersProviderAddressActiveLeasesGraphDataSchema, GetProvidersProviderAddressActiveLeasesGraphDataParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetProvidersProviderAddressActiveLeasesGraphDataError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProvidersProviderAddressActiveLeasesGraphData.useQuery({
     *     path: {
     *         providerAddress: providerAddress
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProvidersProviderAddressActiveLeasesGraphDataData>(
      parameters:
        | ServiceOperationQueryKey<GetProvidersProviderAddressActiveLeasesGraphDataSchema, GetProvidersProviderAddressActiveLeasesGraphDataParameters>
        | DeepReadonly<GetProvidersProviderAddressActiveLeasesGraphDataParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetProvidersProviderAddressActiveLeasesGraphDataData,
          GetProvidersProviderAddressActiveLeasesGraphDataError,
          TData,
          ServiceOperationQueryKey<GetProvidersProviderAddressActiveLeasesGraphDataSchema, GetProvidersProviderAddressActiveLeasesGraphDataParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetProvidersProviderAddressActiveLeasesGraphDataError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetProvidersProviderAddressActiveLeasesGraphDataParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetProvidersProviderAddressActiveLeasesGraphDataSchema,
        GetProvidersProviderAddressActiveLeasesGraphDataData,
        GetProvidersProviderAddressActiveLeasesGraphDataParameters,
        DeepReadonly<TPageParam>,
        GetProvidersProviderAddressActiveLeasesGraphDataError
      >
    ): Promise<OperationInfiniteData<GetProvidersProviderAddressActiveLeasesGraphDataData, GetProvidersProviderAddressActiveLeasesGraphDataParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetProvidersProviderAddressActiveLeasesGraphDataParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetProvidersProviderAddressActiveLeasesGraphDataSchema,
        GetProvidersProviderAddressActiveLeasesGraphDataData,
        GetProvidersProviderAddressActiveLeasesGraphDataParameters,
        DeepReadonly<TPageParam>,
        GetProvidersProviderAddressActiveLeasesGraphDataError
      >
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetProvidersProviderAddressActiveLeasesGraphDataParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetProvidersProviderAddressActiveLeasesGraphDataSchema,
        GetProvidersProviderAddressActiveLeasesGraphDataData,
        GetProvidersProviderAddressActiveLeasesGraphDataParameters,
        DeepReadonly<TPageParam>,
        GetProvidersProviderAddressActiveLeasesGraphDataError
      >
    ): Promise<OperationInfiniteData<GetProvidersProviderAddressActiveLeasesGraphDataData, GetProvidersProviderAddressActiveLeasesGraphDataParameters>>;
    /**/
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetProvidersProviderAddressActiveLeasesGraphDataSchema,
        GetProvidersProviderAddressActiveLeasesGraphDataData,
        GetProvidersProviderAddressActiveLeasesGraphDataParameters,
        GetProvidersProviderAddressActiveLeasesGraphDataError
      >
    ): Promise<GetProvidersProviderAddressActiveLeasesGraphDataData>;
    /**/
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetProvidersProviderAddressActiveLeasesGraphDataSchema,
        GetProvidersProviderAddressActiveLeasesGraphDataData,
        GetProvidersProviderAddressActiveLeasesGraphDataParameters,
        GetProvidersProviderAddressActiveLeasesGraphDataError
      >
    ): Promise<void>;
    /**/
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetProvidersProviderAddressActiveLeasesGraphDataSchema,
        GetProvidersProviderAddressActiveLeasesGraphDataData,
        GetProvidersProviderAddressActiveLeasesGraphDataParameters,
        GetProvidersProviderAddressActiveLeasesGraphDataError
      >
    ): Promise<GetProvidersProviderAddressActiveLeasesGraphDataData>;
    /**/
    getInfiniteQueryData(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProvidersProviderAddressActiveLeasesGraphDataSchema, GetProvidersProviderAddressActiveLeasesGraphDataParameters>
        | DeepReadonly<GetProvidersProviderAddressActiveLeasesGraphDataParameters>
    ): OperationInfiniteData<GetProvidersProviderAddressActiveLeasesGraphDataData, GetProvidersProviderAddressActiveLeasesGraphDataParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProvidersProviderAddressActiveLeasesGraphDataSchema,
            GetProvidersProviderAddressActiveLeasesGraphDataData,
            TInfinite,
            GetProvidersProviderAddressActiveLeasesGraphDataParameters,
            GetProvidersProviderAddressActiveLeasesGraphDataError
          >
        | QueryFiltersByQueryKey<
            GetProvidersProviderAddressActiveLeasesGraphDataSchema,
            GetProvidersProviderAddressActiveLeasesGraphDataData,
            TInfinite,
            GetProvidersProviderAddressActiveLeasesGraphDataParameters,
            GetProvidersProviderAddressActiveLeasesGraphDataError
          >
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<
              GetProvidersProviderAddressActiveLeasesGraphDataSchema,
              GetProvidersProviderAddressActiveLeasesGraphDataParameters
            >,
            data:
              | NoInfer<OperationInfiniteData<GetProvidersProviderAddressActiveLeasesGraphDataData, GetProvidersProviderAddressActiveLeasesGraphDataParameters>>
              | undefined
          ]
        >
      : Array<
          [
            queryKey: ServiceOperationQueryKey<
              GetProvidersProviderAddressActiveLeasesGraphDataSchema,
              GetProvidersProviderAddressActiveLeasesGraphDataParameters
            >,
            data: GetProvidersProviderAddressActiveLeasesGraphDataData | undefined
          ]
        >;
    /**/
    getQueryData(
      parameters:
        | ServiceOperationQueryKey<GetProvidersProviderAddressActiveLeasesGraphDataSchema, GetProvidersProviderAddressActiveLeasesGraphDataParameters>
        | DeepReadonly<GetProvidersProviderAddressActiveLeasesGraphDataParameters>
    ): GetProvidersProviderAddressActiveLeasesGraphDataData | undefined;
    /**/
    getQueryState(
      parameters:
        | ServiceOperationQueryKey<GetProvidersProviderAddressActiveLeasesGraphDataSchema, GetProvidersProviderAddressActiveLeasesGraphDataParameters>
        | DeepReadonly<GetProvidersProviderAddressActiveLeasesGraphDataParameters>
    ): QueryState<GetProvidersProviderAddressActiveLeasesGraphDataData, GetProvidersProviderAddressActiveLeasesGraphDataError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters:
        | DeepReadonly<GetProvidersProviderAddressActiveLeasesGraphDataParameters>
        | ServiceOperationInfiniteQueryKey<GetProvidersProviderAddressActiveLeasesGraphDataSchema, GetProvidersProviderAddressActiveLeasesGraphDataParameters>
    ):
      | QueryState<
          OperationInfiniteData<GetProvidersProviderAddressActiveLeasesGraphDataData, GetProvidersProviderAddressActiveLeasesGraphDataParameters>,
          GetProvidersProviderAddressActiveLeasesGraphDataError
        >
      | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<
        GetProvidersProviderAddressActiveLeasesGraphDataSchema,
        GetProvidersProviderAddressActiveLeasesGraphDataData,
        TInfinite,
        GetProvidersProviderAddressActiveLeasesGraphDataParameters,
        GetProvidersProviderAddressActiveLeasesGraphDataError
      >,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProvidersProviderAddressActiveLeasesGraphDataSchema,
            GetProvidersProviderAddressActiveLeasesGraphDataData,
            TInfinite,
            GetProvidersProviderAddressActiveLeasesGraphDataParameters,
            GetProvidersProviderAddressActiveLeasesGraphDataError
          >
        | QueryFiltersByQueryKey<
            GetProvidersProviderAddressActiveLeasesGraphDataSchema,
            GetProvidersProviderAddressActiveLeasesGraphDataData,
            TInfinite,
            GetProvidersProviderAddressActiveLeasesGraphDataParameters,
            GetProvidersProviderAddressActiveLeasesGraphDataError
          >
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<
            GetProvidersProviderAddressActiveLeasesGraphDataSchema,
            GetProvidersProviderAddressActiveLeasesGraphDataParameters,
            TMeta,
            TSignal
          >
        | QueryFnOptionsByParameters<GetProvidersProviderAddressActiveLeasesGraphDataParameters, TMeta, TSignal>,
      client?: (
        schema: GetProvidersProviderAddressActiveLeasesGraphDataSchema,
        options: {
          parameters: GetProvidersProviderAddressActiveLeasesGraphDataParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetProvidersProviderAddressActiveLeasesGraphDataData, GetProvidersProviderAddressActiveLeasesGraphDataError>>
    ): Promise<RequestFnResponse<GetProvidersProviderAddressActiveLeasesGraphDataData, GetProvidersProviderAddressActiveLeasesGraphDataError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProvidersProviderAddressActiveLeasesGraphDataSchema,
            GetProvidersProviderAddressActiveLeasesGraphDataData,
            TInfinite,
            GetProvidersProviderAddressActiveLeasesGraphDataParameters,
            GetProvidersProviderAddressActiveLeasesGraphDataError
          >
        | QueryFiltersByQueryKey<
            GetProvidersProviderAddressActiveLeasesGraphDataSchema,
            GetProvidersProviderAddressActiveLeasesGraphDataData,
            TInfinite,
            GetProvidersProviderAddressActiveLeasesGraphDataParameters,
            GetProvidersProviderAddressActiveLeasesGraphDataError
          >,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProvidersProviderAddressActiveLeasesGraphDataSchema,
            GetProvidersProviderAddressActiveLeasesGraphDataData,
            TInfinite,
            GetProvidersProviderAddressActiveLeasesGraphDataParameters,
            GetProvidersProviderAddressActiveLeasesGraphDataError
          >
        | QueryFiltersByQueryKey<
            GetProvidersProviderAddressActiveLeasesGraphDataSchema,
            GetProvidersProviderAddressActiveLeasesGraphDataData,
            TInfinite,
            GetProvidersProviderAddressActiveLeasesGraphDataParameters,
            GetProvidersProviderAddressActiveLeasesGraphDataError
          >
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProvidersProviderAddressActiveLeasesGraphDataSchema,
            GetProvidersProviderAddressActiveLeasesGraphDataData,
            TInfinite,
            GetProvidersProviderAddressActiveLeasesGraphDataParameters,
            GetProvidersProviderAddressActiveLeasesGraphDataError
          >
        | QueryFiltersByQueryKey<
            GetProvidersProviderAddressActiveLeasesGraphDataSchema,
            GetProvidersProviderAddressActiveLeasesGraphDataData,
            TInfinite,
            GetProvidersProviderAddressActiveLeasesGraphDataParameters,
            GetProvidersProviderAddressActiveLeasesGraphDataError
          >,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters:
        | DeepReadonly<GetProvidersProviderAddressActiveLeasesGraphDataParameters>
        | ServiceOperationInfiniteQueryKey<GetProvidersProviderAddressActiveLeasesGraphDataSchema, GetProvidersProviderAddressActiveLeasesGraphDataParameters>,
      updater: Updater<
        | NoInfer<OperationInfiniteData<GetProvidersProviderAddressActiveLeasesGraphDataData, GetProvidersProviderAddressActiveLeasesGraphDataParameters>>
        | undefined,
        | NoInfer<
            DeepReadonly<
              OperationInfiniteData<GetProvidersProviderAddressActiveLeasesGraphDataData, GetProvidersProviderAddressActiveLeasesGraphDataParameters>
            >
          >
        | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetProvidersProviderAddressActiveLeasesGraphDataData, GetProvidersProviderAddressActiveLeasesGraphDataParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<
            GetProvidersProviderAddressActiveLeasesGraphDataSchema,
            GetProvidersProviderAddressActiveLeasesGraphDataData,
            TInfinite,
            GetProvidersProviderAddressActiveLeasesGraphDataParameters,
            GetProvidersProviderAddressActiveLeasesGraphDataError
          >
        | QueryFiltersByQueryKey<
            GetProvidersProviderAddressActiveLeasesGraphDataSchema,
            GetProvidersProviderAddressActiveLeasesGraphDataData,
            TInfinite,
            GetProvidersProviderAddressActiveLeasesGraphDataParameters,
            GetProvidersProviderAddressActiveLeasesGraphDataError
          >,
      updater: Updater<
        NoInfer<GetProvidersProviderAddressActiveLeasesGraphDataData> | undefined,
        NoInfer<GetProvidersProviderAddressActiveLeasesGraphDataData> | undefined
      >,
      options?: SetDataOptions
    ): Array<GetProvidersProviderAddressActiveLeasesGraphDataData | undefined>;
    /**/
    setQueryData(
      parameters:
        | DeepReadonly<GetProvidersProviderAddressActiveLeasesGraphDataParameters>
        | ServiceOperationQueryKey<GetProvidersProviderAddressActiveLeasesGraphDataSchema, GetProvidersProviderAddressActiveLeasesGraphDataParameters>,
      updater: Updater<
        NoInfer<GetProvidersProviderAddressActiveLeasesGraphDataData> | undefined,
        NoInfer<DeepReadonly<GetProvidersProviderAddressActiveLeasesGraphDataData>> | undefined
      >,
      options?: SetDataOptions
    ): GetProvidersProviderAddressActiveLeasesGraphDataData | undefined;
    /**/
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetProvidersProviderAddressActiveLeasesGraphDataParameters>
    ): ServiceOperationInfiniteQueryKey<GetProvidersProviderAddressActiveLeasesGraphDataSchema, GetProvidersProviderAddressActiveLeasesGraphDataParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProvidersProviderAddressActiveLeasesGraphData.useInfiniteQuery({
     *     path: {
     *         providerAddress: providerAddress
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetProvidersProviderAddressActiveLeasesGraphDataParameters,
      TQueryFnData = GetProvidersProviderAddressActiveLeasesGraphDataData,
      TData = OperationInfiniteData<TQueryFnData, GetProvidersProviderAddressActiveLeasesGraphDataParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProvidersProviderAddressActiveLeasesGraphDataSchema, GetProvidersProviderAddressActiveLeasesGraphDataParameters>
        | DeepReadonly<GetProvidersProviderAddressActiveLeasesGraphDataParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetProvidersProviderAddressActiveLeasesGraphDataError,
          TData,
          ServiceOperationInfiniteQueryKey<GetProvidersProviderAddressActiveLeasesGraphDataSchema, GetProvidersProviderAddressActiveLeasesGraphDataParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetProvidersProviderAddressActiveLeasesGraphDataError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProvidersProviderAddressActiveLeasesGraphData.useInfiniteQuery({
     *     path: {
     *         providerAddress: providerAddress
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetProvidersProviderAddressActiveLeasesGraphDataParameters,
      TQueryFnData = GetProvidersProviderAddressActiveLeasesGraphDataData,
      TData = OperationInfiniteData<TQueryFnData, GetProvidersProviderAddressActiveLeasesGraphDataParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProvidersProviderAddressActiveLeasesGraphDataSchema, GetProvidersProviderAddressActiveLeasesGraphDataParameters>
        | DeepReadonly<GetProvidersProviderAddressActiveLeasesGraphDataParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetProvidersProviderAddressActiveLeasesGraphDataError,
          TData,
          ServiceOperationInfiniteQueryKey<GetProvidersProviderAddressActiveLeasesGraphDataSchema, GetProvidersProviderAddressActiveLeasesGraphDataParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetProvidersProviderAddressActiveLeasesGraphDataData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetProvidersProviderAddressActiveLeasesGraphDataError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getProvidersProviderAddressActiveLeasesGraphDataTotal = qraft.v1Service.getProvidersProviderAddressActiveLeasesGraphData.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getProvidersProviderAddressActiveLeasesGraphDataByParametersTotal = qraft.v1Service.getProvidersProviderAddressActiveLeasesGraphData.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             providerAddress: providerAddress
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProvidersProviderAddressActiveLeasesGraphDataSchema,
            GetProvidersProviderAddressActiveLeasesGraphDataData,
            TInfinite,
            GetProvidersProviderAddressActiveLeasesGraphDataParameters,
            GetProvidersProviderAddressActiveLeasesGraphDataError
          >
        | QueryFiltersByQueryKey<
            GetProvidersProviderAddressActiveLeasesGraphDataSchema,
            GetProvidersProviderAddressActiveLeasesGraphDataData,
            TInfinite,
            GetProvidersProviderAddressActiveLeasesGraphDataParameters,
            GetProvidersProviderAddressActiveLeasesGraphDataError
          >
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getProvidersProviderAddressActiveLeasesGraphDataResults = qraft.v1Service.getProvidersProviderAddressActiveLeasesGraphData.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 providerAddress: providerAddress1
     *             }
     *         },
     *         {
     *             path: {
     *                 providerAddress: providerAddress2
     *             }
     *         }
     *     ]
     * });
     * getProvidersProviderAddressActiveLeasesGraphDataResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getProvidersProviderAddressActiveLeasesGraphDataCombinedResults = qraft.v1Service.getProvidersProviderAddressActiveLeasesGraphData.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 providerAddress: providerAddress1
     *             }
     *         },
     *         {
     *             path: {
     *                 providerAddress: providerAddress2
     *             }
     *         }
     *     ]
     * });
     * getProvidersProviderAddressActiveLeasesGraphDataCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<
          GetProvidersProviderAddressActiveLeasesGraphDataSchema,
          GetProvidersProviderAddressActiveLeasesGraphDataParameters,
          GetProvidersProviderAddressActiveLeasesGraphDataData,
          GetProvidersProviderAddressActiveLeasesGraphDataError
        >
      >,
      TCombinedResult = Array<UseQueryResult<GetProvidersProviderAddressActiveLeasesGraphDataData, GetProvidersProviderAddressActiveLeasesGraphDataError>>
    >(options: {
      queries: T;
      combine?: (
        results: Array<UseQueryResult<GetProvidersProviderAddressActiveLeasesGraphDataData, GetProvidersProviderAddressActiveLeasesGraphDataError>>
      ) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(
      parameters: DeepReadonly<GetProvidersProviderAddressActiveLeasesGraphDataParameters>
    ): ServiceOperationQueryKey<GetProvidersProviderAddressActiveLeasesGraphDataSchema, GetProvidersProviderAddressActiveLeasesGraphDataParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProvidersProviderAddressActiveLeasesGraphData.useQuery({
     *     path: {
     *         providerAddress: providerAddress
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProvidersProviderAddressActiveLeasesGraphDataData>(
      parameters:
        | ServiceOperationQueryKey<GetProvidersProviderAddressActiveLeasesGraphDataSchema, GetProvidersProviderAddressActiveLeasesGraphDataParameters>
        | DeepReadonly<GetProvidersProviderAddressActiveLeasesGraphDataParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetProvidersProviderAddressActiveLeasesGraphDataData,
          GetProvidersProviderAddressActiveLeasesGraphDataError,
          TData,
          ServiceOperationQueryKey<GetProvidersProviderAddressActiveLeasesGraphDataSchema, GetProvidersProviderAddressActiveLeasesGraphDataParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetProvidersProviderAddressActiveLeasesGraphDataError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProvidersProviderAddressActiveLeasesGraphData.useQuery({
     *     path: {
     *         providerAddress: providerAddress
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProvidersProviderAddressActiveLeasesGraphDataData>(
      parameters:
        | ServiceOperationQueryKey<GetProvidersProviderAddressActiveLeasesGraphDataSchema, GetProvidersProviderAddressActiveLeasesGraphDataParameters>
        | DeepReadonly<GetProvidersProviderAddressActiveLeasesGraphDataParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetProvidersProviderAddressActiveLeasesGraphDataData,
          GetProvidersProviderAddressActiveLeasesGraphDataError,
          TData,
          ServiceOperationQueryKey<GetProvidersProviderAddressActiveLeasesGraphDataSchema, GetProvidersProviderAddressActiveLeasesGraphDataParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetProvidersProviderAddressActiveLeasesGraphDataError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProvidersProviderAddressActiveLeasesGraphData.useSuspenseInfiniteQuery({
     *     path: {
     *         providerAddress: providerAddress
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<
      TPageParam extends GetProvidersProviderAddressActiveLeasesGraphDataParameters,
      TData = GetProvidersProviderAddressActiveLeasesGraphDataData
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProvidersProviderAddressActiveLeasesGraphDataSchema, GetProvidersProviderAddressActiveLeasesGraphDataParameters>
        | DeepReadonly<GetProvidersProviderAddressActiveLeasesGraphDataParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetProvidersProviderAddressActiveLeasesGraphDataData,
          GetProvidersProviderAddressActiveLeasesGraphDataError,
          OperationInfiniteData<TData, GetProvidersProviderAddressActiveLeasesGraphDataParameters>,
          GetProvidersProviderAddressActiveLeasesGraphDataData,
          ServiceOperationInfiniteQueryKey<GetProvidersProviderAddressActiveLeasesGraphDataSchema, GetProvidersProviderAddressActiveLeasesGraphDataParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetProvidersProviderAddressActiveLeasesGraphDataData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<
      OperationInfiniteData<TData, GetProvidersProviderAddressActiveLeasesGraphDataParameters>,
      GetProvidersProviderAddressActiveLeasesGraphDataError | Error
    >;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getProvidersProviderAddressActiveLeasesGraphDataData = qraft.v1Service.getProvidersProviderAddressActiveLeasesGraphData.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 providerAddress: providerAddress1
     *             }
     *         },
     *         {
     *             path: {
     *                 providerAddress: providerAddress2
     *             }
     *         }
     *     ]
     * });
     * getProvidersProviderAddressActiveLeasesGraphDataResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getProvidersProviderAddressActiveLeasesGraphDataCombinedData = qraft.v1Service.getProvidersProviderAddressActiveLeasesGraphData.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 providerAddress: providerAddress1
     *             }
     *         },
     *         {
     *             path: {
     *                 providerAddress: providerAddress2
     *             }
     *         }
     *     ]
     * });
     * getProvidersProviderAddressActiveLeasesGraphDataCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<
          GetProvidersProviderAddressActiveLeasesGraphDataSchema,
          GetProvidersProviderAddressActiveLeasesGraphDataParameters,
          GetProvidersProviderAddressActiveLeasesGraphDataData,
          GetProvidersProviderAddressActiveLeasesGraphDataError
        >
      >,
      TCombinedResult = Array<
        UseSuspenseQueryResult<GetProvidersProviderAddressActiveLeasesGraphDataData, GetProvidersProviderAddressActiveLeasesGraphDataError>
      >
    >(options: {
      queries: T;
      combine?: (
        results: Array<
          WithOptional<
            UseSuspenseQueryResult<GetProvidersProviderAddressActiveLeasesGraphDataData, GetProvidersProviderAddressActiveLeasesGraphDataError>,
            "data"
          >
        >
      ) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getProvidersProviderAddressActiveLeasesGraphData.useSuspenseQuery({
     *     path: {
     *         providerAddress: providerAddress
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetProvidersProviderAddressActiveLeasesGraphDataData>(
      parameters:
        | ServiceOperationQueryKey<GetProvidersProviderAddressActiveLeasesGraphDataSchema, GetProvidersProviderAddressActiveLeasesGraphDataParameters>
        | DeepReadonly<GetProvidersProviderAddressActiveLeasesGraphDataParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<
          GetProvidersProviderAddressActiveLeasesGraphDataData,
          GetProvidersProviderAddressActiveLeasesGraphDataError,
          TData,
          ServiceOperationQueryKey<GetProvidersProviderAddressActiveLeasesGraphDataSchema, GetProvidersProviderAddressActiveLeasesGraphDataParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetProvidersProviderAddressActiveLeasesGraphDataError | Error>;
    schema: GetProvidersProviderAddressActiveLeasesGraphDataSchema;
    types: {
      parameters: GetProvidersProviderAddressActiveLeasesGraphDataParameters;
      data: GetProvidersProviderAddressActiveLeasesGraphDataData;
      error: GetProvidersProviderAddressActiveLeasesGraphDataError;
    };
  };
  /** @summary Get a list of auditors. */
  getAuditors: {
    /** @summary Get a list of auditors. */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAuditorsSchema, GetAuditorsData, TInfinite, GetAuditorsParameters, GetAuditorsError>
        | QueryFiltersByQueryKey<GetAuditorsSchema, GetAuditorsData, TInfinite, GetAuditorsParameters, GetAuditorsError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get a list of auditors. */
    getQueryKey(parameters: DeepReadonly<GetAuditorsParameters> | void): ServiceOperationQueryKey<GetAuditorsSchema, GetAuditorsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of auditors.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAuditors.useQuery()
     * ```
     */
    useQuery<TData = GetAuditorsData>(
      parameters: ServiceOperationQueryKey<GetAuditorsSchema, GetAuditorsParameters> | (DeepReadonly<GetAuditorsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetAuditorsData, GetAuditorsError, TData, ServiceOperationQueryKey<GetAuditorsSchema, GetAuditorsParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetAuditorsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of auditors.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAuditors.useQuery()
     * ```
     */
    useQuery<TData = GetAuditorsData>(
      parameters: ServiceOperationQueryKey<GetAuditorsSchema, GetAuditorsParameters> | (DeepReadonly<GetAuditorsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetAuditorsData, GetAuditorsError, TData, ServiceOperationQueryKey<GetAuditorsSchema, GetAuditorsParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetAuditorsError | Error>;
    /** @summary Get a list of auditors. */
    fetchInfiniteQuery<TPageParam extends GetAuditorsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetAuditorsSchema,
        GetAuditorsData,
        GetAuditorsParameters,
        DeepReadonly<TPageParam>,
        GetAuditorsError
      > | void
    ): Promise<OperationInfiniteData<GetAuditorsData, GetAuditorsParameters>>;
    /** @summary Get a list of auditors. */
    prefetchInfiniteQuery<TPageParam extends GetAuditorsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetAuditorsSchema,
        GetAuditorsData,
        GetAuditorsParameters,
        DeepReadonly<TPageParam>,
        GetAuditorsError
      > | void
    ): Promise<void>;
    /** @summary Get a list of auditors. */
    ensureInfiniteQueryData<TPageParam extends GetAuditorsParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetAuditorsSchema,
        GetAuditorsData,
        GetAuditorsParameters,
        DeepReadonly<TPageParam>,
        GetAuditorsError
      > | void
    ): Promise<OperationInfiniteData<GetAuditorsData, GetAuditorsParameters>>;
    /** @summary Get a list of auditors. */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetAuditorsSchema, GetAuditorsData, GetAuditorsParameters, GetAuditorsError> | void
    ): Promise<GetAuditorsData>;
    /** @summary Get a list of auditors. */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetAuditorsSchema, GetAuditorsData, GetAuditorsParameters, GetAuditorsError> | void
    ): Promise<void>;
    /** @summary Get a list of auditors. */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetAuditorsSchema, GetAuditorsData, GetAuditorsParameters, GetAuditorsError> | void
    ): Promise<GetAuditorsData>;
    /** @summary Get a list of auditors. */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetAuditorsSchema, GetAuditorsParameters> | (DeepReadonly<GetAuditorsParameters> | void)
    ): OperationInfiniteData<GetAuditorsData, GetAuditorsParameters> | undefined;
    /** @summary Get a list of auditors. */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAuditorsSchema, GetAuditorsData, TInfinite, GetAuditorsParameters, GetAuditorsError>
        | QueryFiltersByQueryKey<GetAuditorsSchema, GetAuditorsData, TInfinite, GetAuditorsParameters, GetAuditorsError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetAuditorsSchema, GetAuditorsParameters>,
            data: NoInfer<OperationInfiniteData<GetAuditorsData, GetAuditorsParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetAuditorsSchema, GetAuditorsParameters>, data: GetAuditorsData | undefined]>;
    /** @summary Get a list of auditors. */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetAuditorsSchema, GetAuditorsParameters> | (DeepReadonly<GetAuditorsParameters> | void)
    ): GetAuditorsData | undefined;
    /** @summary Get a list of auditors. */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetAuditorsSchema, GetAuditorsParameters> | (DeepReadonly<GetAuditorsParameters> | void)
    ): QueryState<GetAuditorsData, GetAuditorsError> | undefined;
    /** @summary Get a list of auditors. */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetAuditorsParameters> | ServiceOperationInfiniteQueryKey<GetAuditorsSchema, GetAuditorsParameters> | void
    ): QueryState<OperationInfiniteData<GetAuditorsData, GetAuditorsParameters>, GetAuditorsError> | undefined;
    /** @summary Get a list of auditors. */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetAuditorsSchema, GetAuditorsData, TInfinite, GetAuditorsParameters, GetAuditorsError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get a list of auditors. */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAuditorsSchema, GetAuditorsData, TInfinite, GetAuditorsParameters, GetAuditorsError>
        | QueryFiltersByQueryKey<GetAuditorsSchema, GetAuditorsData, TInfinite, GetAuditorsParameters, GetAuditorsError>
    ): number;
    /** @summary Get a list of auditors. */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetAuditorsSchema, GetAuditorsParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetAuditorsParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetAuditorsSchema,
        options: {
          parameters: GetAuditorsParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetAuditorsData, GetAuditorsError>>
    ): Promise<RequestFnResponse<GetAuditorsData, GetAuditorsError>>;
    /** @summary Get a list of auditors. */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAuditorsSchema, GetAuditorsData, TInfinite, GetAuditorsParameters, GetAuditorsError>
        | QueryFiltersByQueryKey<GetAuditorsSchema, GetAuditorsData, TInfinite, GetAuditorsParameters, GetAuditorsError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get a list of auditors. */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAuditorsSchema, GetAuditorsData, TInfinite, GetAuditorsParameters, GetAuditorsError>
        | QueryFiltersByQueryKey<GetAuditorsSchema, GetAuditorsData, TInfinite, GetAuditorsParameters, GetAuditorsError>
    ): void;
    /** @summary Get a list of auditors. */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAuditorsSchema, GetAuditorsData, TInfinite, GetAuditorsParameters, GetAuditorsError>
        | QueryFiltersByQueryKey<GetAuditorsSchema, GetAuditorsData, TInfinite, GetAuditorsParameters, GetAuditorsError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get a list of auditors. */
    setInfiniteQueryData(
      parameters: (DeepReadonly<GetAuditorsParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetAuditorsSchema, GetAuditorsParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetAuditorsData, GetAuditorsParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetAuditorsData, GetAuditorsParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetAuditorsData, GetAuditorsParameters> | undefined;
    /** @summary Get a list of auditors. */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetAuditorsSchema, GetAuditorsData, TInfinite, GetAuditorsParameters, GetAuditorsError>
        | QueryFiltersByQueryKey<GetAuditorsSchema, GetAuditorsData, TInfinite, GetAuditorsParameters, GetAuditorsError>,
      updater: Updater<NoInfer<GetAuditorsData> | undefined, NoInfer<GetAuditorsData> | undefined>,
      options?: SetDataOptions
    ): Array<GetAuditorsData | undefined>;
    /** @summary Get a list of auditors. */
    setQueryData(
      parameters: (DeepReadonly<GetAuditorsParameters> | undefined) | ServiceOperationQueryKey<GetAuditorsSchema, GetAuditorsParameters>,
      updater: Updater<NoInfer<GetAuditorsData> | undefined, NoInfer<DeepReadonly<GetAuditorsData>> | undefined>,
      options?: SetDataOptions
    ): GetAuditorsData | undefined;
    /** @summary Get a list of auditors. */
    getInfiniteQueryKey(parameters: DeepReadonly<GetAuditorsParameters> | void): ServiceOperationInfiniteQueryKey<GetAuditorsSchema, GetAuditorsParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of auditors.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuditors.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetAuditorsParameters,
      TQueryFnData = GetAuditorsData,
      TData = OperationInfiniteData<TQueryFnData, GetAuditorsParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetAuditorsSchema, GetAuditorsParameters> | (DeepReadonly<GetAuditorsParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetAuditorsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetAuditorsSchema, GetAuditorsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetAuditorsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of auditors.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuditors.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetAuditorsParameters,
      TQueryFnData = GetAuditorsData,
      TData = OperationInfiniteData<TQueryFnData, GetAuditorsParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetAuditorsSchema, GetAuditorsParameters> | (DeepReadonly<GetAuditorsParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetAuditorsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetAuditorsSchema, GetAuditorsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetAuditorsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetAuditorsError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get a list of auditors.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getAuditorsTotal = qraft.v1Service.getAuditors.useIsFetching()
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAuditorsSchema, GetAuditorsData, TInfinite, GetAuditorsParameters, GetAuditorsError>
        | QueryFiltersByQueryKey<GetAuditorsSchema, GetAuditorsData, TInfinite, GetAuditorsParameters, GetAuditorsError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get a list of auditors.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getAuditorsResults = qraft.v1Service.getAuditors.useQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getAuditorsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getAuditorsCombinedResults = qraft.v1Service.getAuditors.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getAuditorsCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetAuditorsSchema, GetAuditorsParameters, GetAuditorsData, GetAuditorsError>>,
      TCombinedResult = Array<UseQueryResult<GetAuditorsData, GetAuditorsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetAuditorsData, GetAuditorsError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get a list of auditors. */
    getQueryKey(parameters: DeepReadonly<GetAuditorsParameters> | void): ServiceOperationQueryKey<GetAuditorsSchema, GetAuditorsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of auditors.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAuditors.useQuery()
     * ```
     */
    useQuery<TData = GetAuditorsData>(
      parameters: ServiceOperationQueryKey<GetAuditorsSchema, GetAuditorsParameters> | (DeepReadonly<GetAuditorsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetAuditorsData, GetAuditorsError, TData, ServiceOperationQueryKey<GetAuditorsSchema, GetAuditorsParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetAuditorsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of auditors.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAuditors.useQuery()
     * ```
     */
    useQuery<TData = GetAuditorsData>(
      parameters: ServiceOperationQueryKey<GetAuditorsSchema, GetAuditorsParameters> | (DeepReadonly<GetAuditorsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetAuditorsData, GetAuditorsError, TData, ServiceOperationQueryKey<GetAuditorsSchema, GetAuditorsParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetAuditorsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get a list of auditors.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAuditors.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetAuditorsParameters, TData = GetAuditorsData>(
      parameters: ServiceOperationInfiniteQueryKey<GetAuditorsSchema, GetAuditorsParameters> | (DeepReadonly<GetAuditorsParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetAuditorsData,
          GetAuditorsError,
          OperationInfiniteData<TData, GetAuditorsParameters>,
          GetAuditorsData,
          ServiceOperationInfiniteQueryKey<GetAuditorsSchema, GetAuditorsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetAuditorsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetAuditorsParameters>, GetAuditorsError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get a list of auditors.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getAuditorsData = qraft.v1Service.getAuditors.useSuspenseQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getAuditorsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getAuditorsCombinedData = qraft.v1Service.getAuditors.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getAuditorsCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetAuditorsSchema, GetAuditorsParameters, GetAuditorsData, GetAuditorsError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetAuditorsData, GetAuditorsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetAuditorsData, GetAuditorsError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get a list of auditors.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getAuditors.useSuspenseQuery()
     * ```
     */
    useSuspenseQuery<TData = GetAuditorsData>(
      parameters: ServiceOperationQueryKey<GetAuditorsSchema, GetAuditorsParameters> | (DeepReadonly<GetAuditorsParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<GetAuditorsData, GetAuditorsError, TData, ServiceOperationQueryKey<GetAuditorsSchema, GetAuditorsParameters>>,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetAuditorsError | Error>;
    schema: GetAuditorsSchema;
    types: {
      parameters: GetAuditorsParameters;
      data: GetAuditorsData;
      error: GetAuditorsError;
    };
  };
  /** @summary Get the provider attributes schema */
  getProviderAttributesSchema: {
    /** @summary Get the provider attributes schema */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderAttributesSchemaSchema,
            GetProviderAttributesSchemaData,
            TInfinite,
            GetProviderAttributesSchemaParameters,
            GetProviderAttributesSchemaError
          >
        | QueryFiltersByQueryKey<
            GetProviderAttributesSchemaSchema,
            GetProviderAttributesSchemaData,
            TInfinite,
            GetProviderAttributesSchemaParameters,
            GetProviderAttributesSchemaError
          >,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get the provider attributes schema */
    getQueryKey(
      parameters: DeepReadonly<GetProviderAttributesSchemaParameters> | void
    ): ServiceOperationQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get the provider attributes schema
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviderAttributesSchema.useQuery()
     * ```
     */
    useQuery<TData = GetProviderAttributesSchemaData>(
      parameters:
        | ServiceOperationQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>
        | (DeepReadonly<GetProviderAttributesSchemaParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetProviderAttributesSchemaData,
          GetProviderAttributesSchemaError,
          TData,
          ServiceOperationQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetProviderAttributesSchemaError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get the provider attributes schema
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviderAttributesSchema.useQuery()
     * ```
     */
    useQuery<TData = GetProviderAttributesSchemaData>(
      parameters:
        | ServiceOperationQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>
        | (DeepReadonly<GetProviderAttributesSchemaParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetProviderAttributesSchemaData,
          GetProviderAttributesSchemaError,
          TData,
          ServiceOperationQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetProviderAttributesSchemaError | Error>;
    /** @summary Get the provider attributes schema */
    fetchInfiniteQuery<TPageParam extends GetProviderAttributesSchemaParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetProviderAttributesSchemaSchema,
        GetProviderAttributesSchemaData,
        GetProviderAttributesSchemaParameters,
        DeepReadonly<TPageParam>,
        GetProviderAttributesSchemaError
      > | void
    ): Promise<OperationInfiniteData<GetProviderAttributesSchemaData, GetProviderAttributesSchemaParameters>>;
    /** @summary Get the provider attributes schema */
    prefetchInfiniteQuery<TPageParam extends GetProviderAttributesSchemaParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetProviderAttributesSchemaSchema,
        GetProviderAttributesSchemaData,
        GetProviderAttributesSchemaParameters,
        DeepReadonly<TPageParam>,
        GetProviderAttributesSchemaError
      > | void
    ): Promise<void>;
    /** @summary Get the provider attributes schema */
    ensureInfiniteQueryData<TPageParam extends GetProviderAttributesSchemaParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetProviderAttributesSchemaSchema,
        GetProviderAttributesSchemaData,
        GetProviderAttributesSchemaParameters,
        DeepReadonly<TPageParam>,
        GetProviderAttributesSchemaError
      > | void
    ): Promise<OperationInfiniteData<GetProviderAttributesSchemaData, GetProviderAttributesSchemaParameters>>;
    /** @summary Get the provider attributes schema */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetProviderAttributesSchemaSchema,
        GetProviderAttributesSchemaData,
        GetProviderAttributesSchemaParameters,
        GetProviderAttributesSchemaError
      > | void
    ): Promise<GetProviderAttributesSchemaData>;
    /** @summary Get the provider attributes schema */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetProviderAttributesSchemaSchema,
        GetProviderAttributesSchemaData,
        GetProviderAttributesSchemaParameters,
        GetProviderAttributesSchemaError
      > | void
    ): Promise<void>;
    /** @summary Get the provider attributes schema */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetProviderAttributesSchemaSchema,
        GetProviderAttributesSchemaData,
        GetProviderAttributesSchemaParameters,
        GetProviderAttributesSchemaError
      > | void
    ): Promise<GetProviderAttributesSchemaData>;
    /** @summary Get the provider attributes schema */
    getInfiniteQueryData(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>
        | (DeepReadonly<GetProviderAttributesSchemaParameters> | void)
    ): OperationInfiniteData<GetProviderAttributesSchemaData, GetProviderAttributesSchemaParameters> | undefined;
    /** @summary Get the provider attributes schema */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderAttributesSchemaSchema,
            GetProviderAttributesSchemaData,
            TInfinite,
            GetProviderAttributesSchemaParameters,
            GetProviderAttributesSchemaError
          >
        | QueryFiltersByQueryKey<
            GetProviderAttributesSchemaSchema,
            GetProviderAttributesSchemaData,
            TInfinite,
            GetProviderAttributesSchemaParameters,
            GetProviderAttributesSchemaError
          >
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>,
            data: NoInfer<OperationInfiniteData<GetProviderAttributesSchemaData, GetProviderAttributesSchemaParameters>> | undefined
          ]
        >
      : Array<
          [
            queryKey: ServiceOperationQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>,
            data: GetProviderAttributesSchemaData | undefined
          ]
        >;
    /** @summary Get the provider attributes schema */
    getQueryData(
      parameters:
        | ServiceOperationQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>
        | (DeepReadonly<GetProviderAttributesSchemaParameters> | void)
    ): GetProviderAttributesSchemaData | undefined;
    /** @summary Get the provider attributes schema */
    getQueryState(
      parameters:
        | ServiceOperationQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>
        | (DeepReadonly<GetProviderAttributesSchemaParameters> | void)
    ): QueryState<GetProviderAttributesSchemaData, GetProviderAttributesSchemaError> | undefined;
    /** @summary Get the provider attributes schema */
    getInfiniteQueryState(
      parameters:
        | DeepReadonly<GetProviderAttributesSchemaParameters>
        | ServiceOperationInfiniteQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>
        | void
    ): QueryState<OperationInfiniteData<GetProviderAttributesSchemaData, GetProviderAttributesSchemaParameters>, GetProviderAttributesSchemaError> | undefined;
    /** @summary Get the provider attributes schema */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<
        GetProviderAttributesSchemaSchema,
        GetProviderAttributesSchemaData,
        TInfinite,
        GetProviderAttributesSchemaParameters,
        GetProviderAttributesSchemaError
      >,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get the provider attributes schema */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderAttributesSchemaSchema,
            GetProviderAttributesSchemaData,
            TInfinite,
            GetProviderAttributesSchemaParameters,
            GetProviderAttributesSchemaError
          >
        | QueryFiltersByQueryKey<
            GetProviderAttributesSchemaSchema,
            GetProviderAttributesSchemaData,
            TInfinite,
            GetProviderAttributesSchemaParameters,
            GetProviderAttributesSchemaError
          >
    ): number;
    /** @summary Get the provider attributes schema */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetProviderAttributesSchemaParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetProviderAttributesSchemaSchema,
        options: {
          parameters: GetProviderAttributesSchemaParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetProviderAttributesSchemaData, GetProviderAttributesSchemaError>>
    ): Promise<RequestFnResponse<GetProviderAttributesSchemaData, GetProviderAttributesSchemaError>>;
    /** @summary Get the provider attributes schema */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderAttributesSchemaSchema,
            GetProviderAttributesSchemaData,
            TInfinite,
            GetProviderAttributesSchemaParameters,
            GetProviderAttributesSchemaError
          >
        | QueryFiltersByQueryKey<
            GetProviderAttributesSchemaSchema,
            GetProviderAttributesSchemaData,
            TInfinite,
            GetProviderAttributesSchemaParameters,
            GetProviderAttributesSchemaError
          >,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get the provider attributes schema */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderAttributesSchemaSchema,
            GetProviderAttributesSchemaData,
            TInfinite,
            GetProviderAttributesSchemaParameters,
            GetProviderAttributesSchemaError
          >
        | QueryFiltersByQueryKey<
            GetProviderAttributesSchemaSchema,
            GetProviderAttributesSchemaData,
            TInfinite,
            GetProviderAttributesSchemaParameters,
            GetProviderAttributesSchemaError
          >
    ): void;
    /** @summary Get the provider attributes schema */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderAttributesSchemaSchema,
            GetProviderAttributesSchemaData,
            TInfinite,
            GetProviderAttributesSchemaParameters,
            GetProviderAttributesSchemaError
          >
        | QueryFiltersByQueryKey<
            GetProviderAttributesSchemaSchema,
            GetProviderAttributesSchemaData,
            TInfinite,
            GetProviderAttributesSchemaParameters,
            GetProviderAttributesSchemaError
          >,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get the provider attributes schema */
    setInfiniteQueryData(
      parameters:
        | (DeepReadonly<GetProviderAttributesSchemaParameters> | undefined)
        | ServiceOperationInfiniteQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetProviderAttributesSchemaData, GetProviderAttributesSchemaParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetProviderAttributesSchemaData, GetProviderAttributesSchemaParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetProviderAttributesSchemaData, GetProviderAttributesSchemaParameters> | undefined;
    /** @summary Get the provider attributes schema */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<
            GetProviderAttributesSchemaSchema,
            GetProviderAttributesSchemaData,
            TInfinite,
            GetProviderAttributesSchemaParameters,
            GetProviderAttributesSchemaError
          >
        | QueryFiltersByQueryKey<
            GetProviderAttributesSchemaSchema,
            GetProviderAttributesSchemaData,
            TInfinite,
            GetProviderAttributesSchemaParameters,
            GetProviderAttributesSchemaError
          >,
      updater: Updater<NoInfer<GetProviderAttributesSchemaData> | undefined, NoInfer<GetProviderAttributesSchemaData> | undefined>,
      options?: SetDataOptions
    ): Array<GetProviderAttributesSchemaData | undefined>;
    /** @summary Get the provider attributes schema */
    setQueryData(
      parameters:
        | (DeepReadonly<GetProviderAttributesSchemaParameters> | undefined)
        | ServiceOperationQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>,
      updater: Updater<NoInfer<GetProviderAttributesSchemaData> | undefined, NoInfer<DeepReadonly<GetProviderAttributesSchemaData>> | undefined>,
      options?: SetDataOptions
    ): GetProviderAttributesSchemaData | undefined;
    /** @summary Get the provider attributes schema */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetProviderAttributesSchemaParameters> | void
    ): ServiceOperationInfiniteQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get the provider attributes schema
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProviderAttributesSchema.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetProviderAttributesSchemaParameters,
      TQueryFnData = GetProviderAttributesSchemaData,
      TData = OperationInfiniteData<TQueryFnData, GetProviderAttributesSchemaParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>
        | (DeepReadonly<GetProviderAttributesSchemaParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetProviderAttributesSchemaError,
          TData,
          ServiceOperationInfiniteQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetProviderAttributesSchemaError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get the provider attributes schema
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProviderAttributesSchema.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetProviderAttributesSchemaParameters,
      TQueryFnData = GetProviderAttributesSchemaData,
      TData = OperationInfiniteData<TQueryFnData, GetProviderAttributesSchemaParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>
        | (DeepReadonly<GetProviderAttributesSchemaParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetProviderAttributesSchemaError,
          TData,
          ServiceOperationInfiniteQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetProviderAttributesSchemaData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetProviderAttributesSchemaError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get the provider attributes schema
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getProviderAttributesSchemaTotal = qraft.v1Service.getProviderAttributesSchema.useIsFetching()
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderAttributesSchemaSchema,
            GetProviderAttributesSchemaData,
            TInfinite,
            GetProviderAttributesSchemaParameters,
            GetProviderAttributesSchemaError
          >
        | QueryFiltersByQueryKey<
            GetProviderAttributesSchemaSchema,
            GetProviderAttributesSchemaData,
            TInfinite,
            GetProviderAttributesSchemaParameters,
            GetProviderAttributesSchemaError
          >
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get the provider attributes schema
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getProviderAttributesSchemaResults = qraft.v1Service.getProviderAttributesSchema.useQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getProviderAttributesSchemaResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getProviderAttributesSchemaCombinedResults = qraft.v1Service.getProviderAttributesSchema.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getProviderAttributesSchemaCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<
          GetProviderAttributesSchemaSchema,
          GetProviderAttributesSchemaParameters,
          GetProviderAttributesSchemaData,
          GetProviderAttributesSchemaError
        >
      >,
      TCombinedResult = Array<UseQueryResult<GetProviderAttributesSchemaData, GetProviderAttributesSchemaError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetProviderAttributesSchemaData, GetProviderAttributesSchemaError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get the provider attributes schema */
    getQueryKey(
      parameters: DeepReadonly<GetProviderAttributesSchemaParameters> | void
    ): ServiceOperationQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get the provider attributes schema
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviderAttributesSchema.useQuery()
     * ```
     */
    useQuery<TData = GetProviderAttributesSchemaData>(
      parameters:
        | ServiceOperationQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>
        | (DeepReadonly<GetProviderAttributesSchemaParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetProviderAttributesSchemaData,
          GetProviderAttributesSchemaError,
          TData,
          ServiceOperationQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetProviderAttributesSchemaError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get the provider attributes schema
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviderAttributesSchema.useQuery()
     * ```
     */
    useQuery<TData = GetProviderAttributesSchemaData>(
      parameters:
        | ServiceOperationQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>
        | (DeepReadonly<GetProviderAttributesSchemaParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetProviderAttributesSchemaData,
          GetProviderAttributesSchemaError,
          TData,
          ServiceOperationQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetProviderAttributesSchemaError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get the provider attributes schema
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProviderAttributesSchema.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetProviderAttributesSchemaParameters, TData = GetProviderAttributesSchemaData>(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>
        | (DeepReadonly<GetProviderAttributesSchemaParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetProviderAttributesSchemaData,
          GetProviderAttributesSchemaError,
          OperationInfiniteData<TData, GetProviderAttributesSchemaParameters>,
          GetProviderAttributesSchemaData,
          ServiceOperationInfiniteQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetProviderAttributesSchemaData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetProviderAttributesSchemaParameters>, GetProviderAttributesSchemaError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get the provider attributes schema
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getProviderAttributesSchemaData = qraft.v1Service.getProviderAttributesSchema.useSuspenseQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getProviderAttributesSchemaResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getProviderAttributesSchemaCombinedData = qraft.v1Service.getProviderAttributesSchema.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getProviderAttributesSchemaCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<
          GetProviderAttributesSchemaSchema,
          GetProviderAttributesSchemaParameters,
          GetProviderAttributesSchemaData,
          GetProviderAttributesSchemaError
        >
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetProviderAttributesSchemaData, GetProviderAttributesSchemaError>>
    >(options: {
      queries: T;
      combine?: (
        results: Array<WithOptional<UseSuspenseQueryResult<GetProviderAttributesSchemaData, GetProviderAttributesSchemaError>, "data">>
      ) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get the provider attributes schema
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getProviderAttributesSchema.useSuspenseQuery()
     * ```
     */
    useSuspenseQuery<TData = GetProviderAttributesSchemaData>(
      parameters:
        | ServiceOperationQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>
        | (DeepReadonly<GetProviderAttributesSchemaParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<
          GetProviderAttributesSchemaData,
          GetProviderAttributesSchemaError,
          TData,
          ServiceOperationQueryKey<GetProviderAttributesSchemaSchema, GetProviderAttributesSchemaParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetProviderAttributesSchemaError | Error>;
    schema: GetProviderAttributesSchemaSchema;
    types: {
      parameters: GetProviderAttributesSchemaParameters;
      data: GetProviderAttributesSchemaData;
      error: GetProviderAttributesSchemaError;
    };
  };
  /** @summary Get a list of provider regions */
  getProviderRegions: {
    /** @summary Get a list of provider regions */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProviderRegionsSchema, GetProviderRegionsData, TInfinite, GetProviderRegionsParameters, GetProviderRegionsError>
        | QueryFiltersByQueryKey<GetProviderRegionsSchema, GetProviderRegionsData, TInfinite, GetProviderRegionsParameters, GetProviderRegionsError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get a list of provider regions */
    getQueryKey(
      parameters: DeepReadonly<GetProviderRegionsParameters> | void
    ): ServiceOperationQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of provider regions
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviderRegions.useQuery()
     * ```
     */
    useQuery<TData = GetProviderRegionsData>(
      parameters: ServiceOperationQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters> | (DeepReadonly<GetProviderRegionsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetProviderRegionsData,
          GetProviderRegionsError,
          TData,
          ServiceOperationQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetProviderRegionsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of provider regions
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviderRegions.useQuery()
     * ```
     */
    useQuery<TData = GetProviderRegionsData>(
      parameters: ServiceOperationQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters> | (DeepReadonly<GetProviderRegionsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetProviderRegionsData,
          GetProviderRegionsError,
          TData,
          ServiceOperationQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetProviderRegionsError | Error>;
    /** @summary Get a list of provider regions */
    fetchInfiniteQuery<TPageParam extends GetProviderRegionsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetProviderRegionsSchema,
        GetProviderRegionsData,
        GetProviderRegionsParameters,
        DeepReadonly<TPageParam>,
        GetProviderRegionsError
      > | void
    ): Promise<OperationInfiniteData<GetProviderRegionsData, GetProviderRegionsParameters>>;
    /** @summary Get a list of provider regions */
    prefetchInfiniteQuery<TPageParam extends GetProviderRegionsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetProviderRegionsSchema,
        GetProviderRegionsData,
        GetProviderRegionsParameters,
        DeepReadonly<TPageParam>,
        GetProviderRegionsError
      > | void
    ): Promise<void>;
    /** @summary Get a list of provider regions */
    ensureInfiniteQueryData<TPageParam extends GetProviderRegionsParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetProviderRegionsSchema,
        GetProviderRegionsData,
        GetProviderRegionsParameters,
        DeepReadonly<TPageParam>,
        GetProviderRegionsError
      > | void
    ): Promise<OperationInfiniteData<GetProviderRegionsData, GetProviderRegionsParameters>>;
    /** @summary Get a list of provider regions */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetProviderRegionsSchema, GetProviderRegionsData, GetProviderRegionsParameters, GetProviderRegionsError> | void
    ): Promise<GetProviderRegionsData>;
    /** @summary Get a list of provider regions */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetProviderRegionsSchema, GetProviderRegionsData, GetProviderRegionsParameters, GetProviderRegionsError> | void
    ): Promise<void>;
    /** @summary Get a list of provider regions */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetProviderRegionsSchema,
        GetProviderRegionsData,
        GetProviderRegionsParameters,
        GetProviderRegionsError
      > | void
    ): Promise<GetProviderRegionsData>;
    /** @summary Get a list of provider regions */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters> | (DeepReadonly<GetProviderRegionsParameters> | void)
    ): OperationInfiniteData<GetProviderRegionsData, GetProviderRegionsParameters> | undefined;
    /** @summary Get a list of provider regions */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProviderRegionsSchema, GetProviderRegionsData, TInfinite, GetProviderRegionsParameters, GetProviderRegionsError>
        | QueryFiltersByQueryKey<GetProviderRegionsSchema, GetProviderRegionsData, TInfinite, GetProviderRegionsParameters, GetProviderRegionsError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters>,
            data: NoInfer<OperationInfiniteData<GetProviderRegionsData, GetProviderRegionsParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters>, data: GetProviderRegionsData | undefined]>;
    /** @summary Get a list of provider regions */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters> | (DeepReadonly<GetProviderRegionsParameters> | void)
    ): GetProviderRegionsData | undefined;
    /** @summary Get a list of provider regions */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters> | (DeepReadonly<GetProviderRegionsParameters> | void)
    ): QueryState<GetProviderRegionsData, GetProviderRegionsError> | undefined;
    /** @summary Get a list of provider regions */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetProviderRegionsParameters> | ServiceOperationInfiniteQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters> | void
    ): QueryState<OperationInfiniteData<GetProviderRegionsData, GetProviderRegionsParameters>, GetProviderRegionsError> | undefined;
    /** @summary Get a list of provider regions */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetProviderRegionsSchema, GetProviderRegionsData, TInfinite, GetProviderRegionsParameters, GetProviderRegionsError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get a list of provider regions */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProviderRegionsSchema, GetProviderRegionsData, TInfinite, GetProviderRegionsParameters, GetProviderRegionsError>
        | QueryFiltersByQueryKey<GetProviderRegionsSchema, GetProviderRegionsData, TInfinite, GetProviderRegionsParameters, GetProviderRegionsError>
    ): number;
    /** @summary Get a list of provider regions */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetProviderRegionsParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetProviderRegionsSchema,
        options: {
          parameters: GetProviderRegionsParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetProviderRegionsData, GetProviderRegionsError>>
    ): Promise<RequestFnResponse<GetProviderRegionsData, GetProviderRegionsError>>;
    /** @summary Get a list of provider regions */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProviderRegionsSchema, GetProviderRegionsData, TInfinite, GetProviderRegionsParameters, GetProviderRegionsError>
        | QueryFiltersByQueryKey<GetProviderRegionsSchema, GetProviderRegionsData, TInfinite, GetProviderRegionsParameters, GetProviderRegionsError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get a list of provider regions */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProviderRegionsSchema, GetProviderRegionsData, TInfinite, GetProviderRegionsParameters, GetProviderRegionsError>
        | QueryFiltersByQueryKey<GetProviderRegionsSchema, GetProviderRegionsData, TInfinite, GetProviderRegionsParameters, GetProviderRegionsError>
    ): void;
    /** @summary Get a list of provider regions */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProviderRegionsSchema, GetProviderRegionsData, TInfinite, GetProviderRegionsParameters, GetProviderRegionsError>
        | QueryFiltersByQueryKey<GetProviderRegionsSchema, GetProviderRegionsData, TInfinite, GetProviderRegionsParameters, GetProviderRegionsError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get a list of provider regions */
    setInfiniteQueryData(
      parameters:
        | (DeepReadonly<GetProviderRegionsParameters> | undefined)
        | ServiceOperationInfiniteQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetProviderRegionsData, GetProviderRegionsParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetProviderRegionsData, GetProviderRegionsParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetProviderRegionsData, GetProviderRegionsParameters> | undefined;
    /** @summary Get a list of provider regions */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetProviderRegionsSchema, GetProviderRegionsData, TInfinite, GetProviderRegionsParameters, GetProviderRegionsError>
        | QueryFiltersByQueryKey<GetProviderRegionsSchema, GetProviderRegionsData, TInfinite, GetProviderRegionsParameters, GetProviderRegionsError>,
      updater: Updater<NoInfer<GetProviderRegionsData> | undefined, NoInfer<GetProviderRegionsData> | undefined>,
      options?: SetDataOptions
    ): Array<GetProviderRegionsData | undefined>;
    /** @summary Get a list of provider regions */
    setQueryData(
      parameters: (DeepReadonly<GetProviderRegionsParameters> | undefined) | ServiceOperationQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters>,
      updater: Updater<NoInfer<GetProviderRegionsData> | undefined, NoInfer<DeepReadonly<GetProviderRegionsData>> | undefined>,
      options?: SetDataOptions
    ): GetProviderRegionsData | undefined;
    /** @summary Get a list of provider regions */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetProviderRegionsParameters> | void
    ): ServiceOperationInfiniteQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of provider regions
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProviderRegions.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetProviderRegionsParameters,
      TQueryFnData = GetProviderRegionsData,
      TData = OperationInfiniteData<TQueryFnData, GetProviderRegionsParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters>
        | (DeepReadonly<GetProviderRegionsParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetProviderRegionsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetProviderRegionsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of provider regions
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProviderRegions.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetProviderRegionsParameters,
      TQueryFnData = GetProviderRegionsData,
      TData = OperationInfiniteData<TQueryFnData, GetProviderRegionsParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters>
        | (DeepReadonly<GetProviderRegionsParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetProviderRegionsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetProviderRegionsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetProviderRegionsError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get a list of provider regions
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getProviderRegionsTotal = qraft.v1Service.getProviderRegions.useIsFetching()
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProviderRegionsSchema, GetProviderRegionsData, TInfinite, GetProviderRegionsParameters, GetProviderRegionsError>
        | QueryFiltersByQueryKey<GetProviderRegionsSchema, GetProviderRegionsData, TInfinite, GetProviderRegionsParameters, GetProviderRegionsError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get a list of provider regions
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getProviderRegionsResults = qraft.v1Service.getProviderRegions.useQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getProviderRegionsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getProviderRegionsCombinedResults = qraft.v1Service.getProviderRegions.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getProviderRegionsCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetProviderRegionsSchema, GetProviderRegionsParameters, GetProviderRegionsData, GetProviderRegionsError>>,
      TCombinedResult = Array<UseQueryResult<GetProviderRegionsData, GetProviderRegionsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetProviderRegionsData, GetProviderRegionsError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get a list of provider regions */
    getQueryKey(
      parameters: DeepReadonly<GetProviderRegionsParameters> | void
    ): ServiceOperationQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of provider regions
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviderRegions.useQuery()
     * ```
     */
    useQuery<TData = GetProviderRegionsData>(
      parameters: ServiceOperationQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters> | (DeepReadonly<GetProviderRegionsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetProviderRegionsData,
          GetProviderRegionsError,
          TData,
          ServiceOperationQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetProviderRegionsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of provider regions
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviderRegions.useQuery()
     * ```
     */
    useQuery<TData = GetProviderRegionsData>(
      parameters: ServiceOperationQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters> | (DeepReadonly<GetProviderRegionsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetProviderRegionsData,
          GetProviderRegionsError,
          TData,
          ServiceOperationQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetProviderRegionsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get a list of provider regions
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProviderRegions.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetProviderRegionsParameters, TData = GetProviderRegionsData>(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters>
        | (DeepReadonly<GetProviderRegionsParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetProviderRegionsData,
          GetProviderRegionsError,
          OperationInfiniteData<TData, GetProviderRegionsParameters>,
          GetProviderRegionsData,
          ServiceOperationInfiniteQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetProviderRegionsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetProviderRegionsParameters>, GetProviderRegionsError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get a list of provider regions
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getProviderRegionsData = qraft.v1Service.getProviderRegions.useSuspenseQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getProviderRegionsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getProviderRegionsCombinedData = qraft.v1Service.getProviderRegions.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getProviderRegionsCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<GetProviderRegionsSchema, GetProviderRegionsParameters, GetProviderRegionsData, GetProviderRegionsError>
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetProviderRegionsData, GetProviderRegionsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetProviderRegionsData, GetProviderRegionsError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get a list of provider regions
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getProviderRegions.useSuspenseQuery()
     * ```
     */
    useSuspenseQuery<TData = GetProviderRegionsData>(
      parameters: ServiceOperationQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters> | (DeepReadonly<GetProviderRegionsParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<
          GetProviderRegionsData,
          GetProviderRegionsError,
          TData,
          ServiceOperationQueryKey<GetProviderRegionsSchema, GetProviderRegionsParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetProviderRegionsError | Error>;
    schema: GetProviderRegionsSchema;
    types: {
      parameters: GetProviderRegionsParameters;
      data: GetProviderRegionsData;
      error: GetProviderRegionsError;
    };
  };
  /** @summary Get dashboard data for provider console. */
  getProviderDashboardOwner: {
    /** @summary Get dashboard data for provider console. */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderDashboardOwnerSchema,
            GetProviderDashboardOwnerData,
            TInfinite,
            GetProviderDashboardOwnerParameters,
            GetProviderDashboardOwnerError
          >
        | QueryFiltersByQueryKey<
            GetProviderDashboardOwnerSchema,
            GetProviderDashboardOwnerData,
            TInfinite,
            GetProviderDashboardOwnerParameters,
            GetProviderDashboardOwnerError
          >,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get dashboard data for provider console. */
    getQueryKey(
      parameters: DeepReadonly<GetProviderDashboardOwnerParameters>
    ): ServiceOperationQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get dashboard data for provider console.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviderDashboardOwner.useQuery({
     *     path: {
     *         owner: owner
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProviderDashboardOwnerData>(
      parameters:
        | ServiceOperationQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>
        | DeepReadonly<GetProviderDashboardOwnerParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetProviderDashboardOwnerData,
          GetProviderDashboardOwnerError,
          TData,
          ServiceOperationQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetProviderDashboardOwnerError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get dashboard data for provider console.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviderDashboardOwner.useQuery({
     *     path: {
     *         owner: owner
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProviderDashboardOwnerData>(
      parameters:
        | ServiceOperationQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>
        | DeepReadonly<GetProviderDashboardOwnerParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetProviderDashboardOwnerData,
          GetProviderDashboardOwnerError,
          TData,
          ServiceOperationQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetProviderDashboardOwnerError | Error>;
    /** @summary Get dashboard data for provider console. */
    fetchInfiniteQuery<TPageParam extends GetProviderDashboardOwnerParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetProviderDashboardOwnerSchema,
        GetProviderDashboardOwnerData,
        GetProviderDashboardOwnerParameters,
        DeepReadonly<TPageParam>,
        GetProviderDashboardOwnerError
      >
    ): Promise<OperationInfiniteData<GetProviderDashboardOwnerData, GetProviderDashboardOwnerParameters>>;
    /** @summary Get dashboard data for provider console. */
    prefetchInfiniteQuery<TPageParam extends GetProviderDashboardOwnerParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetProviderDashboardOwnerSchema,
        GetProviderDashboardOwnerData,
        GetProviderDashboardOwnerParameters,
        DeepReadonly<TPageParam>,
        GetProviderDashboardOwnerError
      >
    ): Promise<void>;
    /** @summary Get dashboard data for provider console. */
    ensureInfiniteQueryData<TPageParam extends GetProviderDashboardOwnerParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetProviderDashboardOwnerSchema,
        GetProviderDashboardOwnerData,
        GetProviderDashboardOwnerParameters,
        DeepReadonly<TPageParam>,
        GetProviderDashboardOwnerError
      >
    ): Promise<OperationInfiniteData<GetProviderDashboardOwnerData, GetProviderDashboardOwnerParameters>>;
    /** @summary Get dashboard data for provider console. */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetProviderDashboardOwnerSchema,
        GetProviderDashboardOwnerData,
        GetProviderDashboardOwnerParameters,
        GetProviderDashboardOwnerError
      >
    ): Promise<GetProviderDashboardOwnerData>;
    /** @summary Get dashboard data for provider console. */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetProviderDashboardOwnerSchema,
        GetProviderDashboardOwnerData,
        GetProviderDashboardOwnerParameters,
        GetProviderDashboardOwnerError
      >
    ): Promise<void>;
    /** @summary Get dashboard data for provider console. */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetProviderDashboardOwnerSchema,
        GetProviderDashboardOwnerData,
        GetProviderDashboardOwnerParameters,
        GetProviderDashboardOwnerError
      >
    ): Promise<GetProviderDashboardOwnerData>;
    /** @summary Get dashboard data for provider console. */
    getInfiniteQueryData(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>
        | DeepReadonly<GetProviderDashboardOwnerParameters>
    ): OperationInfiniteData<GetProviderDashboardOwnerData, GetProviderDashboardOwnerParameters> | undefined;
    /** @summary Get dashboard data for provider console. */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderDashboardOwnerSchema,
            GetProviderDashboardOwnerData,
            TInfinite,
            GetProviderDashboardOwnerParameters,
            GetProviderDashboardOwnerError
          >
        | QueryFiltersByQueryKey<
            GetProviderDashboardOwnerSchema,
            GetProviderDashboardOwnerData,
            TInfinite,
            GetProviderDashboardOwnerParameters,
            GetProviderDashboardOwnerError
          >
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>,
            data: NoInfer<OperationInfiniteData<GetProviderDashboardOwnerData, GetProviderDashboardOwnerParameters>> | undefined
          ]
        >
      : Array<
          [
            queryKey: ServiceOperationQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>,
            data: GetProviderDashboardOwnerData | undefined
          ]
        >;
    /** @summary Get dashboard data for provider console. */
    getQueryData(
      parameters:
        | ServiceOperationQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>
        | DeepReadonly<GetProviderDashboardOwnerParameters>
    ): GetProviderDashboardOwnerData | undefined;
    /** @summary Get dashboard data for provider console. */
    getQueryState(
      parameters:
        | ServiceOperationQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>
        | DeepReadonly<GetProviderDashboardOwnerParameters>
    ): QueryState<GetProviderDashboardOwnerData, GetProviderDashboardOwnerError> | undefined;
    /** @summary Get dashboard data for provider console. */
    getInfiniteQueryState(
      parameters:
        | DeepReadonly<GetProviderDashboardOwnerParameters>
        | ServiceOperationInfiniteQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>
    ): QueryState<OperationInfiniteData<GetProviderDashboardOwnerData, GetProviderDashboardOwnerParameters>, GetProviderDashboardOwnerError> | undefined;
    /** @summary Get dashboard data for provider console. */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<
        GetProviderDashboardOwnerSchema,
        GetProviderDashboardOwnerData,
        TInfinite,
        GetProviderDashboardOwnerParameters,
        GetProviderDashboardOwnerError
      >,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get dashboard data for provider console. */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderDashboardOwnerSchema,
            GetProviderDashboardOwnerData,
            TInfinite,
            GetProviderDashboardOwnerParameters,
            GetProviderDashboardOwnerError
          >
        | QueryFiltersByQueryKey<
            GetProviderDashboardOwnerSchema,
            GetProviderDashboardOwnerData,
            TInfinite,
            GetProviderDashboardOwnerParameters,
            GetProviderDashboardOwnerError
          >
    ): number;
    /** @summary Get dashboard data for provider console. */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetProviderDashboardOwnerParameters, TMeta, TSignal>,
      client?: (
        schema: GetProviderDashboardOwnerSchema,
        options: {
          parameters: GetProviderDashboardOwnerParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetProviderDashboardOwnerData, GetProviderDashboardOwnerError>>
    ): Promise<RequestFnResponse<GetProviderDashboardOwnerData, GetProviderDashboardOwnerError>>;
    /** @summary Get dashboard data for provider console. */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderDashboardOwnerSchema,
            GetProviderDashboardOwnerData,
            TInfinite,
            GetProviderDashboardOwnerParameters,
            GetProviderDashboardOwnerError
          >
        | QueryFiltersByQueryKey<
            GetProviderDashboardOwnerSchema,
            GetProviderDashboardOwnerData,
            TInfinite,
            GetProviderDashboardOwnerParameters,
            GetProviderDashboardOwnerError
          >,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get dashboard data for provider console. */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderDashboardOwnerSchema,
            GetProviderDashboardOwnerData,
            TInfinite,
            GetProviderDashboardOwnerParameters,
            GetProviderDashboardOwnerError
          >
        | QueryFiltersByQueryKey<
            GetProviderDashboardOwnerSchema,
            GetProviderDashboardOwnerData,
            TInfinite,
            GetProviderDashboardOwnerParameters,
            GetProviderDashboardOwnerError
          >
    ): void;
    /** @summary Get dashboard data for provider console. */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderDashboardOwnerSchema,
            GetProviderDashboardOwnerData,
            TInfinite,
            GetProviderDashboardOwnerParameters,
            GetProviderDashboardOwnerError
          >
        | QueryFiltersByQueryKey<
            GetProviderDashboardOwnerSchema,
            GetProviderDashboardOwnerData,
            TInfinite,
            GetProviderDashboardOwnerParameters,
            GetProviderDashboardOwnerError
          >,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get dashboard data for provider console. */
    setInfiniteQueryData(
      parameters:
        | DeepReadonly<GetProviderDashboardOwnerParameters>
        | ServiceOperationInfiniteQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetProviderDashboardOwnerData, GetProviderDashboardOwnerParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetProviderDashboardOwnerData, GetProviderDashboardOwnerParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetProviderDashboardOwnerData, GetProviderDashboardOwnerParameters> | undefined;
    /** @summary Get dashboard data for provider console. */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<
            GetProviderDashboardOwnerSchema,
            GetProviderDashboardOwnerData,
            TInfinite,
            GetProviderDashboardOwnerParameters,
            GetProviderDashboardOwnerError
          >
        | QueryFiltersByQueryKey<
            GetProviderDashboardOwnerSchema,
            GetProviderDashboardOwnerData,
            TInfinite,
            GetProviderDashboardOwnerParameters,
            GetProviderDashboardOwnerError
          >,
      updater: Updater<NoInfer<GetProviderDashboardOwnerData> | undefined, NoInfer<GetProviderDashboardOwnerData> | undefined>,
      options?: SetDataOptions
    ): Array<GetProviderDashboardOwnerData | undefined>;
    /** @summary Get dashboard data for provider console. */
    setQueryData(
      parameters:
        | DeepReadonly<GetProviderDashboardOwnerParameters>
        | ServiceOperationQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>,
      updater: Updater<NoInfer<GetProviderDashboardOwnerData> | undefined, NoInfer<DeepReadonly<GetProviderDashboardOwnerData>> | undefined>,
      options?: SetDataOptions
    ): GetProviderDashboardOwnerData | undefined;
    /** @summary Get dashboard data for provider console. */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetProviderDashboardOwnerParameters>
    ): ServiceOperationInfiniteQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get dashboard data for provider console.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProviderDashboardOwner.useInfiniteQuery({
     *     path: {
     *         owner: owner
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetProviderDashboardOwnerParameters,
      TQueryFnData = GetProviderDashboardOwnerData,
      TData = OperationInfiniteData<TQueryFnData, GetProviderDashboardOwnerParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>
        | DeepReadonly<GetProviderDashboardOwnerParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetProviderDashboardOwnerError,
          TData,
          ServiceOperationInfiniteQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetProviderDashboardOwnerError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get dashboard data for provider console.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProviderDashboardOwner.useInfiniteQuery({
     *     path: {
     *         owner: owner
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetProviderDashboardOwnerParameters,
      TQueryFnData = GetProviderDashboardOwnerData,
      TData = OperationInfiniteData<TQueryFnData, GetProviderDashboardOwnerParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>
        | DeepReadonly<GetProviderDashboardOwnerParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetProviderDashboardOwnerError,
          TData,
          ServiceOperationInfiniteQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetProviderDashboardOwnerData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetProviderDashboardOwnerError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get dashboard data for provider console.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getProviderDashboardOwnerTotal = qraft.v1Service.getProviderDashboardOwner.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getProviderDashboardOwnerByParametersTotal = qraft.v1Service.getProviderDashboardOwner.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             owner: owner
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderDashboardOwnerSchema,
            GetProviderDashboardOwnerData,
            TInfinite,
            GetProviderDashboardOwnerParameters,
            GetProviderDashboardOwnerError
          >
        | QueryFiltersByQueryKey<
            GetProviderDashboardOwnerSchema,
            GetProviderDashboardOwnerData,
            TInfinite,
            GetProviderDashboardOwnerParameters,
            GetProviderDashboardOwnerError
          >
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get dashboard data for provider console.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getProviderDashboardOwnerResults = qraft.v1Service.getProviderDashboardOwner.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 owner: owner1
     *             }
     *         },
     *         {
     *             path: {
     *                 owner: owner2
     *             }
     *         }
     *     ]
     * });
     * getProviderDashboardOwnerResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getProviderDashboardOwnerCombinedResults = qraft.v1Service.getProviderDashboardOwner.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 owner: owner1
     *             }
     *         },
     *         {
     *             path: {
     *                 owner: owner2
     *             }
     *         }
     *     ]
     * });
     * getProviderDashboardOwnerCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<
          GetProviderDashboardOwnerSchema,
          GetProviderDashboardOwnerParameters,
          GetProviderDashboardOwnerData,
          GetProviderDashboardOwnerError
        >
      >,
      TCombinedResult = Array<UseQueryResult<GetProviderDashboardOwnerData, GetProviderDashboardOwnerError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetProviderDashboardOwnerData, GetProviderDashboardOwnerError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get dashboard data for provider console. */
    getQueryKey(
      parameters: DeepReadonly<GetProviderDashboardOwnerParameters>
    ): ServiceOperationQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get dashboard data for provider console.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviderDashboardOwner.useQuery({
     *     path: {
     *         owner: owner
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProviderDashboardOwnerData>(
      parameters:
        | ServiceOperationQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>
        | DeepReadonly<GetProviderDashboardOwnerParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetProviderDashboardOwnerData,
          GetProviderDashboardOwnerError,
          TData,
          ServiceOperationQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetProviderDashboardOwnerError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get dashboard data for provider console.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviderDashboardOwner.useQuery({
     *     path: {
     *         owner: owner
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProviderDashboardOwnerData>(
      parameters:
        | ServiceOperationQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>
        | DeepReadonly<GetProviderDashboardOwnerParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetProviderDashboardOwnerData,
          GetProviderDashboardOwnerError,
          TData,
          ServiceOperationQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetProviderDashboardOwnerError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get dashboard data for provider console.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProviderDashboardOwner.useSuspenseInfiniteQuery({
     *     path: {
     *         owner: owner
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetProviderDashboardOwnerParameters, TData = GetProviderDashboardOwnerData>(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>
        | DeepReadonly<GetProviderDashboardOwnerParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetProviderDashboardOwnerData,
          GetProviderDashboardOwnerError,
          OperationInfiniteData<TData, GetProviderDashboardOwnerParameters>,
          GetProviderDashboardOwnerData,
          ServiceOperationInfiniteQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetProviderDashboardOwnerData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetProviderDashboardOwnerParameters>, GetProviderDashboardOwnerError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get dashboard data for provider console.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getProviderDashboardOwnerData = qraft.v1Service.getProviderDashboardOwner.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 owner: owner1
     *             }
     *         },
     *         {
     *             path: {
     *                 owner: owner2
     *             }
     *         }
     *     ]
     * });
     * getProviderDashboardOwnerResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getProviderDashboardOwnerCombinedData = qraft.v1Service.getProviderDashboardOwner.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 owner: owner1
     *             }
     *         },
     *         {
     *             path: {
     *                 owner: owner2
     *             }
     *         }
     *     ]
     * });
     * getProviderDashboardOwnerCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<
          GetProviderDashboardOwnerSchema,
          GetProviderDashboardOwnerParameters,
          GetProviderDashboardOwnerData,
          GetProviderDashboardOwnerError
        >
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetProviderDashboardOwnerData, GetProviderDashboardOwnerError>>
    >(options: {
      queries: T;
      combine?: (
        results: Array<WithOptional<UseSuspenseQueryResult<GetProviderDashboardOwnerData, GetProviderDashboardOwnerError>, "data">>
      ) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get dashboard data for provider console.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getProviderDashboardOwner.useSuspenseQuery({
     *     path: {
     *         owner: owner
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetProviderDashboardOwnerData>(
      parameters:
        | ServiceOperationQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>
        | DeepReadonly<GetProviderDashboardOwnerParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<
          GetProviderDashboardOwnerData,
          GetProviderDashboardOwnerError,
          TData,
          ServiceOperationQueryKey<GetProviderDashboardOwnerSchema, GetProviderDashboardOwnerParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetProviderDashboardOwnerError | Error>;
    schema: GetProviderDashboardOwnerSchema;
    types: {
      parameters: GetProviderDashboardOwnerParameters;
      data: GetProviderDashboardOwnerData;
      error: GetProviderDashboardOwnerError;
    };
  };
  /** @summary Get earnings data for provider console. */
  getProviderEarningsOwner: {
    /** @summary Get earnings data for provider console. */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderEarningsOwnerSchema,
            GetProviderEarningsOwnerData,
            TInfinite,
            GetProviderEarningsOwnerParameters,
            GetProviderEarningsOwnerError
          >
        | QueryFiltersByQueryKey<
            GetProviderEarningsOwnerSchema,
            GetProviderEarningsOwnerData,
            TInfinite,
            GetProviderEarningsOwnerParameters,
            GetProviderEarningsOwnerError
          >,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get earnings data for provider console. */
    getQueryKey(
      parameters: DeepReadonly<GetProviderEarningsOwnerParameters>
    ): ServiceOperationQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get earnings data for provider console.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviderEarningsOwner.useQuery({
     *     path: {
     *         owner: owner
     *     },
     *     query: {
     *         from: from,
     *         to: to
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProviderEarningsOwnerData>(
      parameters:
        | ServiceOperationQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>
        | DeepReadonly<GetProviderEarningsOwnerParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetProviderEarningsOwnerData,
          GetProviderEarningsOwnerError,
          TData,
          ServiceOperationQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetProviderEarningsOwnerError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get earnings data for provider console.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviderEarningsOwner.useQuery({
     *     path: {
     *         owner: owner
     *     },
     *     query: {
     *         from: from,
     *         to: to
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProviderEarningsOwnerData>(
      parameters:
        | ServiceOperationQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>
        | DeepReadonly<GetProviderEarningsOwnerParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetProviderEarningsOwnerData,
          GetProviderEarningsOwnerError,
          TData,
          ServiceOperationQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetProviderEarningsOwnerError | Error>;
    /** @summary Get earnings data for provider console. */
    fetchInfiniteQuery<TPageParam extends GetProviderEarningsOwnerParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetProviderEarningsOwnerSchema,
        GetProviderEarningsOwnerData,
        GetProviderEarningsOwnerParameters,
        DeepReadonly<TPageParam>,
        GetProviderEarningsOwnerError
      >
    ): Promise<OperationInfiniteData<GetProviderEarningsOwnerData, GetProviderEarningsOwnerParameters>>;
    /** @summary Get earnings data for provider console. */
    prefetchInfiniteQuery<TPageParam extends GetProviderEarningsOwnerParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetProviderEarningsOwnerSchema,
        GetProviderEarningsOwnerData,
        GetProviderEarningsOwnerParameters,
        DeepReadonly<TPageParam>,
        GetProviderEarningsOwnerError
      >
    ): Promise<void>;
    /** @summary Get earnings data for provider console. */
    ensureInfiniteQueryData<TPageParam extends GetProviderEarningsOwnerParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetProviderEarningsOwnerSchema,
        GetProviderEarningsOwnerData,
        GetProviderEarningsOwnerParameters,
        DeepReadonly<TPageParam>,
        GetProviderEarningsOwnerError
      >
    ): Promise<OperationInfiniteData<GetProviderEarningsOwnerData, GetProviderEarningsOwnerParameters>>;
    /** @summary Get earnings data for provider console. */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetProviderEarningsOwnerSchema,
        GetProviderEarningsOwnerData,
        GetProviderEarningsOwnerParameters,
        GetProviderEarningsOwnerError
      >
    ): Promise<GetProviderEarningsOwnerData>;
    /** @summary Get earnings data for provider console. */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetProviderEarningsOwnerSchema,
        GetProviderEarningsOwnerData,
        GetProviderEarningsOwnerParameters,
        GetProviderEarningsOwnerError
      >
    ): Promise<void>;
    /** @summary Get earnings data for provider console. */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetProviderEarningsOwnerSchema,
        GetProviderEarningsOwnerData,
        GetProviderEarningsOwnerParameters,
        GetProviderEarningsOwnerError
      >
    ): Promise<GetProviderEarningsOwnerData>;
    /** @summary Get earnings data for provider console. */
    getInfiniteQueryData(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>
        | DeepReadonly<GetProviderEarningsOwnerParameters>
    ): OperationInfiniteData<GetProviderEarningsOwnerData, GetProviderEarningsOwnerParameters> | undefined;
    /** @summary Get earnings data for provider console. */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderEarningsOwnerSchema,
            GetProviderEarningsOwnerData,
            TInfinite,
            GetProviderEarningsOwnerParameters,
            GetProviderEarningsOwnerError
          >
        | QueryFiltersByQueryKey<
            GetProviderEarningsOwnerSchema,
            GetProviderEarningsOwnerData,
            TInfinite,
            GetProviderEarningsOwnerParameters,
            GetProviderEarningsOwnerError
          >
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>,
            data: NoInfer<OperationInfiniteData<GetProviderEarningsOwnerData, GetProviderEarningsOwnerParameters>> | undefined
          ]
        >
      : Array<
          [
            queryKey: ServiceOperationQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>,
            data: GetProviderEarningsOwnerData | undefined
          ]
        >;
    /** @summary Get earnings data for provider console. */
    getQueryData(
      parameters:
        | ServiceOperationQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>
        | DeepReadonly<GetProviderEarningsOwnerParameters>
    ): GetProviderEarningsOwnerData | undefined;
    /** @summary Get earnings data for provider console. */
    getQueryState(
      parameters:
        | ServiceOperationQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>
        | DeepReadonly<GetProviderEarningsOwnerParameters>
    ): QueryState<GetProviderEarningsOwnerData, GetProviderEarningsOwnerError> | undefined;
    /** @summary Get earnings data for provider console. */
    getInfiniteQueryState(
      parameters:
        | DeepReadonly<GetProviderEarningsOwnerParameters>
        | ServiceOperationInfiniteQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>
    ): QueryState<OperationInfiniteData<GetProviderEarningsOwnerData, GetProviderEarningsOwnerParameters>, GetProviderEarningsOwnerError> | undefined;
    /** @summary Get earnings data for provider console. */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<
        GetProviderEarningsOwnerSchema,
        GetProviderEarningsOwnerData,
        TInfinite,
        GetProviderEarningsOwnerParameters,
        GetProviderEarningsOwnerError
      >,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get earnings data for provider console. */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderEarningsOwnerSchema,
            GetProviderEarningsOwnerData,
            TInfinite,
            GetProviderEarningsOwnerParameters,
            GetProviderEarningsOwnerError
          >
        | QueryFiltersByQueryKey<
            GetProviderEarningsOwnerSchema,
            GetProviderEarningsOwnerData,
            TInfinite,
            GetProviderEarningsOwnerParameters,
            GetProviderEarningsOwnerError
          >
    ): number;
    /** @summary Get earnings data for provider console. */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetProviderEarningsOwnerParameters, TMeta, TSignal>,
      client?: (
        schema: GetProviderEarningsOwnerSchema,
        options: {
          parameters: GetProviderEarningsOwnerParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetProviderEarningsOwnerData, GetProviderEarningsOwnerError>>
    ): Promise<RequestFnResponse<GetProviderEarningsOwnerData, GetProviderEarningsOwnerError>>;
    /** @summary Get earnings data for provider console. */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderEarningsOwnerSchema,
            GetProviderEarningsOwnerData,
            TInfinite,
            GetProviderEarningsOwnerParameters,
            GetProviderEarningsOwnerError
          >
        | QueryFiltersByQueryKey<
            GetProviderEarningsOwnerSchema,
            GetProviderEarningsOwnerData,
            TInfinite,
            GetProviderEarningsOwnerParameters,
            GetProviderEarningsOwnerError
          >,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get earnings data for provider console. */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderEarningsOwnerSchema,
            GetProviderEarningsOwnerData,
            TInfinite,
            GetProviderEarningsOwnerParameters,
            GetProviderEarningsOwnerError
          >
        | QueryFiltersByQueryKey<
            GetProviderEarningsOwnerSchema,
            GetProviderEarningsOwnerData,
            TInfinite,
            GetProviderEarningsOwnerParameters,
            GetProviderEarningsOwnerError
          >
    ): void;
    /** @summary Get earnings data for provider console. */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderEarningsOwnerSchema,
            GetProviderEarningsOwnerData,
            TInfinite,
            GetProviderEarningsOwnerParameters,
            GetProviderEarningsOwnerError
          >
        | QueryFiltersByQueryKey<
            GetProviderEarningsOwnerSchema,
            GetProviderEarningsOwnerData,
            TInfinite,
            GetProviderEarningsOwnerParameters,
            GetProviderEarningsOwnerError
          >,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get earnings data for provider console. */
    setInfiniteQueryData(
      parameters:
        | DeepReadonly<GetProviderEarningsOwnerParameters>
        | ServiceOperationInfiniteQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetProviderEarningsOwnerData, GetProviderEarningsOwnerParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetProviderEarningsOwnerData, GetProviderEarningsOwnerParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetProviderEarningsOwnerData, GetProviderEarningsOwnerParameters> | undefined;
    /** @summary Get earnings data for provider console. */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<
            GetProviderEarningsOwnerSchema,
            GetProviderEarningsOwnerData,
            TInfinite,
            GetProviderEarningsOwnerParameters,
            GetProviderEarningsOwnerError
          >
        | QueryFiltersByQueryKey<
            GetProviderEarningsOwnerSchema,
            GetProviderEarningsOwnerData,
            TInfinite,
            GetProviderEarningsOwnerParameters,
            GetProviderEarningsOwnerError
          >,
      updater: Updater<NoInfer<GetProviderEarningsOwnerData> | undefined, NoInfer<GetProviderEarningsOwnerData> | undefined>,
      options?: SetDataOptions
    ): Array<GetProviderEarningsOwnerData | undefined>;
    /** @summary Get earnings data for provider console. */
    setQueryData(
      parameters:
        | DeepReadonly<GetProviderEarningsOwnerParameters>
        | ServiceOperationQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>,
      updater: Updater<NoInfer<GetProviderEarningsOwnerData> | undefined, NoInfer<DeepReadonly<GetProviderEarningsOwnerData>> | undefined>,
      options?: SetDataOptions
    ): GetProviderEarningsOwnerData | undefined;
    /** @summary Get earnings data for provider console. */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetProviderEarningsOwnerParameters>
    ): ServiceOperationInfiniteQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get earnings data for provider console.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProviderEarningsOwner.useInfiniteQuery({
     *     path: {
     *         owner: owner
     *     },
     *     query: {
     *         from: from,
     *         to: to
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             from: initialFrom,
     *             to: initialTo
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetProviderEarningsOwnerParameters,
      TQueryFnData = GetProviderEarningsOwnerData,
      TData = OperationInfiniteData<TQueryFnData, GetProviderEarningsOwnerParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>
        | DeepReadonly<GetProviderEarningsOwnerParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetProviderEarningsOwnerError,
          TData,
          ServiceOperationInfiniteQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetProviderEarningsOwnerError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get earnings data for provider console.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProviderEarningsOwner.useInfiniteQuery({
     *     path: {
     *         owner: owner
     *     },
     *     query: {
     *         from: from,
     *         to: to
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             from: initialFrom,
     *             to: initialTo
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetProviderEarningsOwnerParameters,
      TQueryFnData = GetProviderEarningsOwnerData,
      TData = OperationInfiniteData<TQueryFnData, GetProviderEarningsOwnerParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>
        | DeepReadonly<GetProviderEarningsOwnerParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetProviderEarningsOwnerError,
          TData,
          ServiceOperationInfiniteQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetProviderEarningsOwnerData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetProviderEarningsOwnerError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get earnings data for provider console.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getProviderEarningsOwnerTotal = qraft.v1Service.getProviderEarningsOwner.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getProviderEarningsOwnerByParametersTotal = qraft.v1Service.getProviderEarningsOwner.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             owner: owner
     *         },
     *         query: {
     *             from: from,
     *             to: to
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderEarningsOwnerSchema,
            GetProviderEarningsOwnerData,
            TInfinite,
            GetProviderEarningsOwnerParameters,
            GetProviderEarningsOwnerError
          >
        | QueryFiltersByQueryKey<
            GetProviderEarningsOwnerSchema,
            GetProviderEarningsOwnerData,
            TInfinite,
            GetProviderEarningsOwnerParameters,
            GetProviderEarningsOwnerError
          >
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get earnings data for provider console.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getProviderEarningsOwnerResults = qraft.v1Service.getProviderEarningsOwner.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 owner: owner1
     *             },
     *             query: {
     *                 from: from1,
     *                 to: to1
     *             }
     *         },
     *         {
     *             path: {
     *                 owner: owner2
     *             },
     *             query: {
     *                 from: from2,
     *                 to: to2
     *             }
     *         }
     *     ]
     * });
     * getProviderEarningsOwnerResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getProviderEarningsOwnerCombinedResults = qraft.v1Service.getProviderEarningsOwner.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 owner: owner1
     *             },
     *             query: {
     *                 from: from1,
     *                 to: to1
     *             }
     *         },
     *         {
     *             path: {
     *                 owner: owner2
     *             },
     *             query: {
     *                 from: from2,
     *                 to: to2
     *             }
     *         }
     *     ]
     * });
     * getProviderEarningsOwnerCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<
          GetProviderEarningsOwnerSchema,
          GetProviderEarningsOwnerParameters,
          GetProviderEarningsOwnerData,
          GetProviderEarningsOwnerError
        >
      >,
      TCombinedResult = Array<UseQueryResult<GetProviderEarningsOwnerData, GetProviderEarningsOwnerError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetProviderEarningsOwnerData, GetProviderEarningsOwnerError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get earnings data for provider console. */
    getQueryKey(
      parameters: DeepReadonly<GetProviderEarningsOwnerParameters>
    ): ServiceOperationQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get earnings data for provider console.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviderEarningsOwner.useQuery({
     *     path: {
     *         owner: owner
     *     },
     *     query: {
     *         from: from,
     *         to: to
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProviderEarningsOwnerData>(
      parameters:
        | ServiceOperationQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>
        | DeepReadonly<GetProviderEarningsOwnerParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetProviderEarningsOwnerData,
          GetProviderEarningsOwnerError,
          TData,
          ServiceOperationQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetProviderEarningsOwnerError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get earnings data for provider console.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviderEarningsOwner.useQuery({
     *     path: {
     *         owner: owner
     *     },
     *     query: {
     *         from: from,
     *         to: to
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProviderEarningsOwnerData>(
      parameters:
        | ServiceOperationQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>
        | DeepReadonly<GetProviderEarningsOwnerParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetProviderEarningsOwnerData,
          GetProviderEarningsOwnerError,
          TData,
          ServiceOperationQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetProviderEarningsOwnerError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get earnings data for provider console.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProviderEarningsOwner.useSuspenseInfiniteQuery({
     *     path: {
     *         owner: owner
     *     },
     *     query: {
     *         from: from,
     *         to: to
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             from: initialFrom,
     *             to: initialTo
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetProviderEarningsOwnerParameters, TData = GetProviderEarningsOwnerData>(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>
        | DeepReadonly<GetProviderEarningsOwnerParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetProviderEarningsOwnerData,
          GetProviderEarningsOwnerError,
          OperationInfiniteData<TData, GetProviderEarningsOwnerParameters>,
          GetProviderEarningsOwnerData,
          ServiceOperationInfiniteQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetProviderEarningsOwnerData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetProviderEarningsOwnerParameters>, GetProviderEarningsOwnerError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get earnings data for provider console.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getProviderEarningsOwnerData = qraft.v1Service.getProviderEarningsOwner.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 owner: owner1
     *             },
     *             query: {
     *                 from: from1,
     *                 to: to1
     *             }
     *         },
     *         {
     *             path: {
     *                 owner: owner2
     *             },
     *             query: {
     *                 from: from2,
     *                 to: to2
     *             }
     *         }
     *     ]
     * });
     * getProviderEarningsOwnerResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getProviderEarningsOwnerCombinedData = qraft.v1Service.getProviderEarningsOwner.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 owner: owner1
     *             },
     *             query: {
     *                 from: from1,
     *                 to: to1
     *             }
     *         },
     *         {
     *             path: {
     *                 owner: owner2
     *             },
     *             query: {
     *                 from: from2,
     *                 to: to2
     *             }
     *         }
     *     ]
     * });
     * getProviderEarningsOwnerCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<
          GetProviderEarningsOwnerSchema,
          GetProviderEarningsOwnerParameters,
          GetProviderEarningsOwnerData,
          GetProviderEarningsOwnerError
        >
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetProviderEarningsOwnerData, GetProviderEarningsOwnerError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetProviderEarningsOwnerData, GetProviderEarningsOwnerError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get earnings data for provider console.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getProviderEarningsOwner.useSuspenseQuery({
     *     path: {
     *         owner: owner
     *     },
     *     query: {
     *         from: from,
     *         to: to
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetProviderEarningsOwnerData>(
      parameters:
        | ServiceOperationQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>
        | DeepReadonly<GetProviderEarningsOwnerParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<
          GetProviderEarningsOwnerData,
          GetProviderEarningsOwnerError,
          TData,
          ServiceOperationQueryKey<GetProviderEarningsOwnerSchema, GetProviderEarningsOwnerParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetProviderEarningsOwnerError | Error>;
    schema: GetProviderEarningsOwnerSchema;
    types: {
      parameters: GetProviderEarningsOwnerParameters;
      data: GetProviderEarningsOwnerData;
      error: GetProviderEarningsOwnerError;
    };
  };
  /** @summary Get providers grouped by version. */
  getProviderVersions: {
    /** @summary Get providers grouped by version. */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProviderVersionsSchema, GetProviderVersionsData, TInfinite, GetProviderVersionsParameters, GetProviderVersionsError>
        | QueryFiltersByQueryKey<GetProviderVersionsSchema, GetProviderVersionsData, TInfinite, GetProviderVersionsParameters, GetProviderVersionsError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get providers grouped by version. */
    getQueryKey(
      parameters: DeepReadonly<GetProviderVersionsParameters> | void
    ): ServiceOperationQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get providers grouped by version.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviderVersions.useQuery()
     * ```
     */
    useQuery<TData = GetProviderVersionsData>(
      parameters: ServiceOperationQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters> | (DeepReadonly<GetProviderVersionsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetProviderVersionsData,
          GetProviderVersionsError,
          TData,
          ServiceOperationQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetProviderVersionsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get providers grouped by version.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviderVersions.useQuery()
     * ```
     */
    useQuery<TData = GetProviderVersionsData>(
      parameters: ServiceOperationQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters> | (DeepReadonly<GetProviderVersionsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetProviderVersionsData,
          GetProviderVersionsError,
          TData,
          ServiceOperationQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetProviderVersionsError | Error>;
    /** @summary Get providers grouped by version. */
    fetchInfiniteQuery<TPageParam extends GetProviderVersionsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetProviderVersionsSchema,
        GetProviderVersionsData,
        GetProviderVersionsParameters,
        DeepReadonly<TPageParam>,
        GetProviderVersionsError
      > | void
    ): Promise<OperationInfiniteData<GetProviderVersionsData, GetProviderVersionsParameters>>;
    /** @summary Get providers grouped by version. */
    prefetchInfiniteQuery<TPageParam extends GetProviderVersionsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetProviderVersionsSchema,
        GetProviderVersionsData,
        GetProviderVersionsParameters,
        DeepReadonly<TPageParam>,
        GetProviderVersionsError
      > | void
    ): Promise<void>;
    /** @summary Get providers grouped by version. */
    ensureInfiniteQueryData<TPageParam extends GetProviderVersionsParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetProviderVersionsSchema,
        GetProviderVersionsData,
        GetProviderVersionsParameters,
        DeepReadonly<TPageParam>,
        GetProviderVersionsError
      > | void
    ): Promise<OperationInfiniteData<GetProviderVersionsData, GetProviderVersionsParameters>>;
    /** @summary Get providers grouped by version. */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetProviderVersionsSchema,
        GetProviderVersionsData,
        GetProviderVersionsParameters,
        GetProviderVersionsError
      > | void
    ): Promise<GetProviderVersionsData>;
    /** @summary Get providers grouped by version. */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetProviderVersionsSchema,
        GetProviderVersionsData,
        GetProviderVersionsParameters,
        GetProviderVersionsError
      > | void
    ): Promise<void>;
    /** @summary Get providers grouped by version. */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetProviderVersionsSchema,
        GetProviderVersionsData,
        GetProviderVersionsParameters,
        GetProviderVersionsError
      > | void
    ): Promise<GetProviderVersionsData>;
    /** @summary Get providers grouped by version. */
    getInfiniteQueryData(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters>
        | (DeepReadonly<GetProviderVersionsParameters> | void)
    ): OperationInfiniteData<GetProviderVersionsData, GetProviderVersionsParameters> | undefined;
    /** @summary Get providers grouped by version. */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProviderVersionsSchema, GetProviderVersionsData, TInfinite, GetProviderVersionsParameters, GetProviderVersionsError>
        | QueryFiltersByQueryKey<GetProviderVersionsSchema, GetProviderVersionsData, TInfinite, GetProviderVersionsParameters, GetProviderVersionsError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters>,
            data: NoInfer<OperationInfiniteData<GetProviderVersionsData, GetProviderVersionsParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters>, data: GetProviderVersionsData | undefined]>;
    /** @summary Get providers grouped by version. */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters> | (DeepReadonly<GetProviderVersionsParameters> | void)
    ): GetProviderVersionsData | undefined;
    /** @summary Get providers grouped by version. */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters> | (DeepReadonly<GetProviderVersionsParameters> | void)
    ): QueryState<GetProviderVersionsData, GetProviderVersionsError> | undefined;
    /** @summary Get providers grouped by version. */
    getInfiniteQueryState(
      parameters:
        | DeepReadonly<GetProviderVersionsParameters>
        | ServiceOperationInfiniteQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters>
        | void
    ): QueryState<OperationInfiniteData<GetProviderVersionsData, GetProviderVersionsParameters>, GetProviderVersionsError> | undefined;
    /** @summary Get providers grouped by version. */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetProviderVersionsSchema, GetProviderVersionsData, TInfinite, GetProviderVersionsParameters, GetProviderVersionsError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get providers grouped by version. */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProviderVersionsSchema, GetProviderVersionsData, TInfinite, GetProviderVersionsParameters, GetProviderVersionsError>
        | QueryFiltersByQueryKey<GetProviderVersionsSchema, GetProviderVersionsData, TInfinite, GetProviderVersionsParameters, GetProviderVersionsError>
    ): number;
    /** @summary Get providers grouped by version. */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetProviderVersionsParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetProviderVersionsSchema,
        options: {
          parameters: GetProviderVersionsParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetProviderVersionsData, GetProviderVersionsError>>
    ): Promise<RequestFnResponse<GetProviderVersionsData, GetProviderVersionsError>>;
    /** @summary Get providers grouped by version. */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProviderVersionsSchema, GetProviderVersionsData, TInfinite, GetProviderVersionsParameters, GetProviderVersionsError>
        | QueryFiltersByQueryKey<GetProviderVersionsSchema, GetProviderVersionsData, TInfinite, GetProviderVersionsParameters, GetProviderVersionsError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get providers grouped by version. */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProviderVersionsSchema, GetProviderVersionsData, TInfinite, GetProviderVersionsParameters, GetProviderVersionsError>
        | QueryFiltersByQueryKey<GetProviderVersionsSchema, GetProviderVersionsData, TInfinite, GetProviderVersionsParameters, GetProviderVersionsError>
    ): void;
    /** @summary Get providers grouped by version. */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProviderVersionsSchema, GetProviderVersionsData, TInfinite, GetProviderVersionsParameters, GetProviderVersionsError>
        | QueryFiltersByQueryKey<GetProviderVersionsSchema, GetProviderVersionsData, TInfinite, GetProviderVersionsParameters, GetProviderVersionsError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get providers grouped by version. */
    setInfiniteQueryData(
      parameters:
        | (DeepReadonly<GetProviderVersionsParameters> | undefined)
        | ServiceOperationInfiniteQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetProviderVersionsData, GetProviderVersionsParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetProviderVersionsData, GetProviderVersionsParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetProviderVersionsData, GetProviderVersionsParameters> | undefined;
    /** @summary Get providers grouped by version. */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetProviderVersionsSchema, GetProviderVersionsData, TInfinite, GetProviderVersionsParameters, GetProviderVersionsError>
        | QueryFiltersByQueryKey<GetProviderVersionsSchema, GetProviderVersionsData, TInfinite, GetProviderVersionsParameters, GetProviderVersionsError>,
      updater: Updater<NoInfer<GetProviderVersionsData> | undefined, NoInfer<GetProviderVersionsData> | undefined>,
      options?: SetDataOptions
    ): Array<GetProviderVersionsData | undefined>;
    /** @summary Get providers grouped by version. */
    setQueryData(
      parameters:
        | (DeepReadonly<GetProviderVersionsParameters> | undefined)
        | ServiceOperationQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters>,
      updater: Updater<NoInfer<GetProviderVersionsData> | undefined, NoInfer<DeepReadonly<GetProviderVersionsData>> | undefined>,
      options?: SetDataOptions
    ): GetProviderVersionsData | undefined;
    /** @summary Get providers grouped by version. */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetProviderVersionsParameters> | void
    ): ServiceOperationInfiniteQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get providers grouped by version.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProviderVersions.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetProviderVersionsParameters,
      TQueryFnData = GetProviderVersionsData,
      TData = OperationInfiniteData<TQueryFnData, GetProviderVersionsParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters>
        | (DeepReadonly<GetProviderVersionsParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetProviderVersionsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetProviderVersionsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get providers grouped by version.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProviderVersions.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetProviderVersionsParameters,
      TQueryFnData = GetProviderVersionsData,
      TData = OperationInfiniteData<TQueryFnData, GetProviderVersionsParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters>
        | (DeepReadonly<GetProviderVersionsParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetProviderVersionsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetProviderVersionsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetProviderVersionsError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get providers grouped by version.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getProviderVersionsTotal = qraft.v1Service.getProviderVersions.useIsFetching()
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProviderVersionsSchema, GetProviderVersionsData, TInfinite, GetProviderVersionsParameters, GetProviderVersionsError>
        | QueryFiltersByQueryKey<GetProviderVersionsSchema, GetProviderVersionsData, TInfinite, GetProviderVersionsParameters, GetProviderVersionsError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get providers grouped by version.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getProviderVersionsResults = qraft.v1Service.getProviderVersions.useQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getProviderVersionsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getProviderVersionsCombinedResults = qraft.v1Service.getProviderVersions.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getProviderVersionsCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<GetProviderVersionsSchema, GetProviderVersionsParameters, GetProviderVersionsData, GetProviderVersionsError>
      >,
      TCombinedResult = Array<UseQueryResult<GetProviderVersionsData, GetProviderVersionsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetProviderVersionsData, GetProviderVersionsError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get providers grouped by version. */
    getQueryKey(
      parameters: DeepReadonly<GetProviderVersionsParameters> | void
    ): ServiceOperationQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get providers grouped by version.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviderVersions.useQuery()
     * ```
     */
    useQuery<TData = GetProviderVersionsData>(
      parameters: ServiceOperationQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters> | (DeepReadonly<GetProviderVersionsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetProviderVersionsData,
          GetProviderVersionsError,
          TData,
          ServiceOperationQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetProviderVersionsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get providers grouped by version.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviderVersions.useQuery()
     * ```
     */
    useQuery<TData = GetProviderVersionsData>(
      parameters: ServiceOperationQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters> | (DeepReadonly<GetProviderVersionsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetProviderVersionsData,
          GetProviderVersionsError,
          TData,
          ServiceOperationQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetProviderVersionsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get providers grouped by version.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProviderVersions.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetProviderVersionsParameters, TData = GetProviderVersionsData>(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters>
        | (DeepReadonly<GetProviderVersionsParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetProviderVersionsData,
          GetProviderVersionsError,
          OperationInfiniteData<TData, GetProviderVersionsParameters>,
          GetProviderVersionsData,
          ServiceOperationInfiniteQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetProviderVersionsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetProviderVersionsParameters>, GetProviderVersionsError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get providers grouped by version.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getProviderVersionsData = qraft.v1Service.getProviderVersions.useSuspenseQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getProviderVersionsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getProviderVersionsCombinedData = qraft.v1Service.getProviderVersions.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getProviderVersionsCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<GetProviderVersionsSchema, GetProviderVersionsParameters, GetProviderVersionsData, GetProviderVersionsError>
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetProviderVersionsData, GetProviderVersionsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetProviderVersionsData, GetProviderVersionsError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get providers grouped by version.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getProviderVersions.useSuspenseQuery()
     * ```
     */
    useSuspenseQuery<TData = GetProviderVersionsData>(
      parameters: ServiceOperationQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters> | (DeepReadonly<GetProviderVersionsParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<
          GetProviderVersionsData,
          GetProviderVersionsError,
          TData,
          ServiceOperationQueryKey<GetProviderVersionsSchema, GetProviderVersionsParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetProviderVersionsError | Error>;
    schema: GetProviderVersionsSchema;
    types: {
      parameters: GetProviderVersionsParameters;
      data: GetProviderVersionsData;
      error: GetProviderVersionsError;
    };
  };
  getProviderGraphDataDataName: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderGraphDataDataNameSchema,
            GetProviderGraphDataDataNameData,
            TInfinite,
            GetProviderGraphDataDataNameParameters,
            GetProviderGraphDataDataNameError
          >
        | QueryFiltersByQueryKey<
            GetProviderGraphDataDataNameSchema,
            GetProviderGraphDataDataNameData,
            TInfinite,
            GetProviderGraphDataDataNameParameters,
            GetProviderGraphDataDataNameError
          >,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(
      parameters: DeepReadonly<GetProviderGraphDataDataNameParameters>
    ): ServiceOperationQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviderGraphDataDataName.useQuery({
     *     path: {
     *         dataName: dataName
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProviderGraphDataDataNameData>(
      parameters:
        | ServiceOperationQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>
        | DeepReadonly<GetProviderGraphDataDataNameParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetProviderGraphDataDataNameData,
          GetProviderGraphDataDataNameError,
          TData,
          ServiceOperationQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetProviderGraphDataDataNameError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviderGraphDataDataName.useQuery({
     *     path: {
     *         dataName: dataName
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProviderGraphDataDataNameData>(
      parameters:
        | ServiceOperationQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>
        | DeepReadonly<GetProviderGraphDataDataNameParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetProviderGraphDataDataNameData,
          GetProviderGraphDataDataNameError,
          TData,
          ServiceOperationQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetProviderGraphDataDataNameError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetProviderGraphDataDataNameParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetProviderGraphDataDataNameSchema,
        GetProviderGraphDataDataNameData,
        GetProviderGraphDataDataNameParameters,
        DeepReadonly<TPageParam>,
        GetProviderGraphDataDataNameError
      >
    ): Promise<OperationInfiniteData<GetProviderGraphDataDataNameData, GetProviderGraphDataDataNameParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetProviderGraphDataDataNameParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetProviderGraphDataDataNameSchema,
        GetProviderGraphDataDataNameData,
        GetProviderGraphDataDataNameParameters,
        DeepReadonly<TPageParam>,
        GetProviderGraphDataDataNameError
      >
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetProviderGraphDataDataNameParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetProviderGraphDataDataNameSchema,
        GetProviderGraphDataDataNameData,
        GetProviderGraphDataDataNameParameters,
        DeepReadonly<TPageParam>,
        GetProviderGraphDataDataNameError
      >
    ): Promise<OperationInfiniteData<GetProviderGraphDataDataNameData, GetProviderGraphDataDataNameParameters>>;
    /**/
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetProviderGraphDataDataNameSchema,
        GetProviderGraphDataDataNameData,
        GetProviderGraphDataDataNameParameters,
        GetProviderGraphDataDataNameError
      >
    ): Promise<GetProviderGraphDataDataNameData>;
    /**/
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetProviderGraphDataDataNameSchema,
        GetProviderGraphDataDataNameData,
        GetProviderGraphDataDataNameParameters,
        GetProviderGraphDataDataNameError
      >
    ): Promise<void>;
    /**/
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetProviderGraphDataDataNameSchema,
        GetProviderGraphDataDataNameData,
        GetProviderGraphDataDataNameParameters,
        GetProviderGraphDataDataNameError
      >
    ): Promise<GetProviderGraphDataDataNameData>;
    /**/
    getInfiniteQueryData(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>
        | DeepReadonly<GetProviderGraphDataDataNameParameters>
    ): OperationInfiniteData<GetProviderGraphDataDataNameData, GetProviderGraphDataDataNameParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderGraphDataDataNameSchema,
            GetProviderGraphDataDataNameData,
            TInfinite,
            GetProviderGraphDataDataNameParameters,
            GetProviderGraphDataDataNameError
          >
        | QueryFiltersByQueryKey<
            GetProviderGraphDataDataNameSchema,
            GetProviderGraphDataDataNameData,
            TInfinite,
            GetProviderGraphDataDataNameParameters,
            GetProviderGraphDataDataNameError
          >
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>,
            data: NoInfer<OperationInfiniteData<GetProviderGraphDataDataNameData, GetProviderGraphDataDataNameParameters>> | undefined
          ]
        >
      : Array<
          [
            queryKey: ServiceOperationQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>,
            data: GetProviderGraphDataDataNameData | undefined
          ]
        >;
    /**/
    getQueryData(
      parameters:
        | ServiceOperationQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>
        | DeepReadonly<GetProviderGraphDataDataNameParameters>
    ): GetProviderGraphDataDataNameData | undefined;
    /**/
    getQueryState(
      parameters:
        | ServiceOperationQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>
        | DeepReadonly<GetProviderGraphDataDataNameParameters>
    ): QueryState<GetProviderGraphDataDataNameData, GetProviderGraphDataDataNameError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters:
        | DeepReadonly<GetProviderGraphDataDataNameParameters>
        | ServiceOperationInfiniteQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>
    ):
      | QueryState<OperationInfiniteData<GetProviderGraphDataDataNameData, GetProviderGraphDataDataNameParameters>, GetProviderGraphDataDataNameError>
      | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<
        GetProviderGraphDataDataNameSchema,
        GetProviderGraphDataDataNameData,
        TInfinite,
        GetProviderGraphDataDataNameParameters,
        GetProviderGraphDataDataNameError
      >,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderGraphDataDataNameSchema,
            GetProviderGraphDataDataNameData,
            TInfinite,
            GetProviderGraphDataDataNameParameters,
            GetProviderGraphDataDataNameError
          >
        | QueryFiltersByQueryKey<
            GetProviderGraphDataDataNameSchema,
            GetProviderGraphDataDataNameData,
            TInfinite,
            GetProviderGraphDataDataNameParameters,
            GetProviderGraphDataDataNameError
          >
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetProviderGraphDataDataNameParameters, TMeta, TSignal>,
      client?: (
        schema: GetProviderGraphDataDataNameSchema,
        options: {
          parameters: GetProviderGraphDataDataNameParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetProviderGraphDataDataNameData, GetProviderGraphDataDataNameError>>
    ): Promise<RequestFnResponse<GetProviderGraphDataDataNameData, GetProviderGraphDataDataNameError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderGraphDataDataNameSchema,
            GetProviderGraphDataDataNameData,
            TInfinite,
            GetProviderGraphDataDataNameParameters,
            GetProviderGraphDataDataNameError
          >
        | QueryFiltersByQueryKey<
            GetProviderGraphDataDataNameSchema,
            GetProviderGraphDataDataNameData,
            TInfinite,
            GetProviderGraphDataDataNameParameters,
            GetProviderGraphDataDataNameError
          >,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderGraphDataDataNameSchema,
            GetProviderGraphDataDataNameData,
            TInfinite,
            GetProviderGraphDataDataNameParameters,
            GetProviderGraphDataDataNameError
          >
        | QueryFiltersByQueryKey<
            GetProviderGraphDataDataNameSchema,
            GetProviderGraphDataDataNameData,
            TInfinite,
            GetProviderGraphDataDataNameParameters,
            GetProviderGraphDataDataNameError
          >
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderGraphDataDataNameSchema,
            GetProviderGraphDataDataNameData,
            TInfinite,
            GetProviderGraphDataDataNameParameters,
            GetProviderGraphDataDataNameError
          >
        | QueryFiltersByQueryKey<
            GetProviderGraphDataDataNameSchema,
            GetProviderGraphDataDataNameData,
            TInfinite,
            GetProviderGraphDataDataNameParameters,
            GetProviderGraphDataDataNameError
          >,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters:
        | DeepReadonly<GetProviderGraphDataDataNameParameters>
        | ServiceOperationInfiniteQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetProviderGraphDataDataNameData, GetProviderGraphDataDataNameParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetProviderGraphDataDataNameData, GetProviderGraphDataDataNameParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetProviderGraphDataDataNameData, GetProviderGraphDataDataNameParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<
            GetProviderGraphDataDataNameSchema,
            GetProviderGraphDataDataNameData,
            TInfinite,
            GetProviderGraphDataDataNameParameters,
            GetProviderGraphDataDataNameError
          >
        | QueryFiltersByQueryKey<
            GetProviderGraphDataDataNameSchema,
            GetProviderGraphDataDataNameData,
            TInfinite,
            GetProviderGraphDataDataNameParameters,
            GetProviderGraphDataDataNameError
          >,
      updater: Updater<NoInfer<GetProviderGraphDataDataNameData> | undefined, NoInfer<GetProviderGraphDataDataNameData> | undefined>,
      options?: SetDataOptions
    ): Array<GetProviderGraphDataDataNameData | undefined>;
    /**/
    setQueryData(
      parameters:
        | DeepReadonly<GetProviderGraphDataDataNameParameters>
        | ServiceOperationQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>,
      updater: Updater<NoInfer<GetProviderGraphDataDataNameData> | undefined, NoInfer<DeepReadonly<GetProviderGraphDataDataNameData>> | undefined>,
      options?: SetDataOptions
    ): GetProviderGraphDataDataNameData | undefined;
    /**/
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetProviderGraphDataDataNameParameters>
    ): ServiceOperationInfiniteQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProviderGraphDataDataName.useInfiniteQuery({
     *     path: {
     *         dataName: dataName
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetProviderGraphDataDataNameParameters,
      TQueryFnData = GetProviderGraphDataDataNameData,
      TData = OperationInfiniteData<TQueryFnData, GetProviderGraphDataDataNameParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>
        | DeepReadonly<GetProviderGraphDataDataNameParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetProviderGraphDataDataNameError,
          TData,
          ServiceOperationInfiniteQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetProviderGraphDataDataNameError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProviderGraphDataDataName.useInfiniteQuery({
     *     path: {
     *         dataName: dataName
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetProviderGraphDataDataNameParameters,
      TQueryFnData = GetProviderGraphDataDataNameData,
      TData = OperationInfiniteData<TQueryFnData, GetProviderGraphDataDataNameParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>
        | DeepReadonly<GetProviderGraphDataDataNameParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetProviderGraphDataDataNameError,
          TData,
          ServiceOperationInfiniteQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetProviderGraphDataDataNameData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetProviderGraphDataDataNameError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getProviderGraphDataDataNameTotal = qraft.v1Service.getProviderGraphDataDataName.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getProviderGraphDataDataNameByParametersTotal = qraft.v1Service.getProviderGraphDataDataName.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             dataName: dataName
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProviderGraphDataDataNameSchema,
            GetProviderGraphDataDataNameData,
            TInfinite,
            GetProviderGraphDataDataNameParameters,
            GetProviderGraphDataDataNameError
          >
        | QueryFiltersByQueryKey<
            GetProviderGraphDataDataNameSchema,
            GetProviderGraphDataDataNameData,
            TInfinite,
            GetProviderGraphDataDataNameParameters,
            GetProviderGraphDataDataNameError
          >
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getProviderGraphDataDataNameResults = qraft.v1Service.getProviderGraphDataDataName.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 dataName: dataName1
     *             }
     *         },
     *         {
     *             path: {
     *                 dataName: dataName2
     *             }
     *         }
     *     ]
     * });
     * getProviderGraphDataDataNameResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getProviderGraphDataDataNameCombinedResults = qraft.v1Service.getProviderGraphDataDataName.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 dataName: dataName1
     *             }
     *         },
     *         {
     *             path: {
     *                 dataName: dataName2
     *             }
     *         }
     *     ]
     * });
     * getProviderGraphDataDataNameCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<
          GetProviderGraphDataDataNameSchema,
          GetProviderGraphDataDataNameParameters,
          GetProviderGraphDataDataNameData,
          GetProviderGraphDataDataNameError
        >
      >,
      TCombinedResult = Array<UseQueryResult<GetProviderGraphDataDataNameData, GetProviderGraphDataDataNameError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetProviderGraphDataDataNameData, GetProviderGraphDataDataNameError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(
      parameters: DeepReadonly<GetProviderGraphDataDataNameParameters>
    ): ServiceOperationQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviderGraphDataDataName.useQuery({
     *     path: {
     *         dataName: dataName
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProviderGraphDataDataNameData>(
      parameters:
        | ServiceOperationQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>
        | DeepReadonly<GetProviderGraphDataDataNameParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetProviderGraphDataDataNameData,
          GetProviderGraphDataDataNameError,
          TData,
          ServiceOperationQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetProviderGraphDataDataNameError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProviderGraphDataDataName.useQuery({
     *     path: {
     *         dataName: dataName
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProviderGraphDataDataNameData>(
      parameters:
        | ServiceOperationQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>
        | DeepReadonly<GetProviderGraphDataDataNameParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetProviderGraphDataDataNameData,
          GetProviderGraphDataDataNameError,
          TData,
          ServiceOperationQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetProviderGraphDataDataNameError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProviderGraphDataDataName.useSuspenseInfiniteQuery({
     *     path: {
     *         dataName: dataName
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetProviderGraphDataDataNameParameters, TData = GetProviderGraphDataDataNameData>(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>
        | DeepReadonly<GetProviderGraphDataDataNameParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetProviderGraphDataDataNameData,
          GetProviderGraphDataDataNameError,
          OperationInfiniteData<TData, GetProviderGraphDataDataNameParameters>,
          GetProviderGraphDataDataNameData,
          ServiceOperationInfiniteQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetProviderGraphDataDataNameData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetProviderGraphDataDataNameParameters>, GetProviderGraphDataDataNameError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getProviderGraphDataDataNameData = qraft.v1Service.getProviderGraphDataDataName.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 dataName: dataName1
     *             }
     *         },
     *         {
     *             path: {
     *                 dataName: dataName2
     *             }
     *         }
     *     ]
     * });
     * getProviderGraphDataDataNameResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getProviderGraphDataDataNameCombinedData = qraft.v1Service.getProviderGraphDataDataName.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 dataName: dataName1
     *             }
     *         },
     *         {
     *             path: {
     *                 dataName: dataName2
     *             }
     *         }
     *     ]
     * });
     * getProviderGraphDataDataNameCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<
          GetProviderGraphDataDataNameSchema,
          GetProviderGraphDataDataNameParameters,
          GetProviderGraphDataDataNameData,
          GetProviderGraphDataDataNameError
        >
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetProviderGraphDataDataNameData, GetProviderGraphDataDataNameError>>
    >(options: {
      queries: T;
      combine?: (
        results: Array<WithOptional<UseSuspenseQueryResult<GetProviderGraphDataDataNameData, GetProviderGraphDataDataNameError>, "data">>
      ) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getProviderGraphDataDataName.useSuspenseQuery({
     *     path: {
     *         dataName: dataName
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetProviderGraphDataDataNameData>(
      parameters:
        | ServiceOperationQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>
        | DeepReadonly<GetProviderGraphDataDataNameParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<
          GetProviderGraphDataDataNameData,
          GetProviderGraphDataDataNameError,
          TData,
          ServiceOperationQueryKey<GetProviderGraphDataDataNameSchema, GetProviderGraphDataDataNameParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetProviderGraphDataDataNameError | Error>;
    schema: GetProviderGraphDataDataNameSchema;
    types: {
      parameters: GetProviderGraphDataDataNameParameters;
      data: GetProviderGraphDataDataNameData;
      error: GetProviderGraphDataDataNameError;
    };
  };
  /** @summary Get a list of deployments for a provider. */
  getProvidersProviderDeploymentsSkipLimit: {
    /** @summary Get a list of deployments for a provider. */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProvidersProviderDeploymentsSkipLimitSchema,
            GetProvidersProviderDeploymentsSkipLimitData,
            TInfinite,
            GetProvidersProviderDeploymentsSkipLimitParameters,
            GetProvidersProviderDeploymentsSkipLimitError
          >
        | QueryFiltersByQueryKey<
            GetProvidersProviderDeploymentsSkipLimitSchema,
            GetProvidersProviderDeploymentsSkipLimitData,
            TInfinite,
            GetProvidersProviderDeploymentsSkipLimitParameters,
            GetProvidersProviderDeploymentsSkipLimitError
          >,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get a list of deployments for a provider. */
    getQueryKey(
      parameters: DeepReadonly<GetProvidersProviderDeploymentsSkipLimitParameters>
    ): ServiceOperationQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of deployments for a provider.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProvidersProviderDeploymentsSkipLimit.useQuery({
     *     path: {
     *         provider: provider,
     *         limit: limit
     *     },
     *     query: {
     *         status: status
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProvidersProviderDeploymentsSkipLimitData>(
      parameters:
        | ServiceOperationQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>
        | DeepReadonly<GetProvidersProviderDeploymentsSkipLimitParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetProvidersProviderDeploymentsSkipLimitData,
          GetProvidersProviderDeploymentsSkipLimitError,
          TData,
          ServiceOperationQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetProvidersProviderDeploymentsSkipLimitError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of deployments for a provider.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProvidersProviderDeploymentsSkipLimit.useQuery({
     *     path: {
     *         provider: provider,
     *         limit: limit
     *     },
     *     query: {
     *         status: status
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProvidersProviderDeploymentsSkipLimitData>(
      parameters:
        | ServiceOperationQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>
        | DeepReadonly<GetProvidersProviderDeploymentsSkipLimitParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetProvidersProviderDeploymentsSkipLimitData,
          GetProvidersProviderDeploymentsSkipLimitError,
          TData,
          ServiceOperationQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetProvidersProviderDeploymentsSkipLimitError | Error>;
    /** @summary Get a list of deployments for a provider. */
    fetchInfiniteQuery<TPageParam extends GetProvidersProviderDeploymentsSkipLimitParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetProvidersProviderDeploymentsSkipLimitSchema,
        GetProvidersProviderDeploymentsSkipLimitData,
        GetProvidersProviderDeploymentsSkipLimitParameters,
        DeepReadonly<TPageParam>,
        GetProvidersProviderDeploymentsSkipLimitError
      >
    ): Promise<OperationInfiniteData<GetProvidersProviderDeploymentsSkipLimitData, GetProvidersProviderDeploymentsSkipLimitParameters>>;
    /** @summary Get a list of deployments for a provider. */
    prefetchInfiniteQuery<TPageParam extends GetProvidersProviderDeploymentsSkipLimitParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetProvidersProviderDeploymentsSkipLimitSchema,
        GetProvidersProviderDeploymentsSkipLimitData,
        GetProvidersProviderDeploymentsSkipLimitParameters,
        DeepReadonly<TPageParam>,
        GetProvidersProviderDeploymentsSkipLimitError
      >
    ): Promise<void>;
    /** @summary Get a list of deployments for a provider. */
    ensureInfiniteQueryData<TPageParam extends GetProvidersProviderDeploymentsSkipLimitParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetProvidersProviderDeploymentsSkipLimitSchema,
        GetProvidersProviderDeploymentsSkipLimitData,
        GetProvidersProviderDeploymentsSkipLimitParameters,
        DeepReadonly<TPageParam>,
        GetProvidersProviderDeploymentsSkipLimitError
      >
    ): Promise<OperationInfiniteData<GetProvidersProviderDeploymentsSkipLimitData, GetProvidersProviderDeploymentsSkipLimitParameters>>;
    /** @summary Get a list of deployments for a provider. */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetProvidersProviderDeploymentsSkipLimitSchema,
        GetProvidersProviderDeploymentsSkipLimitData,
        GetProvidersProviderDeploymentsSkipLimitParameters,
        GetProvidersProviderDeploymentsSkipLimitError
      >
    ): Promise<GetProvidersProviderDeploymentsSkipLimitData>;
    /** @summary Get a list of deployments for a provider. */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetProvidersProviderDeploymentsSkipLimitSchema,
        GetProvidersProviderDeploymentsSkipLimitData,
        GetProvidersProviderDeploymentsSkipLimitParameters,
        GetProvidersProviderDeploymentsSkipLimitError
      >
    ): Promise<void>;
    /** @summary Get a list of deployments for a provider. */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetProvidersProviderDeploymentsSkipLimitSchema,
        GetProvidersProviderDeploymentsSkipLimitData,
        GetProvidersProviderDeploymentsSkipLimitParameters,
        GetProvidersProviderDeploymentsSkipLimitError
      >
    ): Promise<GetProvidersProviderDeploymentsSkipLimitData>;
    /** @summary Get a list of deployments for a provider. */
    getInfiniteQueryData(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>
        | DeepReadonly<GetProvidersProviderDeploymentsSkipLimitParameters>
    ): OperationInfiniteData<GetProvidersProviderDeploymentsSkipLimitData, GetProvidersProviderDeploymentsSkipLimitParameters> | undefined;
    /** @summary Get a list of deployments for a provider. */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProvidersProviderDeploymentsSkipLimitSchema,
            GetProvidersProviderDeploymentsSkipLimitData,
            TInfinite,
            GetProvidersProviderDeploymentsSkipLimitParameters,
            GetProvidersProviderDeploymentsSkipLimitError
          >
        | QueryFiltersByQueryKey<
            GetProvidersProviderDeploymentsSkipLimitSchema,
            GetProvidersProviderDeploymentsSkipLimitData,
            TInfinite,
            GetProvidersProviderDeploymentsSkipLimitParameters,
            GetProvidersProviderDeploymentsSkipLimitError
          >
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>,
            data: NoInfer<OperationInfiniteData<GetProvidersProviderDeploymentsSkipLimitData, GetProvidersProviderDeploymentsSkipLimitParameters>> | undefined
          ]
        >
      : Array<
          [
            queryKey: ServiceOperationQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>,
            data: GetProvidersProviderDeploymentsSkipLimitData | undefined
          ]
        >;
    /** @summary Get a list of deployments for a provider. */
    getQueryData(
      parameters:
        | ServiceOperationQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>
        | DeepReadonly<GetProvidersProviderDeploymentsSkipLimitParameters>
    ): GetProvidersProviderDeploymentsSkipLimitData | undefined;
    /** @summary Get a list of deployments for a provider. */
    getQueryState(
      parameters:
        | ServiceOperationQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>
        | DeepReadonly<GetProvidersProviderDeploymentsSkipLimitParameters>
    ): QueryState<GetProvidersProviderDeploymentsSkipLimitData, GetProvidersProviderDeploymentsSkipLimitError> | undefined;
    /** @summary Get a list of deployments for a provider. */
    getInfiniteQueryState(
      parameters:
        | DeepReadonly<GetProvidersProviderDeploymentsSkipLimitParameters>
        | ServiceOperationInfiniteQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>
    ):
      | QueryState<
          OperationInfiniteData<GetProvidersProviderDeploymentsSkipLimitData, GetProvidersProviderDeploymentsSkipLimitParameters>,
          GetProvidersProviderDeploymentsSkipLimitError
        >
      | undefined;
    /** @summary Get a list of deployments for a provider. */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<
        GetProvidersProviderDeploymentsSkipLimitSchema,
        GetProvidersProviderDeploymentsSkipLimitData,
        TInfinite,
        GetProvidersProviderDeploymentsSkipLimitParameters,
        GetProvidersProviderDeploymentsSkipLimitError
      >,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get a list of deployments for a provider. */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProvidersProviderDeploymentsSkipLimitSchema,
            GetProvidersProviderDeploymentsSkipLimitData,
            TInfinite,
            GetProvidersProviderDeploymentsSkipLimitParameters,
            GetProvidersProviderDeploymentsSkipLimitError
          >
        | QueryFiltersByQueryKey<
            GetProvidersProviderDeploymentsSkipLimitSchema,
            GetProvidersProviderDeploymentsSkipLimitData,
            TInfinite,
            GetProvidersProviderDeploymentsSkipLimitParameters,
            GetProvidersProviderDeploymentsSkipLimitError
          >
    ): number;
    /** @summary Get a list of deployments for a provider. */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetProvidersProviderDeploymentsSkipLimitParameters, TMeta, TSignal>,
      client?: (
        schema: GetProvidersProviderDeploymentsSkipLimitSchema,
        options: {
          parameters: GetProvidersProviderDeploymentsSkipLimitParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetProvidersProviderDeploymentsSkipLimitData, GetProvidersProviderDeploymentsSkipLimitError>>
    ): Promise<RequestFnResponse<GetProvidersProviderDeploymentsSkipLimitData, GetProvidersProviderDeploymentsSkipLimitError>>;
    /** @summary Get a list of deployments for a provider. */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProvidersProviderDeploymentsSkipLimitSchema,
            GetProvidersProviderDeploymentsSkipLimitData,
            TInfinite,
            GetProvidersProviderDeploymentsSkipLimitParameters,
            GetProvidersProviderDeploymentsSkipLimitError
          >
        | QueryFiltersByQueryKey<
            GetProvidersProviderDeploymentsSkipLimitSchema,
            GetProvidersProviderDeploymentsSkipLimitData,
            TInfinite,
            GetProvidersProviderDeploymentsSkipLimitParameters,
            GetProvidersProviderDeploymentsSkipLimitError
          >,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get a list of deployments for a provider. */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProvidersProviderDeploymentsSkipLimitSchema,
            GetProvidersProviderDeploymentsSkipLimitData,
            TInfinite,
            GetProvidersProviderDeploymentsSkipLimitParameters,
            GetProvidersProviderDeploymentsSkipLimitError
          >
        | QueryFiltersByQueryKey<
            GetProvidersProviderDeploymentsSkipLimitSchema,
            GetProvidersProviderDeploymentsSkipLimitData,
            TInfinite,
            GetProvidersProviderDeploymentsSkipLimitParameters,
            GetProvidersProviderDeploymentsSkipLimitError
          >
    ): void;
    /** @summary Get a list of deployments for a provider. */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProvidersProviderDeploymentsSkipLimitSchema,
            GetProvidersProviderDeploymentsSkipLimitData,
            TInfinite,
            GetProvidersProviderDeploymentsSkipLimitParameters,
            GetProvidersProviderDeploymentsSkipLimitError
          >
        | QueryFiltersByQueryKey<
            GetProvidersProviderDeploymentsSkipLimitSchema,
            GetProvidersProviderDeploymentsSkipLimitData,
            TInfinite,
            GetProvidersProviderDeploymentsSkipLimitParameters,
            GetProvidersProviderDeploymentsSkipLimitError
          >,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get a list of deployments for a provider. */
    setInfiniteQueryData(
      parameters:
        | DeepReadonly<GetProvidersProviderDeploymentsSkipLimitParameters>
        | ServiceOperationInfiniteQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetProvidersProviderDeploymentsSkipLimitData, GetProvidersProviderDeploymentsSkipLimitParameters>> | undefined,
        | NoInfer<DeepReadonly<OperationInfiniteData<GetProvidersProviderDeploymentsSkipLimitData, GetProvidersProviderDeploymentsSkipLimitParameters>>>
        | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetProvidersProviderDeploymentsSkipLimitData, GetProvidersProviderDeploymentsSkipLimitParameters> | undefined;
    /** @summary Get a list of deployments for a provider. */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<
            GetProvidersProviderDeploymentsSkipLimitSchema,
            GetProvidersProviderDeploymentsSkipLimitData,
            TInfinite,
            GetProvidersProviderDeploymentsSkipLimitParameters,
            GetProvidersProviderDeploymentsSkipLimitError
          >
        | QueryFiltersByQueryKey<
            GetProvidersProviderDeploymentsSkipLimitSchema,
            GetProvidersProviderDeploymentsSkipLimitData,
            TInfinite,
            GetProvidersProviderDeploymentsSkipLimitParameters,
            GetProvidersProviderDeploymentsSkipLimitError
          >,
      updater: Updater<NoInfer<GetProvidersProviderDeploymentsSkipLimitData> | undefined, NoInfer<GetProvidersProviderDeploymentsSkipLimitData> | undefined>,
      options?: SetDataOptions
    ): Array<GetProvidersProviderDeploymentsSkipLimitData | undefined>;
    /** @summary Get a list of deployments for a provider. */
    setQueryData(
      parameters:
        | DeepReadonly<GetProvidersProviderDeploymentsSkipLimitParameters>
        | ServiceOperationQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>,
      updater: Updater<
        NoInfer<GetProvidersProviderDeploymentsSkipLimitData> | undefined,
        NoInfer<DeepReadonly<GetProvidersProviderDeploymentsSkipLimitData>> | undefined
      >,
      options?: SetDataOptions
    ): GetProvidersProviderDeploymentsSkipLimitData | undefined;
    /** @summary Get a list of deployments for a provider. */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetProvidersProviderDeploymentsSkipLimitParameters>
    ): ServiceOperationInfiniteQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of deployments for a provider.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProvidersProviderDeploymentsSkipLimit.useInfiniteQuery({
     *     path: {
     *         provider: provider,
     *         limit: limit
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             status: initialStatus
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetProvidersProviderDeploymentsSkipLimitParameters,
      TQueryFnData = GetProvidersProviderDeploymentsSkipLimitData,
      TData = OperationInfiniteData<TQueryFnData, GetProvidersProviderDeploymentsSkipLimitParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>
        | DeepReadonly<GetProvidersProviderDeploymentsSkipLimitParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetProvidersProviderDeploymentsSkipLimitError,
          TData,
          ServiceOperationInfiniteQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetProvidersProviderDeploymentsSkipLimitError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of deployments for a provider.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProvidersProviderDeploymentsSkipLimit.useInfiniteQuery({
     *     path: {
     *         provider: provider,
     *         limit: limit
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             status: initialStatus
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetProvidersProviderDeploymentsSkipLimitParameters,
      TQueryFnData = GetProvidersProviderDeploymentsSkipLimitData,
      TData = OperationInfiniteData<TQueryFnData, GetProvidersProviderDeploymentsSkipLimitParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>
        | DeepReadonly<GetProvidersProviderDeploymentsSkipLimitParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetProvidersProviderDeploymentsSkipLimitError,
          TData,
          ServiceOperationInfiniteQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetProvidersProviderDeploymentsSkipLimitData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetProvidersProviderDeploymentsSkipLimitError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get a list of deployments for a provider.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getProvidersProviderDeploymentsSkipLimitTotal = qraft.v1Service.getProvidersProviderDeploymentsSkipLimit.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getProvidersProviderDeploymentsSkipLimitByParametersTotal = qraft.v1Service.getProvidersProviderDeploymentsSkipLimit.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             provider: provider,
     *             limit: limit
     *         },
     *         query: {
     *             status: status
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetProvidersProviderDeploymentsSkipLimitSchema,
            GetProvidersProviderDeploymentsSkipLimitData,
            TInfinite,
            GetProvidersProviderDeploymentsSkipLimitParameters,
            GetProvidersProviderDeploymentsSkipLimitError
          >
        | QueryFiltersByQueryKey<
            GetProvidersProviderDeploymentsSkipLimitSchema,
            GetProvidersProviderDeploymentsSkipLimitData,
            TInfinite,
            GetProvidersProviderDeploymentsSkipLimitParameters,
            GetProvidersProviderDeploymentsSkipLimitError
          >
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get a list of deployments for a provider.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getProvidersProviderDeploymentsSkipLimitResults = qraft.v1Service.getProvidersProviderDeploymentsSkipLimit.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 provider: provider1,
     *                 limit: limit1
     *             },
     *             query: {
     *                 status: status1
     *             }
     *         },
     *         {
     *             path: {
     *                 provider: provider2,
     *                 limit: limit2
     *             },
     *             query: {
     *                 status: status2
     *             }
     *         }
     *     ]
     * });
     * getProvidersProviderDeploymentsSkipLimitResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getProvidersProviderDeploymentsSkipLimitCombinedResults = qraft.v1Service.getProvidersProviderDeploymentsSkipLimit.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 provider: provider1,
     *                 limit: limit1
     *             },
     *             query: {
     *                 status: status1
     *             }
     *         },
     *         {
     *             path: {
     *                 provider: provider2,
     *                 limit: limit2
     *             },
     *             query: {
     *                 status: status2
     *             }
     *         }
     *     ]
     * });
     * getProvidersProviderDeploymentsSkipLimitCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<
          GetProvidersProviderDeploymentsSkipLimitSchema,
          GetProvidersProviderDeploymentsSkipLimitParameters,
          GetProvidersProviderDeploymentsSkipLimitData,
          GetProvidersProviderDeploymentsSkipLimitError
        >
      >,
      TCombinedResult = Array<UseQueryResult<GetProvidersProviderDeploymentsSkipLimitData, GetProvidersProviderDeploymentsSkipLimitError>>
    >(options: {
      queries: T;
      combine?: (
        results: Array<UseQueryResult<GetProvidersProviderDeploymentsSkipLimitData, GetProvidersProviderDeploymentsSkipLimitError>>
      ) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get a list of deployments for a provider. */
    getQueryKey(
      parameters: DeepReadonly<GetProvidersProviderDeploymentsSkipLimitParameters>
    ): ServiceOperationQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of deployments for a provider.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProvidersProviderDeploymentsSkipLimit.useQuery({
     *     path: {
     *         provider: provider,
     *         limit: limit
     *     },
     *     query: {
     *         status: status
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProvidersProviderDeploymentsSkipLimitData>(
      parameters:
        | ServiceOperationQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>
        | DeepReadonly<GetProvidersProviderDeploymentsSkipLimitParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetProvidersProviderDeploymentsSkipLimitData,
          GetProvidersProviderDeploymentsSkipLimitError,
          TData,
          ServiceOperationQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetProvidersProviderDeploymentsSkipLimitError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of deployments for a provider.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProvidersProviderDeploymentsSkipLimit.useQuery({
     *     path: {
     *         provider: provider,
     *         limit: limit
     *     },
     *     query: {
     *         status: status
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProvidersProviderDeploymentsSkipLimitData>(
      parameters:
        | ServiceOperationQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>
        | DeepReadonly<GetProvidersProviderDeploymentsSkipLimitParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetProvidersProviderDeploymentsSkipLimitData,
          GetProvidersProviderDeploymentsSkipLimitError,
          TData,
          ServiceOperationQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetProvidersProviderDeploymentsSkipLimitError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get a list of deployments for a provider.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProvidersProviderDeploymentsSkipLimit.useSuspenseInfiniteQuery({
     *     path: {
     *         provider: provider,
     *         limit: limit
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             status: initialStatus
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetProvidersProviderDeploymentsSkipLimitParameters, TData = GetProvidersProviderDeploymentsSkipLimitData>(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>
        | DeepReadonly<GetProvidersProviderDeploymentsSkipLimitParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetProvidersProviderDeploymentsSkipLimitData,
          GetProvidersProviderDeploymentsSkipLimitError,
          OperationInfiniteData<TData, GetProvidersProviderDeploymentsSkipLimitParameters>,
          GetProvidersProviderDeploymentsSkipLimitData,
          ServiceOperationInfiniteQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetProvidersProviderDeploymentsSkipLimitData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<
      OperationInfiniteData<TData, GetProvidersProviderDeploymentsSkipLimitParameters>,
      GetProvidersProviderDeploymentsSkipLimitError | Error
    >;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get a list of deployments for a provider.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getProvidersProviderDeploymentsSkipLimitData = qraft.v1Service.getProvidersProviderDeploymentsSkipLimit.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 provider: provider1,
     *                 limit: limit1
     *             },
     *             query: {
     *                 status: status1
     *             }
     *         },
     *         {
     *             path: {
     *                 provider: provider2,
     *                 limit: limit2
     *             },
     *             query: {
     *                 status: status2
     *             }
     *         }
     *     ]
     * });
     * getProvidersProviderDeploymentsSkipLimitResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getProvidersProviderDeploymentsSkipLimitCombinedData = qraft.v1Service.getProvidersProviderDeploymentsSkipLimit.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 provider: provider1,
     *                 limit: limit1
     *             },
     *             query: {
     *                 status: status1
     *             }
     *         },
     *         {
     *             path: {
     *                 provider: provider2,
     *                 limit: limit2
     *             },
     *             query: {
     *                 status: status2
     *             }
     *         }
     *     ]
     * });
     * getProvidersProviderDeploymentsSkipLimitCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<
          GetProvidersProviderDeploymentsSkipLimitSchema,
          GetProvidersProviderDeploymentsSkipLimitParameters,
          GetProvidersProviderDeploymentsSkipLimitData,
          GetProvidersProviderDeploymentsSkipLimitError
        >
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetProvidersProviderDeploymentsSkipLimitData, GetProvidersProviderDeploymentsSkipLimitError>>
    >(options: {
      queries: T;
      combine?: (
        results: Array<
          WithOptional<UseSuspenseQueryResult<GetProvidersProviderDeploymentsSkipLimitData, GetProvidersProviderDeploymentsSkipLimitError>, "data">
        >
      ) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get a list of deployments for a provider.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getProvidersProviderDeploymentsSkipLimit.useSuspenseQuery({
     *     path: {
     *         provider: provider,
     *         limit: limit
     *     },
     *     query: {
     *         status: status
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetProvidersProviderDeploymentsSkipLimitData>(
      parameters:
        | ServiceOperationQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>
        | DeepReadonly<GetProvidersProviderDeploymentsSkipLimitParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<
          GetProvidersProviderDeploymentsSkipLimitData,
          GetProvidersProviderDeploymentsSkipLimitError,
          TData,
          ServiceOperationQueryKey<GetProvidersProviderDeploymentsSkipLimitSchema, GetProvidersProviderDeploymentsSkipLimitParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetProvidersProviderDeploymentsSkipLimitError | Error>;
    schema: GetProvidersProviderDeploymentsSkipLimitSchema;
    types: {
      parameters: GetProvidersProviderDeploymentsSkipLimitParameters;
      data: GetProvidersProviderDeploymentsSkipLimitData;
      error: GetProvidersProviderDeploymentsSkipLimitError;
    };
  };
  /** @summary Create new JWT token for managed wallet */
  postCreateJwtToken: {
    /** @summary Create new JWT token for managed wallet */
    getMutationKey(
      parameters: DeepReadonly<PostCreateJwtTokenParameters> | void
    ): ServiceOperationMutationKey<PostCreateJwtTokenSchema, PostCreateJwtTokenParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Create new JWT token for managed wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postCreateJwtToken.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postCreateJwtToken.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends PostCreateJwtTokenBody, TContext = unknown>(
      parameters: DeepReadonly<PostCreateJwtTokenParameters>,
      options?: ServiceOperationUseMutationOptions<
        PostCreateJwtTokenSchema,
        PostCreateJwtTokenData,
        PostCreateJwtTokenParameters,
        TVariables,
        PostCreateJwtTokenError | Error,
        TContext
      >
    ): UseMutationResult<PostCreateJwtTokenData, PostCreateJwtTokenError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Create new JWT token for managed wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postCreateJwtToken.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postCreateJwtToken.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PostCreateJwtTokenBody, PostCreateJwtTokenParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PostCreateJwtTokenSchema,
        PostCreateJwtTokenData,
        PostCreateJwtTokenParameters,
        TVariables,
        PostCreateJwtTokenError | Error,
        TContext
      >
    ): UseMutationResult<PostCreateJwtTokenData, PostCreateJwtTokenError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Create new JWT token for managed wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const postCreateJwtTokenTotal = qraft.v1Service.postCreateJwtToken.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const postCreateJwtTokenTotal = qraft.v1Service.postCreateJwtToken.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<PostCreateJwtTokenBody, PostCreateJwtTokenData, PostCreateJwtTokenParameters, PostCreateJwtTokenError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostCreateJwtTokenSchema,
            PostCreateJwtTokenBody,
            PostCreateJwtTokenData,
            PostCreateJwtTokenParameters,
            PostCreateJwtTokenError | Error,
            TContext
          >
    ): number;
    /** @summary Create new JWT token for managed wallet */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<PostCreateJwtTokenBody, PostCreateJwtTokenData, PostCreateJwtTokenParameters, PostCreateJwtTokenError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostCreateJwtTokenSchema,
            PostCreateJwtTokenBody,
            PostCreateJwtTokenData,
            PostCreateJwtTokenParameters,
            PostCreateJwtTokenError | Error,
            TContext
          >
    ): number;
    /** @summary Create new JWT token for managed wallet */
    (
      options: ServiceOperationMutationFnOptions<PostCreateJwtTokenBody, PostCreateJwtTokenParameters>,
      client?: (
        schema: PostCreateJwtTokenSchema,
        options: ServiceOperationMutationFnOptions<PostCreateJwtTokenBody, PostCreateJwtTokenParameters>
      ) => Promise<RequestFnResponse<PostCreateJwtTokenData, PostCreateJwtTokenError>>
    ): Promise<RequestFnResponse<PostCreateJwtTokenData, PostCreateJwtTokenError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Create new JWT token for managed wallet
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const postCreateJwtTokenPendingMutationVariables = qraft.v1Service.postCreateJwtToken.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const postCreateJwtTokenMutationData = qraft.v1Service.postCreateJwtToken.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        PostCreateJwtTokenData,
        PostCreateJwtTokenError | Error,
        MutationVariables<PostCreateJwtTokenBody, PostCreateJwtTokenParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<PostCreateJwtTokenBody, PostCreateJwtTokenData, PostCreateJwtTokenParameters, PostCreateJwtTokenError | Error, TContext>
        | MutationFiltersByMutationKey<
            PostCreateJwtTokenSchema,
            PostCreateJwtTokenBody,
            PostCreateJwtTokenData,
            PostCreateJwtTokenParameters,
            PostCreateJwtTokenError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          PostCreateJwtTokenData,
          PostCreateJwtTokenError | Error,
          MutationVariables<PostCreateJwtTokenBody, PostCreateJwtTokenParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: PostCreateJwtTokenSchema;
    types: {
      parameters: PostCreateJwtTokenParameters;
      data: PostCreateJwtTokenData;
      error: PostCreateJwtTokenError;
      body: PostCreateJwtTokenBody;
    };
  };
  getGraphDataDataName: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGraphDataDataNameSchema, GetGraphDataDataNameData, TInfinite, GetGraphDataDataNameParameters, GetGraphDataDataNameError>
        | QueryFiltersByQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameData, TInfinite, GetGraphDataDataNameParameters, GetGraphDataDataNameError>,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(parameters: DeepReadonly<GetGraphDataDataNameParameters>): ServiceOperationQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGraphDataDataName.useQuery({
     *     path: {
     *         dataName: dataName
     *     }
     * })
     * ```
     */
    useQuery<TData = GetGraphDataDataNameData>(
      parameters: ServiceOperationQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters> | DeepReadonly<GetGraphDataDataNameParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetGraphDataDataNameData,
          GetGraphDataDataNameError,
          TData,
          ServiceOperationQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetGraphDataDataNameError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGraphDataDataName.useQuery({
     *     path: {
     *         dataName: dataName
     *     }
     * })
     * ```
     */
    useQuery<TData = GetGraphDataDataNameData>(
      parameters: ServiceOperationQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters> | DeepReadonly<GetGraphDataDataNameParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetGraphDataDataNameData,
          GetGraphDataDataNameError,
          TData,
          ServiceOperationQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetGraphDataDataNameError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetGraphDataDataNameParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetGraphDataDataNameSchema,
        GetGraphDataDataNameData,
        GetGraphDataDataNameParameters,
        DeepReadonly<TPageParam>,
        GetGraphDataDataNameError
      >
    ): Promise<OperationInfiniteData<GetGraphDataDataNameData, GetGraphDataDataNameParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetGraphDataDataNameParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetGraphDataDataNameSchema,
        GetGraphDataDataNameData,
        GetGraphDataDataNameParameters,
        DeepReadonly<TPageParam>,
        GetGraphDataDataNameError
      >
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetGraphDataDataNameParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetGraphDataDataNameSchema,
        GetGraphDataDataNameData,
        GetGraphDataDataNameParameters,
        DeepReadonly<TPageParam>,
        GetGraphDataDataNameError
      >
    ): Promise<OperationInfiniteData<GetGraphDataDataNameData, GetGraphDataDataNameParameters>>;
    /**/
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetGraphDataDataNameSchema,
        GetGraphDataDataNameData,
        GetGraphDataDataNameParameters,
        GetGraphDataDataNameError
      >
    ): Promise<GetGraphDataDataNameData>;
    /**/
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetGraphDataDataNameSchema,
        GetGraphDataDataNameData,
        GetGraphDataDataNameParameters,
        GetGraphDataDataNameError
      >
    ): Promise<void>;
    /**/
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetGraphDataDataNameSchema,
        GetGraphDataDataNameData,
        GetGraphDataDataNameParameters,
        GetGraphDataDataNameError
      >
    ): Promise<GetGraphDataDataNameData>;
    /**/
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters> | DeepReadonly<GetGraphDataDataNameParameters>
    ): OperationInfiniteData<GetGraphDataDataNameData, GetGraphDataDataNameParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGraphDataDataNameSchema, GetGraphDataDataNameData, TInfinite, GetGraphDataDataNameParameters, GetGraphDataDataNameError>
        | QueryFiltersByQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameData, TInfinite, GetGraphDataDataNameParameters, GetGraphDataDataNameError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters>,
            data: NoInfer<OperationInfiniteData<GetGraphDataDataNameData, GetGraphDataDataNameParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters>, data: GetGraphDataDataNameData | undefined]>;
    /**/
    getQueryData(
      parameters: ServiceOperationQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters> | DeepReadonly<GetGraphDataDataNameParameters>
    ): GetGraphDataDataNameData | undefined;
    /**/
    getQueryState(
      parameters: ServiceOperationQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters> | DeepReadonly<GetGraphDataDataNameParameters>
    ): QueryState<GetGraphDataDataNameData, GetGraphDataDataNameError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters: DeepReadonly<GetGraphDataDataNameParameters> | ServiceOperationInfiniteQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters>
    ): QueryState<OperationInfiniteData<GetGraphDataDataNameData, GetGraphDataDataNameParameters>, GetGraphDataDataNameError> | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<
        GetGraphDataDataNameSchema,
        GetGraphDataDataNameData,
        TInfinite,
        GetGraphDataDataNameParameters,
        GetGraphDataDataNameError
      >,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGraphDataDataNameSchema, GetGraphDataDataNameData, TInfinite, GetGraphDataDataNameParameters, GetGraphDataDataNameError>
        | QueryFiltersByQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameData, TInfinite, GetGraphDataDataNameParameters, GetGraphDataDataNameError>
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetGraphDataDataNameParameters, TMeta, TSignal>,
      client?: (
        schema: GetGraphDataDataNameSchema,
        options: {
          parameters: GetGraphDataDataNameParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetGraphDataDataNameData, GetGraphDataDataNameError>>
    ): Promise<RequestFnResponse<GetGraphDataDataNameData, GetGraphDataDataNameError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGraphDataDataNameSchema, GetGraphDataDataNameData, TInfinite, GetGraphDataDataNameParameters, GetGraphDataDataNameError>
        | QueryFiltersByQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameData, TInfinite, GetGraphDataDataNameParameters, GetGraphDataDataNameError>,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGraphDataDataNameSchema, GetGraphDataDataNameData, TInfinite, GetGraphDataDataNameParameters, GetGraphDataDataNameError>
        | QueryFiltersByQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameData, TInfinite, GetGraphDataDataNameParameters, GetGraphDataDataNameError>
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGraphDataDataNameSchema, GetGraphDataDataNameData, TInfinite, GetGraphDataDataNameParameters, GetGraphDataDataNameError>
        | QueryFiltersByQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameData, TInfinite, GetGraphDataDataNameParameters, GetGraphDataDataNameError>,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters: DeepReadonly<GetGraphDataDataNameParameters> | ServiceOperationInfiniteQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetGraphDataDataNameData, GetGraphDataDataNameParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetGraphDataDataNameData, GetGraphDataDataNameParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetGraphDataDataNameData, GetGraphDataDataNameParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetGraphDataDataNameSchema, GetGraphDataDataNameData, TInfinite, GetGraphDataDataNameParameters, GetGraphDataDataNameError>
        | QueryFiltersByQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameData, TInfinite, GetGraphDataDataNameParameters, GetGraphDataDataNameError>,
      updater: Updater<NoInfer<GetGraphDataDataNameData> | undefined, NoInfer<GetGraphDataDataNameData> | undefined>,
      options?: SetDataOptions
    ): Array<GetGraphDataDataNameData | undefined>;
    /**/
    setQueryData(
      parameters: DeepReadonly<GetGraphDataDataNameParameters> | ServiceOperationQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters>,
      updater: Updater<NoInfer<GetGraphDataDataNameData> | undefined, NoInfer<DeepReadonly<GetGraphDataDataNameData>> | undefined>,
      options?: SetDataOptions
    ): GetGraphDataDataNameData | undefined;
    /**/
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetGraphDataDataNameParameters>
    ): ServiceOperationInfiniteQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGraphDataDataName.useInfiniteQuery({
     *     path: {
     *         dataName: dataName
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetGraphDataDataNameParameters,
      TQueryFnData = GetGraphDataDataNameData,
      TData = OperationInfiniteData<TQueryFnData, GetGraphDataDataNameParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters> | DeepReadonly<GetGraphDataDataNameParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetGraphDataDataNameError,
          TData,
          ServiceOperationInfiniteQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetGraphDataDataNameError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGraphDataDataName.useInfiniteQuery({
     *     path: {
     *         dataName: dataName
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetGraphDataDataNameParameters,
      TQueryFnData = GetGraphDataDataNameData,
      TData = OperationInfiniteData<TQueryFnData, GetGraphDataDataNameParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters> | DeepReadonly<GetGraphDataDataNameParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetGraphDataDataNameError,
          TData,
          ServiceOperationInfiniteQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetGraphDataDataNameData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetGraphDataDataNameError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getGraphDataDataNameTotal = qraft.v1Service.getGraphDataDataName.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getGraphDataDataNameByParametersTotal = qraft.v1Service.getGraphDataDataName.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             dataName: dataName
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGraphDataDataNameSchema, GetGraphDataDataNameData, TInfinite, GetGraphDataDataNameParameters, GetGraphDataDataNameError>
        | QueryFiltersByQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameData, TInfinite, GetGraphDataDataNameParameters, GetGraphDataDataNameError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getGraphDataDataNameResults = qraft.v1Service.getGraphDataDataName.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 dataName: dataName1
     *             }
     *         },
     *         {
     *             path: {
     *                 dataName: dataName2
     *             }
     *         }
     *     ]
     * });
     * getGraphDataDataNameResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getGraphDataDataNameCombinedResults = qraft.v1Service.getGraphDataDataName.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 dataName: dataName1
     *             }
     *         },
     *         {
     *             path: {
     *                 dataName: dataName2
     *             }
     *         }
     *     ]
     * });
     * getGraphDataDataNameCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters, GetGraphDataDataNameData, GetGraphDataDataNameError>
      >,
      TCombinedResult = Array<UseQueryResult<GetGraphDataDataNameData, GetGraphDataDataNameError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetGraphDataDataNameData, GetGraphDataDataNameError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(parameters: DeepReadonly<GetGraphDataDataNameParameters>): ServiceOperationQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGraphDataDataName.useQuery({
     *     path: {
     *         dataName: dataName
     *     }
     * })
     * ```
     */
    useQuery<TData = GetGraphDataDataNameData>(
      parameters: ServiceOperationQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters> | DeepReadonly<GetGraphDataDataNameParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetGraphDataDataNameData,
          GetGraphDataDataNameError,
          TData,
          ServiceOperationQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetGraphDataDataNameError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGraphDataDataName.useQuery({
     *     path: {
     *         dataName: dataName
     *     }
     * })
     * ```
     */
    useQuery<TData = GetGraphDataDataNameData>(
      parameters: ServiceOperationQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters> | DeepReadonly<GetGraphDataDataNameParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetGraphDataDataNameData,
          GetGraphDataDataNameError,
          TData,
          ServiceOperationQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetGraphDataDataNameError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGraphDataDataName.useSuspenseInfiniteQuery({
     *     path: {
     *         dataName: dataName
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetGraphDataDataNameParameters, TData = GetGraphDataDataNameData>(
      parameters: ServiceOperationInfiniteQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters> | DeepReadonly<GetGraphDataDataNameParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetGraphDataDataNameData,
          GetGraphDataDataNameError,
          OperationInfiniteData<TData, GetGraphDataDataNameParameters>,
          GetGraphDataDataNameData,
          ServiceOperationInfiniteQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetGraphDataDataNameData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetGraphDataDataNameParameters>, GetGraphDataDataNameError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getGraphDataDataNameData = qraft.v1Service.getGraphDataDataName.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 dataName: dataName1
     *             }
     *         },
     *         {
     *             path: {
     *                 dataName: dataName2
     *             }
     *         }
     *     ]
     * });
     * getGraphDataDataNameResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getGraphDataDataNameCombinedData = qraft.v1Service.getGraphDataDataName.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 dataName: dataName1
     *             }
     *         },
     *         {
     *             path: {
     *                 dataName: dataName2
     *             }
     *         }
     *     ]
     * });
     * getGraphDataDataNameCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters, GetGraphDataDataNameData, GetGraphDataDataNameError>
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetGraphDataDataNameData, GetGraphDataDataNameError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetGraphDataDataNameData, GetGraphDataDataNameError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getGraphDataDataName.useSuspenseQuery({
     *     path: {
     *         dataName: dataName
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetGraphDataDataNameData>(
      parameters: ServiceOperationQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters> | DeepReadonly<GetGraphDataDataNameParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<
          GetGraphDataDataNameData,
          GetGraphDataDataNameError,
          TData,
          ServiceOperationQueryKey<GetGraphDataDataNameSchema, GetGraphDataDataNameParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetGraphDataDataNameError | Error>;
    schema: GetGraphDataDataNameSchema;
    types: {
      parameters: GetGraphDataDataNameParameters;
      data: GetGraphDataDataNameData;
      error: GetGraphDataDataNameError;
    };
  };
  getDashboardData: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDashboardDataSchema, GetDashboardDataData, TInfinite, GetDashboardDataParameters, GetDashboardDataError>
        | QueryFiltersByQueryKey<GetDashboardDataSchema, GetDashboardDataData, TInfinite, GetDashboardDataParameters, GetDashboardDataError>,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(parameters: DeepReadonly<GetDashboardDataParameters> | void): ServiceOperationQueryKey<GetDashboardDataSchema, GetDashboardDataParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDashboardData.useQuery()
     * ```
     */
    useQuery<TData = GetDashboardDataData>(
      parameters: ServiceOperationQueryKey<GetDashboardDataSchema, GetDashboardDataParameters> | (DeepReadonly<GetDashboardDataParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetDashboardDataData,
          GetDashboardDataError,
          TData,
          ServiceOperationQueryKey<GetDashboardDataSchema, GetDashboardDataParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetDashboardDataError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDashboardData.useQuery()
     * ```
     */
    useQuery<TData = GetDashboardDataData>(
      parameters: ServiceOperationQueryKey<GetDashboardDataSchema, GetDashboardDataParameters> | (DeepReadonly<GetDashboardDataParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetDashboardDataData,
          GetDashboardDataError,
          TData,
          ServiceOperationQueryKey<GetDashboardDataSchema, GetDashboardDataParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetDashboardDataError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetDashboardDataParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetDashboardDataSchema,
        GetDashboardDataData,
        GetDashboardDataParameters,
        DeepReadonly<TPageParam>,
        GetDashboardDataError
      > | void
    ): Promise<OperationInfiniteData<GetDashboardDataData, GetDashboardDataParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetDashboardDataParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetDashboardDataSchema,
        GetDashboardDataData,
        GetDashboardDataParameters,
        DeepReadonly<TPageParam>,
        GetDashboardDataError
      > | void
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetDashboardDataParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetDashboardDataSchema,
        GetDashboardDataData,
        GetDashboardDataParameters,
        DeepReadonly<TPageParam>,
        GetDashboardDataError
      > | void
    ): Promise<OperationInfiniteData<GetDashboardDataData, GetDashboardDataParameters>>;
    /**/
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetDashboardDataSchema, GetDashboardDataData, GetDashboardDataParameters, GetDashboardDataError> | void
    ): Promise<GetDashboardDataData>;
    /**/
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetDashboardDataSchema, GetDashboardDataData, GetDashboardDataParameters, GetDashboardDataError> | void
    ): Promise<void>;
    /**/
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetDashboardDataSchema, GetDashboardDataData, GetDashboardDataParameters, GetDashboardDataError> | void
    ): Promise<GetDashboardDataData>;
    /**/
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetDashboardDataSchema, GetDashboardDataParameters> | (DeepReadonly<GetDashboardDataParameters> | void)
    ): OperationInfiniteData<GetDashboardDataData, GetDashboardDataParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDashboardDataSchema, GetDashboardDataData, TInfinite, GetDashboardDataParameters, GetDashboardDataError>
        | QueryFiltersByQueryKey<GetDashboardDataSchema, GetDashboardDataData, TInfinite, GetDashboardDataParameters, GetDashboardDataError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetDashboardDataSchema, GetDashboardDataParameters>,
            data: NoInfer<OperationInfiniteData<GetDashboardDataData, GetDashboardDataParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetDashboardDataSchema, GetDashboardDataParameters>, data: GetDashboardDataData | undefined]>;
    /**/
    getQueryData(
      parameters: ServiceOperationQueryKey<GetDashboardDataSchema, GetDashboardDataParameters> | (DeepReadonly<GetDashboardDataParameters> | void)
    ): GetDashboardDataData | undefined;
    /**/
    getQueryState(
      parameters: ServiceOperationQueryKey<GetDashboardDataSchema, GetDashboardDataParameters> | (DeepReadonly<GetDashboardDataParameters> | void)
    ): QueryState<GetDashboardDataData, GetDashboardDataError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters: DeepReadonly<GetDashboardDataParameters> | ServiceOperationInfiniteQueryKey<GetDashboardDataSchema, GetDashboardDataParameters> | void
    ): QueryState<OperationInfiniteData<GetDashboardDataData, GetDashboardDataParameters>, GetDashboardDataError> | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetDashboardDataSchema, GetDashboardDataData, TInfinite, GetDashboardDataParameters, GetDashboardDataError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDashboardDataSchema, GetDashboardDataData, TInfinite, GetDashboardDataParameters, GetDashboardDataError>
        | QueryFiltersByQueryKey<GetDashboardDataSchema, GetDashboardDataData, TInfinite, GetDashboardDataParameters, GetDashboardDataError>
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetDashboardDataSchema, GetDashboardDataParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetDashboardDataParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetDashboardDataSchema,
        options: {
          parameters: GetDashboardDataParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetDashboardDataData, GetDashboardDataError>>
    ): Promise<RequestFnResponse<GetDashboardDataData, GetDashboardDataError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDashboardDataSchema, GetDashboardDataData, TInfinite, GetDashboardDataParameters, GetDashboardDataError>
        | QueryFiltersByQueryKey<GetDashboardDataSchema, GetDashboardDataData, TInfinite, GetDashboardDataParameters, GetDashboardDataError>,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDashboardDataSchema, GetDashboardDataData, TInfinite, GetDashboardDataParameters, GetDashboardDataError>
        | QueryFiltersByQueryKey<GetDashboardDataSchema, GetDashboardDataData, TInfinite, GetDashboardDataParameters, GetDashboardDataError>
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDashboardDataSchema, GetDashboardDataData, TInfinite, GetDashboardDataParameters, GetDashboardDataError>
        | QueryFiltersByQueryKey<GetDashboardDataSchema, GetDashboardDataData, TInfinite, GetDashboardDataParameters, GetDashboardDataError>,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters: (DeepReadonly<GetDashboardDataParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetDashboardDataSchema, GetDashboardDataParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetDashboardDataData, GetDashboardDataParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetDashboardDataData, GetDashboardDataParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetDashboardDataData, GetDashboardDataParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetDashboardDataSchema, GetDashboardDataData, TInfinite, GetDashboardDataParameters, GetDashboardDataError>
        | QueryFiltersByQueryKey<GetDashboardDataSchema, GetDashboardDataData, TInfinite, GetDashboardDataParameters, GetDashboardDataError>,
      updater: Updater<NoInfer<GetDashboardDataData> | undefined, NoInfer<GetDashboardDataData> | undefined>,
      options?: SetDataOptions
    ): Array<GetDashboardDataData | undefined>;
    /**/
    setQueryData(
      parameters: (DeepReadonly<GetDashboardDataParameters> | undefined) | ServiceOperationQueryKey<GetDashboardDataSchema, GetDashboardDataParameters>,
      updater: Updater<NoInfer<GetDashboardDataData> | undefined, NoInfer<DeepReadonly<GetDashboardDataData>> | undefined>,
      options?: SetDataOptions
    ): GetDashboardDataData | undefined;
    /**/
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetDashboardDataParameters> | void
    ): ServiceOperationInfiniteQueryKey<GetDashboardDataSchema, GetDashboardDataParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getDashboardData.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetDashboardDataParameters,
      TQueryFnData = GetDashboardDataData,
      TData = OperationInfiniteData<TQueryFnData, GetDashboardDataParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetDashboardDataSchema, GetDashboardDataParameters> | (DeepReadonly<GetDashboardDataParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetDashboardDataError,
          TData,
          ServiceOperationInfiniteQueryKey<GetDashboardDataSchema, GetDashboardDataParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetDashboardDataError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getDashboardData.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetDashboardDataParameters,
      TQueryFnData = GetDashboardDataData,
      TData = OperationInfiniteData<TQueryFnData, GetDashboardDataParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetDashboardDataSchema, GetDashboardDataParameters> | (DeepReadonly<GetDashboardDataParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetDashboardDataError,
          TData,
          ServiceOperationInfiniteQueryKey<GetDashboardDataSchema, GetDashboardDataParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetDashboardDataData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetDashboardDataError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getDashboardDataTotal = qraft.v1Service.getDashboardData.useIsFetching()
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDashboardDataSchema, GetDashboardDataData, TInfinite, GetDashboardDataParameters, GetDashboardDataError>
        | QueryFiltersByQueryKey<GetDashboardDataSchema, GetDashboardDataData, TInfinite, GetDashboardDataParameters, GetDashboardDataError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getDashboardDataResults = qraft.v1Service.getDashboardData.useQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getDashboardDataResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getDashboardDataCombinedResults = qraft.v1Service.getDashboardData.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getDashboardDataCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetDashboardDataSchema, GetDashboardDataParameters, GetDashboardDataData, GetDashboardDataError>>,
      TCombinedResult = Array<UseQueryResult<GetDashboardDataData, GetDashboardDataError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetDashboardDataData, GetDashboardDataError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(parameters: DeepReadonly<GetDashboardDataParameters> | void): ServiceOperationQueryKey<GetDashboardDataSchema, GetDashboardDataParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDashboardData.useQuery()
     * ```
     */
    useQuery<TData = GetDashboardDataData>(
      parameters: ServiceOperationQueryKey<GetDashboardDataSchema, GetDashboardDataParameters> | (DeepReadonly<GetDashboardDataParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetDashboardDataData,
          GetDashboardDataError,
          TData,
          ServiceOperationQueryKey<GetDashboardDataSchema, GetDashboardDataParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetDashboardDataError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDashboardData.useQuery()
     * ```
     */
    useQuery<TData = GetDashboardDataData>(
      parameters: ServiceOperationQueryKey<GetDashboardDataSchema, GetDashboardDataParameters> | (DeepReadonly<GetDashboardDataParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetDashboardDataData,
          GetDashboardDataError,
          TData,
          ServiceOperationQueryKey<GetDashboardDataSchema, GetDashboardDataParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetDashboardDataError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getDashboardData.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetDashboardDataParameters, TData = GetDashboardDataData>(
      parameters: ServiceOperationInfiniteQueryKey<GetDashboardDataSchema, GetDashboardDataParameters> | (DeepReadonly<GetDashboardDataParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetDashboardDataData,
          GetDashboardDataError,
          OperationInfiniteData<TData, GetDashboardDataParameters>,
          GetDashboardDataData,
          ServiceOperationInfiniteQueryKey<GetDashboardDataSchema, GetDashboardDataParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetDashboardDataData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetDashboardDataParameters>, GetDashboardDataError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getDashboardDataData = qraft.v1Service.getDashboardData.useSuspenseQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getDashboardDataResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getDashboardDataCombinedData = qraft.v1Service.getDashboardData.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getDashboardDataCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetDashboardDataSchema, GetDashboardDataParameters, GetDashboardDataData, GetDashboardDataError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetDashboardDataData, GetDashboardDataError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetDashboardDataData, GetDashboardDataError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getDashboardData.useSuspenseQuery()
     * ```
     */
    useSuspenseQuery<TData = GetDashboardDataData>(
      parameters: ServiceOperationQueryKey<GetDashboardDataSchema, GetDashboardDataParameters> | (DeepReadonly<GetDashboardDataParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<
          GetDashboardDataData,
          GetDashboardDataError,
          TData,
          ServiceOperationQueryKey<GetDashboardDataSchema, GetDashboardDataParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetDashboardDataError | Error>;
    schema: GetDashboardDataSchema;
    types: {
      parameters: GetDashboardDataParameters;
      data: GetDashboardDataData;
      error: GetDashboardDataError;
    };
  };
  getNetworkCapacity: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetNetworkCapacitySchema, GetNetworkCapacityData, TInfinite, GetNetworkCapacityParameters, GetNetworkCapacityError>
        | QueryFiltersByQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityData, TInfinite, GetNetworkCapacityParameters, GetNetworkCapacityError>,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(
      parameters: DeepReadonly<GetNetworkCapacityParameters> | void
    ): ServiceOperationQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNetworkCapacity.useQuery()
     * ```
     */
    useQuery<TData = GetNetworkCapacityData>(
      parameters: ServiceOperationQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters> | (DeepReadonly<GetNetworkCapacityParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetNetworkCapacityData,
          GetNetworkCapacityError,
          TData,
          ServiceOperationQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetNetworkCapacityError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNetworkCapacity.useQuery()
     * ```
     */
    useQuery<TData = GetNetworkCapacityData>(
      parameters: ServiceOperationQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters> | (DeepReadonly<GetNetworkCapacityParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetNetworkCapacityData,
          GetNetworkCapacityError,
          TData,
          ServiceOperationQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetNetworkCapacityError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetNetworkCapacityParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetNetworkCapacitySchema,
        GetNetworkCapacityData,
        GetNetworkCapacityParameters,
        DeepReadonly<TPageParam>,
        GetNetworkCapacityError
      > | void
    ): Promise<OperationInfiniteData<GetNetworkCapacityData, GetNetworkCapacityParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetNetworkCapacityParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetNetworkCapacitySchema,
        GetNetworkCapacityData,
        GetNetworkCapacityParameters,
        DeepReadonly<TPageParam>,
        GetNetworkCapacityError
      > | void
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetNetworkCapacityParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetNetworkCapacitySchema,
        GetNetworkCapacityData,
        GetNetworkCapacityParameters,
        DeepReadonly<TPageParam>,
        GetNetworkCapacityError
      > | void
    ): Promise<OperationInfiniteData<GetNetworkCapacityData, GetNetworkCapacityParameters>>;
    /**/
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetNetworkCapacitySchema, GetNetworkCapacityData, GetNetworkCapacityParameters, GetNetworkCapacityError> | void
    ): Promise<GetNetworkCapacityData>;
    /**/
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetNetworkCapacitySchema, GetNetworkCapacityData, GetNetworkCapacityParameters, GetNetworkCapacityError> | void
    ): Promise<void>;
    /**/
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetNetworkCapacitySchema,
        GetNetworkCapacityData,
        GetNetworkCapacityParameters,
        GetNetworkCapacityError
      > | void
    ): Promise<GetNetworkCapacityData>;
    /**/
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters> | (DeepReadonly<GetNetworkCapacityParameters> | void)
    ): OperationInfiniteData<GetNetworkCapacityData, GetNetworkCapacityParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetNetworkCapacitySchema, GetNetworkCapacityData, TInfinite, GetNetworkCapacityParameters, GetNetworkCapacityError>
        | QueryFiltersByQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityData, TInfinite, GetNetworkCapacityParameters, GetNetworkCapacityError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters>,
            data: NoInfer<OperationInfiniteData<GetNetworkCapacityData, GetNetworkCapacityParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters>, data: GetNetworkCapacityData | undefined]>;
    /**/
    getQueryData(
      parameters: ServiceOperationQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters> | (DeepReadonly<GetNetworkCapacityParameters> | void)
    ): GetNetworkCapacityData | undefined;
    /**/
    getQueryState(
      parameters: ServiceOperationQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters> | (DeepReadonly<GetNetworkCapacityParameters> | void)
    ): QueryState<GetNetworkCapacityData, GetNetworkCapacityError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters: DeepReadonly<GetNetworkCapacityParameters> | ServiceOperationInfiniteQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters> | void
    ): QueryState<OperationInfiniteData<GetNetworkCapacityData, GetNetworkCapacityParameters>, GetNetworkCapacityError> | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetNetworkCapacitySchema, GetNetworkCapacityData, TInfinite, GetNetworkCapacityParameters, GetNetworkCapacityError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetNetworkCapacitySchema, GetNetworkCapacityData, TInfinite, GetNetworkCapacityParameters, GetNetworkCapacityError>
        | QueryFiltersByQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityData, TInfinite, GetNetworkCapacityParameters, GetNetworkCapacityError>
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetNetworkCapacityParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetNetworkCapacitySchema,
        options: {
          parameters: GetNetworkCapacityParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetNetworkCapacityData, GetNetworkCapacityError>>
    ): Promise<RequestFnResponse<GetNetworkCapacityData, GetNetworkCapacityError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetNetworkCapacitySchema, GetNetworkCapacityData, TInfinite, GetNetworkCapacityParameters, GetNetworkCapacityError>
        | QueryFiltersByQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityData, TInfinite, GetNetworkCapacityParameters, GetNetworkCapacityError>,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetNetworkCapacitySchema, GetNetworkCapacityData, TInfinite, GetNetworkCapacityParameters, GetNetworkCapacityError>
        | QueryFiltersByQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityData, TInfinite, GetNetworkCapacityParameters, GetNetworkCapacityError>
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetNetworkCapacitySchema, GetNetworkCapacityData, TInfinite, GetNetworkCapacityParameters, GetNetworkCapacityError>
        | QueryFiltersByQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityData, TInfinite, GetNetworkCapacityParameters, GetNetworkCapacityError>,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters:
        | (DeepReadonly<GetNetworkCapacityParameters> | undefined)
        | ServiceOperationInfiniteQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetNetworkCapacityData, GetNetworkCapacityParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetNetworkCapacityData, GetNetworkCapacityParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetNetworkCapacityData, GetNetworkCapacityParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetNetworkCapacitySchema, GetNetworkCapacityData, TInfinite, GetNetworkCapacityParameters, GetNetworkCapacityError>
        | QueryFiltersByQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityData, TInfinite, GetNetworkCapacityParameters, GetNetworkCapacityError>,
      updater: Updater<NoInfer<GetNetworkCapacityData> | undefined, NoInfer<GetNetworkCapacityData> | undefined>,
      options?: SetDataOptions
    ): Array<GetNetworkCapacityData | undefined>;
    /**/
    setQueryData(
      parameters: (DeepReadonly<GetNetworkCapacityParameters> | undefined) | ServiceOperationQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters>,
      updater: Updater<NoInfer<GetNetworkCapacityData> | undefined, NoInfer<DeepReadonly<GetNetworkCapacityData>> | undefined>,
      options?: SetDataOptions
    ): GetNetworkCapacityData | undefined;
    /**/
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetNetworkCapacityParameters> | void
    ): ServiceOperationInfiniteQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getNetworkCapacity.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetNetworkCapacityParameters,
      TQueryFnData = GetNetworkCapacityData,
      TData = OperationInfiniteData<TQueryFnData, GetNetworkCapacityParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters>
        | (DeepReadonly<GetNetworkCapacityParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetNetworkCapacityError,
          TData,
          ServiceOperationInfiniteQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetNetworkCapacityError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getNetworkCapacity.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetNetworkCapacityParameters,
      TQueryFnData = GetNetworkCapacityData,
      TData = OperationInfiniteData<TQueryFnData, GetNetworkCapacityParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters>
        | (DeepReadonly<GetNetworkCapacityParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetNetworkCapacityError,
          TData,
          ServiceOperationInfiniteQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetNetworkCapacityData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetNetworkCapacityError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getNetworkCapacityTotal = qraft.v1Service.getNetworkCapacity.useIsFetching()
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetNetworkCapacitySchema, GetNetworkCapacityData, TInfinite, GetNetworkCapacityParameters, GetNetworkCapacityError>
        | QueryFiltersByQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityData, TInfinite, GetNetworkCapacityParameters, GetNetworkCapacityError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getNetworkCapacityResults = qraft.v1Service.getNetworkCapacity.useQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getNetworkCapacityResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getNetworkCapacityCombinedResults = qraft.v1Service.getNetworkCapacity.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getNetworkCapacityCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetNetworkCapacitySchema, GetNetworkCapacityParameters, GetNetworkCapacityData, GetNetworkCapacityError>>,
      TCombinedResult = Array<UseQueryResult<GetNetworkCapacityData, GetNetworkCapacityError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetNetworkCapacityData, GetNetworkCapacityError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(
      parameters: DeepReadonly<GetNetworkCapacityParameters> | void
    ): ServiceOperationQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNetworkCapacity.useQuery()
     * ```
     */
    useQuery<TData = GetNetworkCapacityData>(
      parameters: ServiceOperationQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters> | (DeepReadonly<GetNetworkCapacityParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetNetworkCapacityData,
          GetNetworkCapacityError,
          TData,
          ServiceOperationQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetNetworkCapacityError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNetworkCapacity.useQuery()
     * ```
     */
    useQuery<TData = GetNetworkCapacityData>(
      parameters: ServiceOperationQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters> | (DeepReadonly<GetNetworkCapacityParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetNetworkCapacityData,
          GetNetworkCapacityError,
          TData,
          ServiceOperationQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetNetworkCapacityError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getNetworkCapacity.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetNetworkCapacityParameters, TData = GetNetworkCapacityData>(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters>
        | (DeepReadonly<GetNetworkCapacityParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetNetworkCapacityData,
          GetNetworkCapacityError,
          OperationInfiniteData<TData, GetNetworkCapacityParameters>,
          GetNetworkCapacityData,
          ServiceOperationInfiniteQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetNetworkCapacityData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetNetworkCapacityParameters>, GetNetworkCapacityError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getNetworkCapacityData = qraft.v1Service.getNetworkCapacity.useSuspenseQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getNetworkCapacityResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getNetworkCapacityCombinedData = qraft.v1Service.getNetworkCapacity.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getNetworkCapacityCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<GetNetworkCapacitySchema, GetNetworkCapacityParameters, GetNetworkCapacityData, GetNetworkCapacityError>
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetNetworkCapacityData, GetNetworkCapacityError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetNetworkCapacityData, GetNetworkCapacityError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getNetworkCapacity.useSuspenseQuery()
     * ```
     */
    useSuspenseQuery<TData = GetNetworkCapacityData>(
      parameters: ServiceOperationQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters> | (DeepReadonly<GetNetworkCapacityParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<
          GetNetworkCapacityData,
          GetNetworkCapacityError,
          TData,
          ServiceOperationQueryKey<GetNetworkCapacitySchema, GetNetworkCapacityParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetNetworkCapacityError | Error>;
    schema: GetNetworkCapacitySchema;
    types: {
      parameters: GetNetworkCapacityParameters;
      data: GetNetworkCapacityData;
      error: GetNetworkCapacityError;
    };
  };
  /** @summary Get a list of recent blocks. */
  getBlocks: {
    /** @summary Get a list of recent blocks. */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBlocksSchema, GetBlocksData, TInfinite, GetBlocksParameters, GetBlocksError>
        | QueryFiltersByQueryKey<GetBlocksSchema, GetBlocksData, TInfinite, GetBlocksParameters, GetBlocksError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get a list of recent blocks. */
    getQueryKey(parameters: DeepReadonly<GetBlocksParameters> | void): ServiceOperationQueryKey<GetBlocksSchema, GetBlocksParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of recent blocks.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBlocks.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBlocks.useQuery({
     *     query: {
     *         limit: limit
     *     }
     * })
     * ```
     */
    useQuery<TData = GetBlocksData>(
      parameters: ServiceOperationQueryKey<GetBlocksSchema, GetBlocksParameters> | (DeepReadonly<GetBlocksParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetBlocksData, GetBlocksError, TData, ServiceOperationQueryKey<GetBlocksSchema, GetBlocksParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetBlocksError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of recent blocks.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBlocks.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBlocks.useQuery({
     *     query: {
     *         limit: limit
     *     }
     * })
     * ```
     */
    useQuery<TData = GetBlocksData>(
      parameters: ServiceOperationQueryKey<GetBlocksSchema, GetBlocksParameters> | (DeepReadonly<GetBlocksParameters> | void),
      options: Omit<DefinedInitialDataOptions<GetBlocksData, GetBlocksError, TData, ServiceOperationQueryKey<GetBlocksSchema, GetBlocksParameters>>, "queryKey">
    ): DefinedUseQueryResult<TData, GetBlocksError | Error>;
    /** @summary Get a list of recent blocks. */
    fetchInfiniteQuery<TPageParam extends GetBlocksParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<GetBlocksSchema, GetBlocksData, GetBlocksParameters, DeepReadonly<TPageParam>, GetBlocksError> | void
    ): Promise<OperationInfiniteData<GetBlocksData, GetBlocksParameters>>;
    /** @summary Get a list of recent blocks. */
    prefetchInfiniteQuery<TPageParam extends GetBlocksParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<GetBlocksSchema, GetBlocksData, GetBlocksParameters, DeepReadonly<TPageParam>, GetBlocksError> | void
    ): Promise<void>;
    /** @summary Get a list of recent blocks. */
    ensureInfiniteQueryData<TPageParam extends GetBlocksParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetBlocksSchema,
        GetBlocksData,
        GetBlocksParameters,
        DeepReadonly<TPageParam>,
        GetBlocksError
      > | void
    ): Promise<OperationInfiniteData<GetBlocksData, GetBlocksParameters>>;
    /** @summary Get a list of recent blocks. */
    fetchQuery(options: ServiceOperationFetchQueryOptions<GetBlocksSchema, GetBlocksData, GetBlocksParameters, GetBlocksError> | void): Promise<GetBlocksData>;
    /** @summary Get a list of recent blocks. */
    prefetchQuery(options: ServiceOperationFetchQueryOptions<GetBlocksSchema, GetBlocksData, GetBlocksParameters, GetBlocksError> | void): Promise<void>;
    /** @summary Get a list of recent blocks. */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetBlocksSchema, GetBlocksData, GetBlocksParameters, GetBlocksError> | void
    ): Promise<GetBlocksData>;
    /** @summary Get a list of recent blocks. */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetBlocksSchema, GetBlocksParameters> | (DeepReadonly<GetBlocksParameters> | void)
    ): OperationInfiniteData<GetBlocksData, GetBlocksParameters> | undefined;
    /** @summary Get a list of recent blocks. */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBlocksSchema, GetBlocksData, TInfinite, GetBlocksParameters, GetBlocksError>
        | QueryFiltersByQueryKey<GetBlocksSchema, GetBlocksData, TInfinite, GetBlocksParameters, GetBlocksError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetBlocksSchema, GetBlocksParameters>,
            data: NoInfer<OperationInfiniteData<GetBlocksData, GetBlocksParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetBlocksSchema, GetBlocksParameters>, data: GetBlocksData | undefined]>;
    /** @summary Get a list of recent blocks. */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetBlocksSchema, GetBlocksParameters> | (DeepReadonly<GetBlocksParameters> | void)
    ): GetBlocksData | undefined;
    /** @summary Get a list of recent blocks. */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetBlocksSchema, GetBlocksParameters> | (DeepReadonly<GetBlocksParameters> | void)
    ): QueryState<GetBlocksData, GetBlocksError> | undefined;
    /** @summary Get a list of recent blocks. */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetBlocksParameters> | ServiceOperationInfiniteQueryKey<GetBlocksSchema, GetBlocksParameters> | void
    ): QueryState<OperationInfiniteData<GetBlocksData, GetBlocksParameters>, GetBlocksError> | undefined;
    /** @summary Get a list of recent blocks. */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetBlocksSchema, GetBlocksData, TInfinite, GetBlocksParameters, GetBlocksError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get a list of recent blocks. */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBlocksSchema, GetBlocksData, TInfinite, GetBlocksParameters, GetBlocksError>
        | QueryFiltersByQueryKey<GetBlocksSchema, GetBlocksData, TInfinite, GetBlocksParameters, GetBlocksError>
    ): number;
    /** @summary Get a list of recent blocks. */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetBlocksSchema, GetBlocksParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetBlocksParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetBlocksSchema,
        options: {
          parameters: GetBlocksParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetBlocksData, GetBlocksError>>
    ): Promise<RequestFnResponse<GetBlocksData, GetBlocksError>>;
    /** @summary Get a list of recent blocks. */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBlocksSchema, GetBlocksData, TInfinite, GetBlocksParameters, GetBlocksError>
        | QueryFiltersByQueryKey<GetBlocksSchema, GetBlocksData, TInfinite, GetBlocksParameters, GetBlocksError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get a list of recent blocks. */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBlocksSchema, GetBlocksData, TInfinite, GetBlocksParameters, GetBlocksError>
        | QueryFiltersByQueryKey<GetBlocksSchema, GetBlocksData, TInfinite, GetBlocksParameters, GetBlocksError>
    ): void;
    /** @summary Get a list of recent blocks. */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBlocksSchema, GetBlocksData, TInfinite, GetBlocksParameters, GetBlocksError>
        | QueryFiltersByQueryKey<GetBlocksSchema, GetBlocksData, TInfinite, GetBlocksParameters, GetBlocksError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get a list of recent blocks. */
    setInfiniteQueryData(
      parameters: (DeepReadonly<GetBlocksParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetBlocksSchema, GetBlocksParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetBlocksData, GetBlocksParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetBlocksData, GetBlocksParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetBlocksData, GetBlocksParameters> | undefined;
    /** @summary Get a list of recent blocks. */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetBlocksSchema, GetBlocksData, TInfinite, GetBlocksParameters, GetBlocksError>
        | QueryFiltersByQueryKey<GetBlocksSchema, GetBlocksData, TInfinite, GetBlocksParameters, GetBlocksError>,
      updater: Updater<NoInfer<GetBlocksData> | undefined, NoInfer<GetBlocksData> | undefined>,
      options?: SetDataOptions
    ): Array<GetBlocksData | undefined>;
    /** @summary Get a list of recent blocks. */
    setQueryData(
      parameters: (DeepReadonly<GetBlocksParameters> | undefined) | ServiceOperationQueryKey<GetBlocksSchema, GetBlocksParameters>,
      updater: Updater<NoInfer<GetBlocksData> | undefined, NoInfer<DeepReadonly<GetBlocksData>> | undefined>,
      options?: SetDataOptions
    ): GetBlocksData | undefined;
    /** @summary Get a list of recent blocks. */
    getInfiniteQueryKey(parameters: DeepReadonly<GetBlocksParameters> | void): ServiceOperationInfiniteQueryKey<GetBlocksSchema, GetBlocksParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of recent blocks.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getBlocks.useInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             limit: initialLimit
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<TPageParam extends GetBlocksParameters, TQueryFnData = GetBlocksData, TData = OperationInfiniteData<TQueryFnData, GetBlocksParameters>>(
      parameters: ServiceOperationInfiniteQueryKey<GetBlocksSchema, GetBlocksParameters> | (DeepReadonly<GetBlocksParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetBlocksError,
          TData,
          ServiceOperationInfiniteQueryKey<GetBlocksSchema, GetBlocksParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetBlocksError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of recent blocks.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getBlocks.useInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             limit: initialLimit
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<TPageParam extends GetBlocksParameters, TQueryFnData = GetBlocksData, TData = OperationInfiniteData<TQueryFnData, GetBlocksParameters>>(
      parameters: ServiceOperationInfiniteQueryKey<GetBlocksSchema, GetBlocksParameters> | (DeepReadonly<GetBlocksParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetBlocksError,
          TData,
          ServiceOperationInfiniteQueryKey<GetBlocksSchema, GetBlocksParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetBlocksData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetBlocksError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get a list of recent blocks.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getBlocksTotal = qraft.v1Service.getBlocks.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getBlocksByParametersTotal = qraft.v1Service.getBlocks.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         query: {
     *             limit: limit
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBlocksSchema, GetBlocksData, TInfinite, GetBlocksParameters, GetBlocksError>
        | QueryFiltersByQueryKey<GetBlocksSchema, GetBlocksData, TInfinite, GetBlocksParameters, GetBlocksError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get a list of recent blocks.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getBlocksResults = qraft.v1Service.getBlocks.useQueries({
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             }
     *         }
     *     ]
     * });
     * getBlocksResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getBlocksCombinedResults = qraft.v1Service.getBlocks.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             }
     *         }
     *     ]
     * });
     * getBlocksCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetBlocksSchema, GetBlocksParameters, GetBlocksData, GetBlocksError>>,
      TCombinedResult = Array<UseQueryResult<GetBlocksData, GetBlocksError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetBlocksData, GetBlocksError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get a list of recent blocks. */
    getQueryKey(parameters: DeepReadonly<GetBlocksParameters> | void): ServiceOperationQueryKey<GetBlocksSchema, GetBlocksParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of recent blocks.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBlocks.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBlocks.useQuery({
     *     query: {
     *         limit: limit
     *     }
     * })
     * ```
     */
    useQuery<TData = GetBlocksData>(
      parameters: ServiceOperationQueryKey<GetBlocksSchema, GetBlocksParameters> | (DeepReadonly<GetBlocksParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetBlocksData, GetBlocksError, TData, ServiceOperationQueryKey<GetBlocksSchema, GetBlocksParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetBlocksError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of recent blocks.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBlocks.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBlocks.useQuery({
     *     query: {
     *         limit: limit
     *     }
     * })
     * ```
     */
    useQuery<TData = GetBlocksData>(
      parameters: ServiceOperationQueryKey<GetBlocksSchema, GetBlocksParameters> | (DeepReadonly<GetBlocksParameters> | void),
      options: Omit<DefinedInitialDataOptions<GetBlocksData, GetBlocksError, TData, ServiceOperationQueryKey<GetBlocksSchema, GetBlocksParameters>>, "queryKey">
    ): DefinedUseQueryResult<TData, GetBlocksError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get a list of recent blocks.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getBlocks.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             limit: initialLimit
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetBlocksParameters, TData = GetBlocksData>(
      parameters: ServiceOperationInfiniteQueryKey<GetBlocksSchema, GetBlocksParameters> | (DeepReadonly<GetBlocksParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetBlocksData,
          GetBlocksError,
          OperationInfiniteData<TData, GetBlocksParameters>,
          GetBlocksData,
          ServiceOperationInfiniteQueryKey<GetBlocksSchema, GetBlocksParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetBlocksData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetBlocksParameters>, GetBlocksError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get a list of recent blocks.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getBlocksData = qraft.v1Service.getBlocks.useSuspenseQueries({
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             }
     *         }
     *     ]
     * });
     * getBlocksResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getBlocksCombinedData = qraft.v1Service.getBlocks.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             }
     *         }
     *     ]
     * });
     * getBlocksCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetBlocksSchema, GetBlocksParameters, GetBlocksData, GetBlocksError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetBlocksData, GetBlocksError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetBlocksData, GetBlocksError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get a list of recent blocks.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getBlocks.useSuspenseQuery()
     * ```
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getBlocks.useSuspenseQuery({
     *     query: {
     *         limit: limit
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetBlocksData>(
      parameters: ServiceOperationQueryKey<GetBlocksSchema, GetBlocksParameters> | (DeepReadonly<GetBlocksParameters> | void),
      options?: Omit<UseSuspenseQueryOptions<GetBlocksData, GetBlocksError, TData, ServiceOperationQueryKey<GetBlocksSchema, GetBlocksParameters>>, "queryKey">
    ): UseSuspenseQueryResult<TData, GetBlocksError | Error>;
    schema: GetBlocksSchema;
    types: {
      parameters: GetBlocksParameters;
      data: GetBlocksData;
      error: GetBlocksError;
    };
  };
  /** @summary Get a block by height. */
  getBlocksHeight: {
    /** @summary Get a block by height. */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBlocksHeightSchema, GetBlocksHeightData, TInfinite, GetBlocksHeightParameters, GetBlocksHeightError>
        | QueryFiltersByQueryKey<GetBlocksHeightSchema, GetBlocksHeightData, TInfinite, GetBlocksHeightParameters, GetBlocksHeightError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get a block by height. */
    getQueryKey(parameters: DeepReadonly<GetBlocksHeightParameters> | void): ServiceOperationQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a block by height.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBlocksHeight.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBlocksHeight.useQuery({
     *     path: {
     *         height: height
     *     }
     * })
     * ```
     */
    useQuery<TData = GetBlocksHeightData>(
      parameters: ServiceOperationQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters> | (DeepReadonly<GetBlocksHeightParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetBlocksHeightData,
          GetBlocksHeightError,
          TData,
          ServiceOperationQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetBlocksHeightError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a block by height.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBlocksHeight.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBlocksHeight.useQuery({
     *     path: {
     *         height: height
     *     }
     * })
     * ```
     */
    useQuery<TData = GetBlocksHeightData>(
      parameters: ServiceOperationQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters> | (DeepReadonly<GetBlocksHeightParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetBlocksHeightData, GetBlocksHeightError, TData, ServiceOperationQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetBlocksHeightError | Error>;
    /** @summary Get a block by height. */
    fetchInfiniteQuery<TPageParam extends GetBlocksHeightParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetBlocksHeightSchema,
        GetBlocksHeightData,
        GetBlocksHeightParameters,
        DeepReadonly<TPageParam>,
        GetBlocksHeightError
      > | void
    ): Promise<OperationInfiniteData<GetBlocksHeightData, GetBlocksHeightParameters>>;
    /** @summary Get a block by height. */
    prefetchInfiniteQuery<TPageParam extends GetBlocksHeightParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetBlocksHeightSchema,
        GetBlocksHeightData,
        GetBlocksHeightParameters,
        DeepReadonly<TPageParam>,
        GetBlocksHeightError
      > | void
    ): Promise<void>;
    /** @summary Get a block by height. */
    ensureInfiniteQueryData<TPageParam extends GetBlocksHeightParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetBlocksHeightSchema,
        GetBlocksHeightData,
        GetBlocksHeightParameters,
        DeepReadonly<TPageParam>,
        GetBlocksHeightError
      > | void
    ): Promise<OperationInfiniteData<GetBlocksHeightData, GetBlocksHeightParameters>>;
    /** @summary Get a block by height. */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetBlocksHeightSchema, GetBlocksHeightData, GetBlocksHeightParameters, GetBlocksHeightError> | void
    ): Promise<GetBlocksHeightData>;
    /** @summary Get a block by height. */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetBlocksHeightSchema, GetBlocksHeightData, GetBlocksHeightParameters, GetBlocksHeightError> | void
    ): Promise<void>;
    /** @summary Get a block by height. */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetBlocksHeightSchema, GetBlocksHeightData, GetBlocksHeightParameters, GetBlocksHeightError> | void
    ): Promise<GetBlocksHeightData>;
    /** @summary Get a block by height. */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters> | (DeepReadonly<GetBlocksHeightParameters> | void)
    ): OperationInfiniteData<GetBlocksHeightData, GetBlocksHeightParameters> | undefined;
    /** @summary Get a block by height. */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBlocksHeightSchema, GetBlocksHeightData, TInfinite, GetBlocksHeightParameters, GetBlocksHeightError>
        | QueryFiltersByQueryKey<GetBlocksHeightSchema, GetBlocksHeightData, TInfinite, GetBlocksHeightParameters, GetBlocksHeightError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters>,
            data: NoInfer<OperationInfiniteData<GetBlocksHeightData, GetBlocksHeightParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters>, data: GetBlocksHeightData | undefined]>;
    /** @summary Get a block by height. */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters> | (DeepReadonly<GetBlocksHeightParameters> | void)
    ): GetBlocksHeightData | undefined;
    /** @summary Get a block by height. */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters> | (DeepReadonly<GetBlocksHeightParameters> | void)
    ): QueryState<GetBlocksHeightData, GetBlocksHeightError> | undefined;
    /** @summary Get a block by height. */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetBlocksHeightParameters> | ServiceOperationInfiniteQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters> | void
    ): QueryState<OperationInfiniteData<GetBlocksHeightData, GetBlocksHeightParameters>, GetBlocksHeightError> | undefined;
    /** @summary Get a block by height. */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetBlocksHeightSchema, GetBlocksHeightData, TInfinite, GetBlocksHeightParameters, GetBlocksHeightError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get a block by height. */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBlocksHeightSchema, GetBlocksHeightData, TInfinite, GetBlocksHeightParameters, GetBlocksHeightError>
        | QueryFiltersByQueryKey<GetBlocksHeightSchema, GetBlocksHeightData, TInfinite, GetBlocksHeightParameters, GetBlocksHeightError>
    ): number;
    /** @summary Get a block by height. */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetBlocksHeightParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetBlocksHeightSchema,
        options: {
          parameters: GetBlocksHeightParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetBlocksHeightData, GetBlocksHeightError>>
    ): Promise<RequestFnResponse<GetBlocksHeightData, GetBlocksHeightError>>;
    /** @summary Get a block by height. */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBlocksHeightSchema, GetBlocksHeightData, TInfinite, GetBlocksHeightParameters, GetBlocksHeightError>
        | QueryFiltersByQueryKey<GetBlocksHeightSchema, GetBlocksHeightData, TInfinite, GetBlocksHeightParameters, GetBlocksHeightError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get a block by height. */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBlocksHeightSchema, GetBlocksHeightData, TInfinite, GetBlocksHeightParameters, GetBlocksHeightError>
        | QueryFiltersByQueryKey<GetBlocksHeightSchema, GetBlocksHeightData, TInfinite, GetBlocksHeightParameters, GetBlocksHeightError>
    ): void;
    /** @summary Get a block by height. */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBlocksHeightSchema, GetBlocksHeightData, TInfinite, GetBlocksHeightParameters, GetBlocksHeightError>
        | QueryFiltersByQueryKey<GetBlocksHeightSchema, GetBlocksHeightData, TInfinite, GetBlocksHeightParameters, GetBlocksHeightError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get a block by height. */
    setInfiniteQueryData(
      parameters: (DeepReadonly<GetBlocksHeightParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetBlocksHeightData, GetBlocksHeightParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetBlocksHeightData, GetBlocksHeightParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetBlocksHeightData, GetBlocksHeightParameters> | undefined;
    /** @summary Get a block by height. */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetBlocksHeightSchema, GetBlocksHeightData, TInfinite, GetBlocksHeightParameters, GetBlocksHeightError>
        | QueryFiltersByQueryKey<GetBlocksHeightSchema, GetBlocksHeightData, TInfinite, GetBlocksHeightParameters, GetBlocksHeightError>,
      updater: Updater<NoInfer<GetBlocksHeightData> | undefined, NoInfer<GetBlocksHeightData> | undefined>,
      options?: SetDataOptions
    ): Array<GetBlocksHeightData | undefined>;
    /** @summary Get a block by height. */
    setQueryData(
      parameters: (DeepReadonly<GetBlocksHeightParameters> | undefined) | ServiceOperationQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters>,
      updater: Updater<NoInfer<GetBlocksHeightData> | undefined, NoInfer<DeepReadonly<GetBlocksHeightData>> | undefined>,
      options?: SetDataOptions
    ): GetBlocksHeightData | undefined;
    /** @summary Get a block by height. */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetBlocksHeightParameters> | void
    ): ServiceOperationInfiniteQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a block by height.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getBlocksHeight.useInfiniteQuery({
     *     path: {
     *         height: height
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetBlocksHeightParameters,
      TQueryFnData = GetBlocksHeightData,
      TData = OperationInfiniteData<TQueryFnData, GetBlocksHeightParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters> | (DeepReadonly<GetBlocksHeightParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetBlocksHeightError,
          TData,
          ServiceOperationInfiniteQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetBlocksHeightError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a block by height.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getBlocksHeight.useInfiniteQuery({
     *     path: {
     *         height: height
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetBlocksHeightParameters,
      TQueryFnData = GetBlocksHeightData,
      TData = OperationInfiniteData<TQueryFnData, GetBlocksHeightParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters> | (DeepReadonly<GetBlocksHeightParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetBlocksHeightError,
          TData,
          ServiceOperationInfiniteQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetBlocksHeightData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetBlocksHeightError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get a block by height.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getBlocksHeightTotal = qraft.v1Service.getBlocksHeight.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getBlocksHeightByParametersTotal = qraft.v1Service.getBlocksHeight.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             height: height
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetBlocksHeightSchema, GetBlocksHeightData, TInfinite, GetBlocksHeightParameters, GetBlocksHeightError>
        | QueryFiltersByQueryKey<GetBlocksHeightSchema, GetBlocksHeightData, TInfinite, GetBlocksHeightParameters, GetBlocksHeightError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get a block by height.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getBlocksHeightResults = qraft.v1Service.getBlocksHeight.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 height: height1
     *             }
     *         },
     *         {
     *             path: {
     *                 height: height2
     *             }
     *         }
     *     ]
     * });
     * getBlocksHeightResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getBlocksHeightCombinedResults = qraft.v1Service.getBlocksHeight.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 height: height1
     *             }
     *         },
     *         {
     *             path: {
     *                 height: height2
     *             }
     *         }
     *     ]
     * });
     * getBlocksHeightCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetBlocksHeightSchema, GetBlocksHeightParameters, GetBlocksHeightData, GetBlocksHeightError>>,
      TCombinedResult = Array<UseQueryResult<GetBlocksHeightData, GetBlocksHeightError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetBlocksHeightData, GetBlocksHeightError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get a block by height. */
    getQueryKey(parameters: DeepReadonly<GetBlocksHeightParameters> | void): ServiceOperationQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a block by height.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBlocksHeight.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBlocksHeight.useQuery({
     *     path: {
     *         height: height
     *     }
     * })
     * ```
     */
    useQuery<TData = GetBlocksHeightData>(
      parameters: ServiceOperationQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters> | (DeepReadonly<GetBlocksHeightParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetBlocksHeightData,
          GetBlocksHeightError,
          TData,
          ServiceOperationQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetBlocksHeightError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a block by height.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBlocksHeight.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getBlocksHeight.useQuery({
     *     path: {
     *         height: height
     *     }
     * })
     * ```
     */
    useQuery<TData = GetBlocksHeightData>(
      parameters: ServiceOperationQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters> | (DeepReadonly<GetBlocksHeightParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetBlocksHeightData, GetBlocksHeightError, TData, ServiceOperationQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetBlocksHeightError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get a block by height.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getBlocksHeight.useSuspenseInfiniteQuery({
     *     path: {
     *         height: height
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetBlocksHeightParameters, TData = GetBlocksHeightData>(
      parameters: ServiceOperationInfiniteQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters> | (DeepReadonly<GetBlocksHeightParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetBlocksHeightData,
          GetBlocksHeightError,
          OperationInfiniteData<TData, GetBlocksHeightParameters>,
          GetBlocksHeightData,
          ServiceOperationInfiniteQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetBlocksHeightData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetBlocksHeightParameters>, GetBlocksHeightError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get a block by height.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getBlocksHeightData = qraft.v1Service.getBlocksHeight.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 height: height1
     *             }
     *         },
     *         {
     *             path: {
     *                 height: height2
     *             }
     *         }
     *     ]
     * });
     * getBlocksHeightResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getBlocksHeightCombinedData = qraft.v1Service.getBlocksHeight.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 height: height1
     *             }
     *         },
     *         {
     *             path: {
     *                 height: height2
     *             }
     *         }
     *     ]
     * });
     * getBlocksHeightCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetBlocksHeightSchema, GetBlocksHeightParameters, GetBlocksHeightData, GetBlocksHeightError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetBlocksHeightData, GetBlocksHeightError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetBlocksHeightData, GetBlocksHeightError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get a block by height.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getBlocksHeight.useSuspenseQuery()
     * ```
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getBlocksHeight.useSuspenseQuery({
     *     path: {
     *         height: height
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetBlocksHeightData>(
      parameters: ServiceOperationQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters> | (DeepReadonly<GetBlocksHeightParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<GetBlocksHeightData, GetBlocksHeightError, TData, ServiceOperationQueryKey<GetBlocksHeightSchema, GetBlocksHeightParameters>>,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetBlocksHeightError | Error>;
    schema: GetBlocksHeightSchema;
    types: {
      parameters: GetBlocksHeightParameters;
      data: GetBlocksHeightData;
      error: GetBlocksHeightError;
    };
  };
  /** @summary Get the estimated date of a future block. */
  getPredictedBlockDateHeight: {
    /** @summary Get the estimated date of a future block. */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetPredictedBlockDateHeightSchema,
            GetPredictedBlockDateHeightData,
            TInfinite,
            GetPredictedBlockDateHeightParameters,
            GetPredictedBlockDateHeightError
          >
        | QueryFiltersByQueryKey<
            GetPredictedBlockDateHeightSchema,
            GetPredictedBlockDateHeightData,
            TInfinite,
            GetPredictedBlockDateHeightParameters,
            GetPredictedBlockDateHeightError
          >,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get the estimated date of a future block. */
    getQueryKey(
      parameters: DeepReadonly<GetPredictedBlockDateHeightParameters> | void
    ): ServiceOperationQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get the estimated date of a future block.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getPredictedBlockDateHeight.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getPredictedBlockDateHeight.useQuery({
     *     path: {
     *         height: height
     *     },
     *     query: {
     *         blockWindow: blockWindow
     *     }
     * })
     * ```
     */
    useQuery<TData = GetPredictedBlockDateHeightData>(
      parameters:
        | ServiceOperationQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>
        | (DeepReadonly<GetPredictedBlockDateHeightParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetPredictedBlockDateHeightData,
          GetPredictedBlockDateHeightError,
          TData,
          ServiceOperationQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetPredictedBlockDateHeightError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get the estimated date of a future block.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getPredictedBlockDateHeight.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getPredictedBlockDateHeight.useQuery({
     *     path: {
     *         height: height
     *     },
     *     query: {
     *         blockWindow: blockWindow
     *     }
     * })
     * ```
     */
    useQuery<TData = GetPredictedBlockDateHeightData>(
      parameters:
        | ServiceOperationQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>
        | (DeepReadonly<GetPredictedBlockDateHeightParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetPredictedBlockDateHeightData,
          GetPredictedBlockDateHeightError,
          TData,
          ServiceOperationQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetPredictedBlockDateHeightError | Error>;
    /** @summary Get the estimated date of a future block. */
    fetchInfiniteQuery<TPageParam extends GetPredictedBlockDateHeightParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetPredictedBlockDateHeightSchema,
        GetPredictedBlockDateHeightData,
        GetPredictedBlockDateHeightParameters,
        DeepReadonly<TPageParam>,
        GetPredictedBlockDateHeightError
      > | void
    ): Promise<OperationInfiniteData<GetPredictedBlockDateHeightData, GetPredictedBlockDateHeightParameters>>;
    /** @summary Get the estimated date of a future block. */
    prefetchInfiniteQuery<TPageParam extends GetPredictedBlockDateHeightParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetPredictedBlockDateHeightSchema,
        GetPredictedBlockDateHeightData,
        GetPredictedBlockDateHeightParameters,
        DeepReadonly<TPageParam>,
        GetPredictedBlockDateHeightError
      > | void
    ): Promise<void>;
    /** @summary Get the estimated date of a future block. */
    ensureInfiniteQueryData<TPageParam extends GetPredictedBlockDateHeightParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetPredictedBlockDateHeightSchema,
        GetPredictedBlockDateHeightData,
        GetPredictedBlockDateHeightParameters,
        DeepReadonly<TPageParam>,
        GetPredictedBlockDateHeightError
      > | void
    ): Promise<OperationInfiniteData<GetPredictedBlockDateHeightData, GetPredictedBlockDateHeightParameters>>;
    /** @summary Get the estimated date of a future block. */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetPredictedBlockDateHeightSchema,
        GetPredictedBlockDateHeightData,
        GetPredictedBlockDateHeightParameters,
        GetPredictedBlockDateHeightError
      > | void
    ): Promise<GetPredictedBlockDateHeightData>;
    /** @summary Get the estimated date of a future block. */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetPredictedBlockDateHeightSchema,
        GetPredictedBlockDateHeightData,
        GetPredictedBlockDateHeightParameters,
        GetPredictedBlockDateHeightError
      > | void
    ): Promise<void>;
    /** @summary Get the estimated date of a future block. */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetPredictedBlockDateHeightSchema,
        GetPredictedBlockDateHeightData,
        GetPredictedBlockDateHeightParameters,
        GetPredictedBlockDateHeightError
      > | void
    ): Promise<GetPredictedBlockDateHeightData>;
    /** @summary Get the estimated date of a future block. */
    getInfiniteQueryData(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>
        | (DeepReadonly<GetPredictedBlockDateHeightParameters> | void)
    ): OperationInfiniteData<GetPredictedBlockDateHeightData, GetPredictedBlockDateHeightParameters> | undefined;
    /** @summary Get the estimated date of a future block. */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetPredictedBlockDateHeightSchema,
            GetPredictedBlockDateHeightData,
            TInfinite,
            GetPredictedBlockDateHeightParameters,
            GetPredictedBlockDateHeightError
          >
        | QueryFiltersByQueryKey<
            GetPredictedBlockDateHeightSchema,
            GetPredictedBlockDateHeightData,
            TInfinite,
            GetPredictedBlockDateHeightParameters,
            GetPredictedBlockDateHeightError
          >
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>,
            data: NoInfer<OperationInfiniteData<GetPredictedBlockDateHeightData, GetPredictedBlockDateHeightParameters>> | undefined
          ]
        >
      : Array<
          [
            queryKey: ServiceOperationQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>,
            data: GetPredictedBlockDateHeightData | undefined
          ]
        >;
    /** @summary Get the estimated date of a future block. */
    getQueryData(
      parameters:
        | ServiceOperationQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>
        | (DeepReadonly<GetPredictedBlockDateHeightParameters> | void)
    ): GetPredictedBlockDateHeightData | undefined;
    /** @summary Get the estimated date of a future block. */
    getQueryState(
      parameters:
        | ServiceOperationQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>
        | (DeepReadonly<GetPredictedBlockDateHeightParameters> | void)
    ): QueryState<GetPredictedBlockDateHeightData, GetPredictedBlockDateHeightError> | undefined;
    /** @summary Get the estimated date of a future block. */
    getInfiniteQueryState(
      parameters:
        | DeepReadonly<GetPredictedBlockDateHeightParameters>
        | ServiceOperationInfiniteQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>
        | void
    ): QueryState<OperationInfiniteData<GetPredictedBlockDateHeightData, GetPredictedBlockDateHeightParameters>, GetPredictedBlockDateHeightError> | undefined;
    /** @summary Get the estimated date of a future block. */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<
        GetPredictedBlockDateHeightSchema,
        GetPredictedBlockDateHeightData,
        TInfinite,
        GetPredictedBlockDateHeightParameters,
        GetPredictedBlockDateHeightError
      >,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get the estimated date of a future block. */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetPredictedBlockDateHeightSchema,
            GetPredictedBlockDateHeightData,
            TInfinite,
            GetPredictedBlockDateHeightParameters,
            GetPredictedBlockDateHeightError
          >
        | QueryFiltersByQueryKey<
            GetPredictedBlockDateHeightSchema,
            GetPredictedBlockDateHeightData,
            TInfinite,
            GetPredictedBlockDateHeightParameters,
            GetPredictedBlockDateHeightError
          >
    ): number;
    /** @summary Get the estimated date of a future block. */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetPredictedBlockDateHeightParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetPredictedBlockDateHeightSchema,
        options: {
          parameters: GetPredictedBlockDateHeightParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetPredictedBlockDateHeightData, GetPredictedBlockDateHeightError>>
    ): Promise<RequestFnResponse<GetPredictedBlockDateHeightData, GetPredictedBlockDateHeightError>>;
    /** @summary Get the estimated date of a future block. */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetPredictedBlockDateHeightSchema,
            GetPredictedBlockDateHeightData,
            TInfinite,
            GetPredictedBlockDateHeightParameters,
            GetPredictedBlockDateHeightError
          >
        | QueryFiltersByQueryKey<
            GetPredictedBlockDateHeightSchema,
            GetPredictedBlockDateHeightData,
            TInfinite,
            GetPredictedBlockDateHeightParameters,
            GetPredictedBlockDateHeightError
          >,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get the estimated date of a future block. */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetPredictedBlockDateHeightSchema,
            GetPredictedBlockDateHeightData,
            TInfinite,
            GetPredictedBlockDateHeightParameters,
            GetPredictedBlockDateHeightError
          >
        | QueryFiltersByQueryKey<
            GetPredictedBlockDateHeightSchema,
            GetPredictedBlockDateHeightData,
            TInfinite,
            GetPredictedBlockDateHeightParameters,
            GetPredictedBlockDateHeightError
          >
    ): void;
    /** @summary Get the estimated date of a future block. */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetPredictedBlockDateHeightSchema,
            GetPredictedBlockDateHeightData,
            TInfinite,
            GetPredictedBlockDateHeightParameters,
            GetPredictedBlockDateHeightError
          >
        | QueryFiltersByQueryKey<
            GetPredictedBlockDateHeightSchema,
            GetPredictedBlockDateHeightData,
            TInfinite,
            GetPredictedBlockDateHeightParameters,
            GetPredictedBlockDateHeightError
          >,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get the estimated date of a future block. */
    setInfiniteQueryData(
      parameters:
        | (DeepReadonly<GetPredictedBlockDateHeightParameters> | undefined)
        | ServiceOperationInfiniteQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetPredictedBlockDateHeightData, GetPredictedBlockDateHeightParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetPredictedBlockDateHeightData, GetPredictedBlockDateHeightParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetPredictedBlockDateHeightData, GetPredictedBlockDateHeightParameters> | undefined;
    /** @summary Get the estimated date of a future block. */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<
            GetPredictedBlockDateHeightSchema,
            GetPredictedBlockDateHeightData,
            TInfinite,
            GetPredictedBlockDateHeightParameters,
            GetPredictedBlockDateHeightError
          >
        | QueryFiltersByQueryKey<
            GetPredictedBlockDateHeightSchema,
            GetPredictedBlockDateHeightData,
            TInfinite,
            GetPredictedBlockDateHeightParameters,
            GetPredictedBlockDateHeightError
          >,
      updater: Updater<NoInfer<GetPredictedBlockDateHeightData> | undefined, NoInfer<GetPredictedBlockDateHeightData> | undefined>,
      options?: SetDataOptions
    ): Array<GetPredictedBlockDateHeightData | undefined>;
    /** @summary Get the estimated date of a future block. */
    setQueryData(
      parameters:
        | (DeepReadonly<GetPredictedBlockDateHeightParameters> | undefined)
        | ServiceOperationQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>,
      updater: Updater<NoInfer<GetPredictedBlockDateHeightData> | undefined, NoInfer<DeepReadonly<GetPredictedBlockDateHeightData>> | undefined>,
      options?: SetDataOptions
    ): GetPredictedBlockDateHeightData | undefined;
    /** @summary Get the estimated date of a future block. */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetPredictedBlockDateHeightParameters> | void
    ): ServiceOperationInfiniteQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get the estimated date of a future block.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getPredictedBlockDateHeight.useInfiniteQuery({
     *     path: {
     *         height: height
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             blockWindow: initialBlockWindow
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetPredictedBlockDateHeightParameters,
      TQueryFnData = GetPredictedBlockDateHeightData,
      TData = OperationInfiniteData<TQueryFnData, GetPredictedBlockDateHeightParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>
        | (DeepReadonly<GetPredictedBlockDateHeightParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetPredictedBlockDateHeightError,
          TData,
          ServiceOperationInfiniteQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetPredictedBlockDateHeightError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get the estimated date of a future block.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getPredictedBlockDateHeight.useInfiniteQuery({
     *     path: {
     *         height: height
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             blockWindow: initialBlockWindow
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetPredictedBlockDateHeightParameters,
      TQueryFnData = GetPredictedBlockDateHeightData,
      TData = OperationInfiniteData<TQueryFnData, GetPredictedBlockDateHeightParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>
        | (DeepReadonly<GetPredictedBlockDateHeightParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetPredictedBlockDateHeightError,
          TData,
          ServiceOperationInfiniteQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetPredictedBlockDateHeightData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetPredictedBlockDateHeightError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get the estimated date of a future block.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getPredictedBlockDateHeightTotal = qraft.v1Service.getPredictedBlockDateHeight.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getPredictedBlockDateHeightByParametersTotal = qraft.v1Service.getPredictedBlockDateHeight.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             height: height
     *         },
     *         query: {
     *             blockWindow: blockWindow
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetPredictedBlockDateHeightSchema,
            GetPredictedBlockDateHeightData,
            TInfinite,
            GetPredictedBlockDateHeightParameters,
            GetPredictedBlockDateHeightError
          >
        | QueryFiltersByQueryKey<
            GetPredictedBlockDateHeightSchema,
            GetPredictedBlockDateHeightData,
            TInfinite,
            GetPredictedBlockDateHeightParameters,
            GetPredictedBlockDateHeightError
          >
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get the estimated date of a future block.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getPredictedBlockDateHeightResults = qraft.v1Service.getPredictedBlockDateHeight.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 height: height1
     *             },
     *             query: {
     *                 blockWindow: blockWindow1
     *             }
     *         },
     *         {
     *             path: {
     *                 height: height2
     *             },
     *             query: {
     *                 blockWindow: blockWindow2
     *             }
     *         }
     *     ]
     * });
     * getPredictedBlockDateHeightResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getPredictedBlockDateHeightCombinedResults = qraft.v1Service.getPredictedBlockDateHeight.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 height: height1
     *             },
     *             query: {
     *                 blockWindow: blockWindow1
     *             }
     *         },
     *         {
     *             path: {
     *                 height: height2
     *             },
     *             query: {
     *                 blockWindow: blockWindow2
     *             }
     *         }
     *     ]
     * });
     * getPredictedBlockDateHeightCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<
          GetPredictedBlockDateHeightSchema,
          GetPredictedBlockDateHeightParameters,
          GetPredictedBlockDateHeightData,
          GetPredictedBlockDateHeightError
        >
      >,
      TCombinedResult = Array<UseQueryResult<GetPredictedBlockDateHeightData, GetPredictedBlockDateHeightError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetPredictedBlockDateHeightData, GetPredictedBlockDateHeightError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get the estimated date of a future block. */
    getQueryKey(
      parameters: DeepReadonly<GetPredictedBlockDateHeightParameters> | void
    ): ServiceOperationQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get the estimated date of a future block.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getPredictedBlockDateHeight.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getPredictedBlockDateHeight.useQuery({
     *     path: {
     *         height: height
     *     },
     *     query: {
     *         blockWindow: blockWindow
     *     }
     * })
     * ```
     */
    useQuery<TData = GetPredictedBlockDateHeightData>(
      parameters:
        | ServiceOperationQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>
        | (DeepReadonly<GetPredictedBlockDateHeightParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetPredictedBlockDateHeightData,
          GetPredictedBlockDateHeightError,
          TData,
          ServiceOperationQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetPredictedBlockDateHeightError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get the estimated date of a future block.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getPredictedBlockDateHeight.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getPredictedBlockDateHeight.useQuery({
     *     path: {
     *         height: height
     *     },
     *     query: {
     *         blockWindow: blockWindow
     *     }
     * })
     * ```
     */
    useQuery<TData = GetPredictedBlockDateHeightData>(
      parameters:
        | ServiceOperationQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>
        | (DeepReadonly<GetPredictedBlockDateHeightParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetPredictedBlockDateHeightData,
          GetPredictedBlockDateHeightError,
          TData,
          ServiceOperationQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetPredictedBlockDateHeightError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get the estimated date of a future block.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getPredictedBlockDateHeight.useSuspenseInfiniteQuery({
     *     path: {
     *         height: height
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             blockWindow: initialBlockWindow
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetPredictedBlockDateHeightParameters, TData = GetPredictedBlockDateHeightData>(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>
        | (DeepReadonly<GetPredictedBlockDateHeightParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetPredictedBlockDateHeightData,
          GetPredictedBlockDateHeightError,
          OperationInfiniteData<TData, GetPredictedBlockDateHeightParameters>,
          GetPredictedBlockDateHeightData,
          ServiceOperationInfiniteQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetPredictedBlockDateHeightData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetPredictedBlockDateHeightParameters>, GetPredictedBlockDateHeightError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get the estimated date of a future block.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getPredictedBlockDateHeightData = qraft.v1Service.getPredictedBlockDateHeight.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 height: height1
     *             },
     *             query: {
     *                 blockWindow: blockWindow1
     *             }
     *         },
     *         {
     *             path: {
     *                 height: height2
     *             },
     *             query: {
     *                 blockWindow: blockWindow2
     *             }
     *         }
     *     ]
     * });
     * getPredictedBlockDateHeightResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getPredictedBlockDateHeightCombinedData = qraft.v1Service.getPredictedBlockDateHeight.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 height: height1
     *             },
     *             query: {
     *                 blockWindow: blockWindow1
     *             }
     *         },
     *         {
     *             path: {
     *                 height: height2
     *             },
     *             query: {
     *                 blockWindow: blockWindow2
     *             }
     *         }
     *     ]
     * });
     * getPredictedBlockDateHeightCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<
          GetPredictedBlockDateHeightSchema,
          GetPredictedBlockDateHeightParameters,
          GetPredictedBlockDateHeightData,
          GetPredictedBlockDateHeightError
        >
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetPredictedBlockDateHeightData, GetPredictedBlockDateHeightError>>
    >(options: {
      queries: T;
      combine?: (
        results: Array<WithOptional<UseSuspenseQueryResult<GetPredictedBlockDateHeightData, GetPredictedBlockDateHeightError>, "data">>
      ) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get the estimated date of a future block.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getPredictedBlockDateHeight.useSuspenseQuery()
     * ```
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getPredictedBlockDateHeight.useSuspenseQuery({
     *     path: {
     *         height: height
     *     },
     *     query: {
     *         blockWindow: blockWindow
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetPredictedBlockDateHeightData>(
      parameters:
        | ServiceOperationQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>
        | (DeepReadonly<GetPredictedBlockDateHeightParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<
          GetPredictedBlockDateHeightData,
          GetPredictedBlockDateHeightError,
          TData,
          ServiceOperationQueryKey<GetPredictedBlockDateHeightSchema, GetPredictedBlockDateHeightParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetPredictedBlockDateHeightError | Error>;
    schema: GetPredictedBlockDateHeightSchema;
    types: {
      parameters: GetPredictedBlockDateHeightParameters;
      data: GetPredictedBlockDateHeightData;
      error: GetPredictedBlockDateHeightError;
    };
  };
  /** @summary Get the estimated height of a future date and time. */
  getPredictedDateHeightTimestamp: {
    /** @summary Get the estimated height of a future date and time. */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetPredictedDateHeightTimestampSchema,
            GetPredictedDateHeightTimestampData,
            TInfinite,
            GetPredictedDateHeightTimestampParameters,
            GetPredictedDateHeightTimestampError
          >
        | QueryFiltersByQueryKey<
            GetPredictedDateHeightTimestampSchema,
            GetPredictedDateHeightTimestampData,
            TInfinite,
            GetPredictedDateHeightTimestampParameters,
            GetPredictedDateHeightTimestampError
          >,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get the estimated height of a future date and time. */
    getQueryKey(
      parameters: DeepReadonly<GetPredictedDateHeightTimestampParameters> | void
    ): ServiceOperationQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get the estimated height of a future date and time.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getPredictedDateHeightTimestamp.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getPredictedDateHeightTimestamp.useQuery({
     *     path: {
     *         timestamp: timestamp
     *     },
     *     query: {
     *         blockWindow: blockWindow
     *     }
     * })
     * ```
     */
    useQuery<TData = GetPredictedDateHeightTimestampData>(
      parameters:
        | ServiceOperationQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>
        | (DeepReadonly<GetPredictedDateHeightTimestampParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetPredictedDateHeightTimestampData,
          GetPredictedDateHeightTimestampError,
          TData,
          ServiceOperationQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetPredictedDateHeightTimestampError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get the estimated height of a future date and time.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getPredictedDateHeightTimestamp.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getPredictedDateHeightTimestamp.useQuery({
     *     path: {
     *         timestamp: timestamp
     *     },
     *     query: {
     *         blockWindow: blockWindow
     *     }
     * })
     * ```
     */
    useQuery<TData = GetPredictedDateHeightTimestampData>(
      parameters:
        | ServiceOperationQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>
        | (DeepReadonly<GetPredictedDateHeightTimestampParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetPredictedDateHeightTimestampData,
          GetPredictedDateHeightTimestampError,
          TData,
          ServiceOperationQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetPredictedDateHeightTimestampError | Error>;
    /** @summary Get the estimated height of a future date and time. */
    fetchInfiniteQuery<TPageParam extends GetPredictedDateHeightTimestampParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetPredictedDateHeightTimestampSchema,
        GetPredictedDateHeightTimestampData,
        GetPredictedDateHeightTimestampParameters,
        DeepReadonly<TPageParam>,
        GetPredictedDateHeightTimestampError
      > | void
    ): Promise<OperationInfiniteData<GetPredictedDateHeightTimestampData, GetPredictedDateHeightTimestampParameters>>;
    /** @summary Get the estimated height of a future date and time. */
    prefetchInfiniteQuery<TPageParam extends GetPredictedDateHeightTimestampParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetPredictedDateHeightTimestampSchema,
        GetPredictedDateHeightTimestampData,
        GetPredictedDateHeightTimestampParameters,
        DeepReadonly<TPageParam>,
        GetPredictedDateHeightTimestampError
      > | void
    ): Promise<void>;
    /** @summary Get the estimated height of a future date and time. */
    ensureInfiniteQueryData<TPageParam extends GetPredictedDateHeightTimestampParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetPredictedDateHeightTimestampSchema,
        GetPredictedDateHeightTimestampData,
        GetPredictedDateHeightTimestampParameters,
        DeepReadonly<TPageParam>,
        GetPredictedDateHeightTimestampError
      > | void
    ): Promise<OperationInfiniteData<GetPredictedDateHeightTimestampData, GetPredictedDateHeightTimestampParameters>>;
    /** @summary Get the estimated height of a future date and time. */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetPredictedDateHeightTimestampSchema,
        GetPredictedDateHeightTimestampData,
        GetPredictedDateHeightTimestampParameters,
        GetPredictedDateHeightTimestampError
      > | void
    ): Promise<GetPredictedDateHeightTimestampData>;
    /** @summary Get the estimated height of a future date and time. */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetPredictedDateHeightTimestampSchema,
        GetPredictedDateHeightTimestampData,
        GetPredictedDateHeightTimestampParameters,
        GetPredictedDateHeightTimestampError
      > | void
    ): Promise<void>;
    /** @summary Get the estimated height of a future date and time. */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetPredictedDateHeightTimestampSchema,
        GetPredictedDateHeightTimestampData,
        GetPredictedDateHeightTimestampParameters,
        GetPredictedDateHeightTimestampError
      > | void
    ): Promise<GetPredictedDateHeightTimestampData>;
    /** @summary Get the estimated height of a future date and time. */
    getInfiniteQueryData(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>
        | (DeepReadonly<GetPredictedDateHeightTimestampParameters> | void)
    ): OperationInfiniteData<GetPredictedDateHeightTimestampData, GetPredictedDateHeightTimestampParameters> | undefined;
    /** @summary Get the estimated height of a future date and time. */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetPredictedDateHeightTimestampSchema,
            GetPredictedDateHeightTimestampData,
            TInfinite,
            GetPredictedDateHeightTimestampParameters,
            GetPredictedDateHeightTimestampError
          >
        | QueryFiltersByQueryKey<
            GetPredictedDateHeightTimestampSchema,
            GetPredictedDateHeightTimestampData,
            TInfinite,
            GetPredictedDateHeightTimestampParameters,
            GetPredictedDateHeightTimestampError
          >
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>,
            data: NoInfer<OperationInfiniteData<GetPredictedDateHeightTimestampData, GetPredictedDateHeightTimestampParameters>> | undefined
          ]
        >
      : Array<
          [
            queryKey: ServiceOperationQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>,
            data: GetPredictedDateHeightTimestampData | undefined
          ]
        >;
    /** @summary Get the estimated height of a future date and time. */
    getQueryData(
      parameters:
        | ServiceOperationQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>
        | (DeepReadonly<GetPredictedDateHeightTimestampParameters> | void)
    ): GetPredictedDateHeightTimestampData | undefined;
    /** @summary Get the estimated height of a future date and time. */
    getQueryState(
      parameters:
        | ServiceOperationQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>
        | (DeepReadonly<GetPredictedDateHeightTimestampParameters> | void)
    ): QueryState<GetPredictedDateHeightTimestampData, GetPredictedDateHeightTimestampError> | undefined;
    /** @summary Get the estimated height of a future date and time. */
    getInfiniteQueryState(
      parameters:
        | DeepReadonly<GetPredictedDateHeightTimestampParameters>
        | ServiceOperationInfiniteQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>
        | void
    ):
      | QueryState<OperationInfiniteData<GetPredictedDateHeightTimestampData, GetPredictedDateHeightTimestampParameters>, GetPredictedDateHeightTimestampError>
      | undefined;
    /** @summary Get the estimated height of a future date and time. */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<
        GetPredictedDateHeightTimestampSchema,
        GetPredictedDateHeightTimestampData,
        TInfinite,
        GetPredictedDateHeightTimestampParameters,
        GetPredictedDateHeightTimestampError
      >,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get the estimated height of a future date and time. */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetPredictedDateHeightTimestampSchema,
            GetPredictedDateHeightTimestampData,
            TInfinite,
            GetPredictedDateHeightTimestampParameters,
            GetPredictedDateHeightTimestampError
          >
        | QueryFiltersByQueryKey<
            GetPredictedDateHeightTimestampSchema,
            GetPredictedDateHeightTimestampData,
            TInfinite,
            GetPredictedDateHeightTimestampParameters,
            GetPredictedDateHeightTimestampError
          >
    ): number;
    /** @summary Get the estimated height of a future date and time. */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetPredictedDateHeightTimestampParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetPredictedDateHeightTimestampSchema,
        options: {
          parameters: GetPredictedDateHeightTimestampParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetPredictedDateHeightTimestampData, GetPredictedDateHeightTimestampError>>
    ): Promise<RequestFnResponse<GetPredictedDateHeightTimestampData, GetPredictedDateHeightTimestampError>>;
    /** @summary Get the estimated height of a future date and time. */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetPredictedDateHeightTimestampSchema,
            GetPredictedDateHeightTimestampData,
            TInfinite,
            GetPredictedDateHeightTimestampParameters,
            GetPredictedDateHeightTimestampError
          >
        | QueryFiltersByQueryKey<
            GetPredictedDateHeightTimestampSchema,
            GetPredictedDateHeightTimestampData,
            TInfinite,
            GetPredictedDateHeightTimestampParameters,
            GetPredictedDateHeightTimestampError
          >,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get the estimated height of a future date and time. */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetPredictedDateHeightTimestampSchema,
            GetPredictedDateHeightTimestampData,
            TInfinite,
            GetPredictedDateHeightTimestampParameters,
            GetPredictedDateHeightTimestampError
          >
        | QueryFiltersByQueryKey<
            GetPredictedDateHeightTimestampSchema,
            GetPredictedDateHeightTimestampData,
            TInfinite,
            GetPredictedDateHeightTimestampParameters,
            GetPredictedDateHeightTimestampError
          >
    ): void;
    /** @summary Get the estimated height of a future date and time. */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetPredictedDateHeightTimestampSchema,
            GetPredictedDateHeightTimestampData,
            TInfinite,
            GetPredictedDateHeightTimestampParameters,
            GetPredictedDateHeightTimestampError
          >
        | QueryFiltersByQueryKey<
            GetPredictedDateHeightTimestampSchema,
            GetPredictedDateHeightTimestampData,
            TInfinite,
            GetPredictedDateHeightTimestampParameters,
            GetPredictedDateHeightTimestampError
          >,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get the estimated height of a future date and time. */
    setInfiniteQueryData(
      parameters:
        | (DeepReadonly<GetPredictedDateHeightTimestampParameters> | undefined)
        | ServiceOperationInfiniteQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetPredictedDateHeightTimestampData, GetPredictedDateHeightTimestampParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetPredictedDateHeightTimestampData, GetPredictedDateHeightTimestampParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetPredictedDateHeightTimestampData, GetPredictedDateHeightTimestampParameters> | undefined;
    /** @summary Get the estimated height of a future date and time. */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<
            GetPredictedDateHeightTimestampSchema,
            GetPredictedDateHeightTimestampData,
            TInfinite,
            GetPredictedDateHeightTimestampParameters,
            GetPredictedDateHeightTimestampError
          >
        | QueryFiltersByQueryKey<
            GetPredictedDateHeightTimestampSchema,
            GetPredictedDateHeightTimestampData,
            TInfinite,
            GetPredictedDateHeightTimestampParameters,
            GetPredictedDateHeightTimestampError
          >,
      updater: Updater<NoInfer<GetPredictedDateHeightTimestampData> | undefined, NoInfer<GetPredictedDateHeightTimestampData> | undefined>,
      options?: SetDataOptions
    ): Array<GetPredictedDateHeightTimestampData | undefined>;
    /** @summary Get the estimated height of a future date and time. */
    setQueryData(
      parameters:
        | (DeepReadonly<GetPredictedDateHeightTimestampParameters> | undefined)
        | ServiceOperationQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>,
      updater: Updater<NoInfer<GetPredictedDateHeightTimestampData> | undefined, NoInfer<DeepReadonly<GetPredictedDateHeightTimestampData>> | undefined>,
      options?: SetDataOptions
    ): GetPredictedDateHeightTimestampData | undefined;
    /** @summary Get the estimated height of a future date and time. */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetPredictedDateHeightTimestampParameters> | void
    ): ServiceOperationInfiniteQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get the estimated height of a future date and time.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getPredictedDateHeightTimestamp.useInfiniteQuery({
     *     path: {
     *         timestamp: timestamp
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             blockWindow: initialBlockWindow
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetPredictedDateHeightTimestampParameters,
      TQueryFnData = GetPredictedDateHeightTimestampData,
      TData = OperationInfiniteData<TQueryFnData, GetPredictedDateHeightTimestampParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>
        | (DeepReadonly<GetPredictedDateHeightTimestampParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetPredictedDateHeightTimestampError,
          TData,
          ServiceOperationInfiniteQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetPredictedDateHeightTimestampError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get the estimated height of a future date and time.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getPredictedDateHeightTimestamp.useInfiniteQuery({
     *     path: {
     *         timestamp: timestamp
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             blockWindow: initialBlockWindow
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetPredictedDateHeightTimestampParameters,
      TQueryFnData = GetPredictedDateHeightTimestampData,
      TData = OperationInfiniteData<TQueryFnData, GetPredictedDateHeightTimestampParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>
        | (DeepReadonly<GetPredictedDateHeightTimestampParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetPredictedDateHeightTimestampError,
          TData,
          ServiceOperationInfiniteQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetPredictedDateHeightTimestampData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetPredictedDateHeightTimestampError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get the estimated height of a future date and time.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getPredictedDateHeightTimestampTotal = qraft.v1Service.getPredictedDateHeightTimestamp.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getPredictedDateHeightTimestampByParametersTotal = qraft.v1Service.getPredictedDateHeightTimestamp.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             timestamp: timestamp
     *         },
     *         query: {
     *             blockWindow: blockWindow
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetPredictedDateHeightTimestampSchema,
            GetPredictedDateHeightTimestampData,
            TInfinite,
            GetPredictedDateHeightTimestampParameters,
            GetPredictedDateHeightTimestampError
          >
        | QueryFiltersByQueryKey<
            GetPredictedDateHeightTimestampSchema,
            GetPredictedDateHeightTimestampData,
            TInfinite,
            GetPredictedDateHeightTimestampParameters,
            GetPredictedDateHeightTimestampError
          >
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get the estimated height of a future date and time.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getPredictedDateHeightTimestampResults = qraft.v1Service.getPredictedDateHeightTimestamp.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 timestamp: timestamp1
     *             },
     *             query: {
     *                 blockWindow: blockWindow1
     *             }
     *         },
     *         {
     *             path: {
     *                 timestamp: timestamp2
     *             },
     *             query: {
     *                 blockWindow: blockWindow2
     *             }
     *         }
     *     ]
     * });
     * getPredictedDateHeightTimestampResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getPredictedDateHeightTimestampCombinedResults = qraft.v1Service.getPredictedDateHeightTimestamp.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 timestamp: timestamp1
     *             },
     *             query: {
     *                 blockWindow: blockWindow1
     *             }
     *         },
     *         {
     *             path: {
     *                 timestamp: timestamp2
     *             },
     *             query: {
     *                 blockWindow: blockWindow2
     *             }
     *         }
     *     ]
     * });
     * getPredictedDateHeightTimestampCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<
          GetPredictedDateHeightTimestampSchema,
          GetPredictedDateHeightTimestampParameters,
          GetPredictedDateHeightTimestampData,
          GetPredictedDateHeightTimestampError
        >
      >,
      TCombinedResult = Array<UseQueryResult<GetPredictedDateHeightTimestampData, GetPredictedDateHeightTimestampError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetPredictedDateHeightTimestampData, GetPredictedDateHeightTimestampError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get the estimated height of a future date and time. */
    getQueryKey(
      parameters: DeepReadonly<GetPredictedDateHeightTimestampParameters> | void
    ): ServiceOperationQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get the estimated height of a future date and time.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getPredictedDateHeightTimestamp.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getPredictedDateHeightTimestamp.useQuery({
     *     path: {
     *         timestamp: timestamp
     *     },
     *     query: {
     *         blockWindow: blockWindow
     *     }
     * })
     * ```
     */
    useQuery<TData = GetPredictedDateHeightTimestampData>(
      parameters:
        | ServiceOperationQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>
        | (DeepReadonly<GetPredictedDateHeightTimestampParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetPredictedDateHeightTimestampData,
          GetPredictedDateHeightTimestampError,
          TData,
          ServiceOperationQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetPredictedDateHeightTimestampError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get the estimated height of a future date and time.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getPredictedDateHeightTimestamp.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getPredictedDateHeightTimestamp.useQuery({
     *     path: {
     *         timestamp: timestamp
     *     },
     *     query: {
     *         blockWindow: blockWindow
     *     }
     * })
     * ```
     */
    useQuery<TData = GetPredictedDateHeightTimestampData>(
      parameters:
        | ServiceOperationQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>
        | (DeepReadonly<GetPredictedDateHeightTimestampParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetPredictedDateHeightTimestampData,
          GetPredictedDateHeightTimestampError,
          TData,
          ServiceOperationQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetPredictedDateHeightTimestampError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get the estimated height of a future date and time.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getPredictedDateHeightTimestamp.useSuspenseInfiniteQuery({
     *     path: {
     *         timestamp: timestamp
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             blockWindow: initialBlockWindow
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetPredictedDateHeightTimestampParameters, TData = GetPredictedDateHeightTimestampData>(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>
        | (DeepReadonly<GetPredictedDateHeightTimestampParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetPredictedDateHeightTimestampData,
          GetPredictedDateHeightTimestampError,
          OperationInfiniteData<TData, GetPredictedDateHeightTimestampParameters>,
          GetPredictedDateHeightTimestampData,
          ServiceOperationInfiniteQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetPredictedDateHeightTimestampData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetPredictedDateHeightTimestampParameters>, GetPredictedDateHeightTimestampError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get the estimated height of a future date and time.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getPredictedDateHeightTimestampData = qraft.v1Service.getPredictedDateHeightTimestamp.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 timestamp: timestamp1
     *             },
     *             query: {
     *                 blockWindow: blockWindow1
     *             }
     *         },
     *         {
     *             path: {
     *                 timestamp: timestamp2
     *             },
     *             query: {
     *                 blockWindow: blockWindow2
     *             }
     *         }
     *     ]
     * });
     * getPredictedDateHeightTimestampResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getPredictedDateHeightTimestampCombinedData = qraft.v1Service.getPredictedDateHeightTimestamp.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 timestamp: timestamp1
     *             },
     *             query: {
     *                 blockWindow: blockWindow1
     *             }
     *         },
     *         {
     *             path: {
     *                 timestamp: timestamp2
     *             },
     *             query: {
     *                 blockWindow: blockWindow2
     *             }
     *         }
     *     ]
     * });
     * getPredictedDateHeightTimestampCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<
          GetPredictedDateHeightTimestampSchema,
          GetPredictedDateHeightTimestampParameters,
          GetPredictedDateHeightTimestampData,
          GetPredictedDateHeightTimestampError
        >
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetPredictedDateHeightTimestampData, GetPredictedDateHeightTimestampError>>
    >(options: {
      queries: T;
      combine?: (
        results: Array<WithOptional<UseSuspenseQueryResult<GetPredictedDateHeightTimestampData, GetPredictedDateHeightTimestampError>, "data">>
      ) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get the estimated height of a future date and time.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getPredictedDateHeightTimestamp.useSuspenseQuery()
     * ```
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getPredictedDateHeightTimestamp.useSuspenseQuery({
     *     path: {
     *         timestamp: timestamp
     *     },
     *     query: {
     *         blockWindow: blockWindow
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetPredictedDateHeightTimestampData>(
      parameters:
        | ServiceOperationQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>
        | (DeepReadonly<GetPredictedDateHeightTimestampParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<
          GetPredictedDateHeightTimestampData,
          GetPredictedDateHeightTimestampError,
          TData,
          ServiceOperationQueryKey<GetPredictedDateHeightTimestampSchema, GetPredictedDateHeightTimestampParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetPredictedDateHeightTimestampError | Error>;
    schema: GetPredictedDateHeightTimestampSchema;
    types: {
      parameters: GetPredictedDateHeightTimestampParameters;
      data: GetPredictedDateHeightTimestampData;
      error: GetPredictedDateHeightTimestampError;
    };
  };
  /** @summary Get a list of transactions. */
  getTransactions: {
    /** @summary Get a list of transactions. */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTransactionsSchema, GetTransactionsData, TInfinite, GetTransactionsParameters, GetTransactionsError>
        | QueryFiltersByQueryKey<GetTransactionsSchema, GetTransactionsData, TInfinite, GetTransactionsParameters, GetTransactionsError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get a list of transactions. */
    getQueryKey(parameters: DeepReadonly<GetTransactionsParameters> | void): ServiceOperationQueryKey<GetTransactionsSchema, GetTransactionsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of transactions.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getTransactions.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getTransactions.useQuery({
     *     query: {
     *         limit: limit
     *     }
     * })
     * ```
     */
    useQuery<TData = GetTransactionsData>(
      parameters: ServiceOperationQueryKey<GetTransactionsSchema, GetTransactionsParameters> | (DeepReadonly<GetTransactionsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetTransactionsData,
          GetTransactionsError,
          TData,
          ServiceOperationQueryKey<GetTransactionsSchema, GetTransactionsParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetTransactionsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of transactions.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getTransactions.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getTransactions.useQuery({
     *     query: {
     *         limit: limit
     *     }
     * })
     * ```
     */
    useQuery<TData = GetTransactionsData>(
      parameters: ServiceOperationQueryKey<GetTransactionsSchema, GetTransactionsParameters> | (DeepReadonly<GetTransactionsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetTransactionsData, GetTransactionsError, TData, ServiceOperationQueryKey<GetTransactionsSchema, GetTransactionsParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetTransactionsError | Error>;
    /** @summary Get a list of transactions. */
    fetchInfiniteQuery<TPageParam extends GetTransactionsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetTransactionsSchema,
        GetTransactionsData,
        GetTransactionsParameters,
        DeepReadonly<TPageParam>,
        GetTransactionsError
      > | void
    ): Promise<OperationInfiniteData<GetTransactionsData, GetTransactionsParameters>>;
    /** @summary Get a list of transactions. */
    prefetchInfiniteQuery<TPageParam extends GetTransactionsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetTransactionsSchema,
        GetTransactionsData,
        GetTransactionsParameters,
        DeepReadonly<TPageParam>,
        GetTransactionsError
      > | void
    ): Promise<void>;
    /** @summary Get a list of transactions. */
    ensureInfiniteQueryData<TPageParam extends GetTransactionsParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetTransactionsSchema,
        GetTransactionsData,
        GetTransactionsParameters,
        DeepReadonly<TPageParam>,
        GetTransactionsError
      > | void
    ): Promise<OperationInfiniteData<GetTransactionsData, GetTransactionsParameters>>;
    /** @summary Get a list of transactions. */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetTransactionsSchema, GetTransactionsData, GetTransactionsParameters, GetTransactionsError> | void
    ): Promise<GetTransactionsData>;
    /** @summary Get a list of transactions. */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetTransactionsSchema, GetTransactionsData, GetTransactionsParameters, GetTransactionsError> | void
    ): Promise<void>;
    /** @summary Get a list of transactions. */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetTransactionsSchema, GetTransactionsData, GetTransactionsParameters, GetTransactionsError> | void
    ): Promise<GetTransactionsData>;
    /** @summary Get a list of transactions. */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetTransactionsSchema, GetTransactionsParameters> | (DeepReadonly<GetTransactionsParameters> | void)
    ): OperationInfiniteData<GetTransactionsData, GetTransactionsParameters> | undefined;
    /** @summary Get a list of transactions. */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTransactionsSchema, GetTransactionsData, TInfinite, GetTransactionsParameters, GetTransactionsError>
        | QueryFiltersByQueryKey<GetTransactionsSchema, GetTransactionsData, TInfinite, GetTransactionsParameters, GetTransactionsError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetTransactionsSchema, GetTransactionsParameters>,
            data: NoInfer<OperationInfiniteData<GetTransactionsData, GetTransactionsParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetTransactionsSchema, GetTransactionsParameters>, data: GetTransactionsData | undefined]>;
    /** @summary Get a list of transactions. */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetTransactionsSchema, GetTransactionsParameters> | (DeepReadonly<GetTransactionsParameters> | void)
    ): GetTransactionsData | undefined;
    /** @summary Get a list of transactions. */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetTransactionsSchema, GetTransactionsParameters> | (DeepReadonly<GetTransactionsParameters> | void)
    ): QueryState<GetTransactionsData, GetTransactionsError> | undefined;
    /** @summary Get a list of transactions. */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetTransactionsParameters> | ServiceOperationInfiniteQueryKey<GetTransactionsSchema, GetTransactionsParameters> | void
    ): QueryState<OperationInfiniteData<GetTransactionsData, GetTransactionsParameters>, GetTransactionsError> | undefined;
    /** @summary Get a list of transactions. */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetTransactionsSchema, GetTransactionsData, TInfinite, GetTransactionsParameters, GetTransactionsError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get a list of transactions. */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTransactionsSchema, GetTransactionsData, TInfinite, GetTransactionsParameters, GetTransactionsError>
        | QueryFiltersByQueryKey<GetTransactionsSchema, GetTransactionsData, TInfinite, GetTransactionsParameters, GetTransactionsError>
    ): number;
    /** @summary Get a list of transactions. */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetTransactionsSchema, GetTransactionsParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetTransactionsParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetTransactionsSchema,
        options: {
          parameters: GetTransactionsParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetTransactionsData, GetTransactionsError>>
    ): Promise<RequestFnResponse<GetTransactionsData, GetTransactionsError>>;
    /** @summary Get a list of transactions. */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTransactionsSchema, GetTransactionsData, TInfinite, GetTransactionsParameters, GetTransactionsError>
        | QueryFiltersByQueryKey<GetTransactionsSchema, GetTransactionsData, TInfinite, GetTransactionsParameters, GetTransactionsError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get a list of transactions. */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTransactionsSchema, GetTransactionsData, TInfinite, GetTransactionsParameters, GetTransactionsError>
        | QueryFiltersByQueryKey<GetTransactionsSchema, GetTransactionsData, TInfinite, GetTransactionsParameters, GetTransactionsError>
    ): void;
    /** @summary Get a list of transactions. */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTransactionsSchema, GetTransactionsData, TInfinite, GetTransactionsParameters, GetTransactionsError>
        | QueryFiltersByQueryKey<GetTransactionsSchema, GetTransactionsData, TInfinite, GetTransactionsParameters, GetTransactionsError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get a list of transactions. */
    setInfiniteQueryData(
      parameters: (DeepReadonly<GetTransactionsParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetTransactionsSchema, GetTransactionsParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetTransactionsData, GetTransactionsParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetTransactionsData, GetTransactionsParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetTransactionsData, GetTransactionsParameters> | undefined;
    /** @summary Get a list of transactions. */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetTransactionsSchema, GetTransactionsData, TInfinite, GetTransactionsParameters, GetTransactionsError>
        | QueryFiltersByQueryKey<GetTransactionsSchema, GetTransactionsData, TInfinite, GetTransactionsParameters, GetTransactionsError>,
      updater: Updater<NoInfer<GetTransactionsData> | undefined, NoInfer<GetTransactionsData> | undefined>,
      options?: SetDataOptions
    ): Array<GetTransactionsData | undefined>;
    /** @summary Get a list of transactions. */
    setQueryData(
      parameters: (DeepReadonly<GetTransactionsParameters> | undefined) | ServiceOperationQueryKey<GetTransactionsSchema, GetTransactionsParameters>,
      updater: Updater<NoInfer<GetTransactionsData> | undefined, NoInfer<DeepReadonly<GetTransactionsData>> | undefined>,
      options?: SetDataOptions
    ): GetTransactionsData | undefined;
    /** @summary Get a list of transactions. */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetTransactionsParameters> | void
    ): ServiceOperationInfiniteQueryKey<GetTransactionsSchema, GetTransactionsParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of transactions.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getTransactions.useInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             limit: initialLimit
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetTransactionsParameters,
      TQueryFnData = GetTransactionsData,
      TData = OperationInfiniteData<TQueryFnData, GetTransactionsParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetTransactionsSchema, GetTransactionsParameters> | (DeepReadonly<GetTransactionsParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetTransactionsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetTransactionsSchema, GetTransactionsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetTransactionsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of transactions.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getTransactions.useInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             limit: initialLimit
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetTransactionsParameters,
      TQueryFnData = GetTransactionsData,
      TData = OperationInfiniteData<TQueryFnData, GetTransactionsParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetTransactionsSchema, GetTransactionsParameters> | (DeepReadonly<GetTransactionsParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetTransactionsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetTransactionsSchema, GetTransactionsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetTransactionsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetTransactionsError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get a list of transactions.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getTransactionsTotal = qraft.v1Service.getTransactions.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getTransactionsByParametersTotal = qraft.v1Service.getTransactions.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         query: {
     *             limit: limit
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTransactionsSchema, GetTransactionsData, TInfinite, GetTransactionsParameters, GetTransactionsError>
        | QueryFiltersByQueryKey<GetTransactionsSchema, GetTransactionsData, TInfinite, GetTransactionsParameters, GetTransactionsError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get a list of transactions.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getTransactionsResults = qraft.v1Service.getTransactions.useQueries({
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             }
     *         }
     *     ]
     * });
     * getTransactionsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getTransactionsCombinedResults = qraft.v1Service.getTransactions.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             }
     *         }
     *     ]
     * });
     * getTransactionsCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetTransactionsSchema, GetTransactionsParameters, GetTransactionsData, GetTransactionsError>>,
      TCombinedResult = Array<UseQueryResult<GetTransactionsData, GetTransactionsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetTransactionsData, GetTransactionsError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get a list of transactions. */
    getQueryKey(parameters: DeepReadonly<GetTransactionsParameters> | void): ServiceOperationQueryKey<GetTransactionsSchema, GetTransactionsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of transactions.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getTransactions.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getTransactions.useQuery({
     *     query: {
     *         limit: limit
     *     }
     * })
     * ```
     */
    useQuery<TData = GetTransactionsData>(
      parameters: ServiceOperationQueryKey<GetTransactionsSchema, GetTransactionsParameters> | (DeepReadonly<GetTransactionsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetTransactionsData,
          GetTransactionsError,
          TData,
          ServiceOperationQueryKey<GetTransactionsSchema, GetTransactionsParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetTransactionsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of transactions.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getTransactions.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getTransactions.useQuery({
     *     query: {
     *         limit: limit
     *     }
     * })
     * ```
     */
    useQuery<TData = GetTransactionsData>(
      parameters: ServiceOperationQueryKey<GetTransactionsSchema, GetTransactionsParameters> | (DeepReadonly<GetTransactionsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetTransactionsData, GetTransactionsError, TData, ServiceOperationQueryKey<GetTransactionsSchema, GetTransactionsParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetTransactionsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get a list of transactions.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getTransactions.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             limit: initialLimit
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetTransactionsParameters, TData = GetTransactionsData>(
      parameters: ServiceOperationInfiniteQueryKey<GetTransactionsSchema, GetTransactionsParameters> | (DeepReadonly<GetTransactionsParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetTransactionsData,
          GetTransactionsError,
          OperationInfiniteData<TData, GetTransactionsParameters>,
          GetTransactionsData,
          ServiceOperationInfiniteQueryKey<GetTransactionsSchema, GetTransactionsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetTransactionsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetTransactionsParameters>, GetTransactionsError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get a list of transactions.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getTransactionsData = qraft.v1Service.getTransactions.useSuspenseQueries({
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             }
     *         }
     *     ]
     * });
     * getTransactionsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getTransactionsCombinedData = qraft.v1Service.getTransactions.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             }
     *         }
     *     ]
     * });
     * getTransactionsCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetTransactionsSchema, GetTransactionsParameters, GetTransactionsData, GetTransactionsError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetTransactionsData, GetTransactionsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetTransactionsData, GetTransactionsError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get a list of transactions.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getTransactions.useSuspenseQuery()
     * ```
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getTransactions.useSuspenseQuery({
     *     query: {
     *         limit: limit
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetTransactionsData>(
      parameters: ServiceOperationQueryKey<GetTransactionsSchema, GetTransactionsParameters> | (DeepReadonly<GetTransactionsParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<GetTransactionsData, GetTransactionsError, TData, ServiceOperationQueryKey<GetTransactionsSchema, GetTransactionsParameters>>,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetTransactionsError | Error>;
    schema: GetTransactionsSchema;
    types: {
      parameters: GetTransactionsParameters;
      data: GetTransactionsData;
      error: GetTransactionsError;
    };
  };
  /** @summary Get a transaction by hash. */
  getTransactionsHash: {
    /** @summary Get a transaction by hash. */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTransactionsHashSchema, GetTransactionsHashData, TInfinite, GetTransactionsHashParameters, GetTransactionsHashError>
        | QueryFiltersByQueryKey<GetTransactionsHashSchema, GetTransactionsHashData, TInfinite, GetTransactionsHashParameters, GetTransactionsHashError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get a transaction by hash. */
    getQueryKey(parameters: DeepReadonly<GetTransactionsHashParameters>): ServiceOperationQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a transaction by hash.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getTransactionsHash.useQuery({
     *     path: {
     *         hash: hash
     *     }
     * })
     * ```
     */
    useQuery<TData = GetTransactionsHashData>(
      parameters: ServiceOperationQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters> | DeepReadonly<GetTransactionsHashParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetTransactionsHashData,
          GetTransactionsHashError,
          TData,
          ServiceOperationQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetTransactionsHashError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a transaction by hash.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getTransactionsHash.useQuery({
     *     path: {
     *         hash: hash
     *     }
     * })
     * ```
     */
    useQuery<TData = GetTransactionsHashData>(
      parameters: ServiceOperationQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters> | DeepReadonly<GetTransactionsHashParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetTransactionsHashData,
          GetTransactionsHashError,
          TData,
          ServiceOperationQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetTransactionsHashError | Error>;
    /** @summary Get a transaction by hash. */
    fetchInfiniteQuery<TPageParam extends GetTransactionsHashParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetTransactionsHashSchema,
        GetTransactionsHashData,
        GetTransactionsHashParameters,
        DeepReadonly<TPageParam>,
        GetTransactionsHashError
      >
    ): Promise<OperationInfiniteData<GetTransactionsHashData, GetTransactionsHashParameters>>;
    /** @summary Get a transaction by hash. */
    prefetchInfiniteQuery<TPageParam extends GetTransactionsHashParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetTransactionsHashSchema,
        GetTransactionsHashData,
        GetTransactionsHashParameters,
        DeepReadonly<TPageParam>,
        GetTransactionsHashError
      >
    ): Promise<void>;
    /** @summary Get a transaction by hash. */
    ensureInfiniteQueryData<TPageParam extends GetTransactionsHashParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetTransactionsHashSchema,
        GetTransactionsHashData,
        GetTransactionsHashParameters,
        DeepReadonly<TPageParam>,
        GetTransactionsHashError
      >
    ): Promise<OperationInfiniteData<GetTransactionsHashData, GetTransactionsHashParameters>>;
    /** @summary Get a transaction by hash. */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetTransactionsHashSchema, GetTransactionsHashData, GetTransactionsHashParameters, GetTransactionsHashError>
    ): Promise<GetTransactionsHashData>;
    /** @summary Get a transaction by hash. */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetTransactionsHashSchema, GetTransactionsHashData, GetTransactionsHashParameters, GetTransactionsHashError>
    ): Promise<void>;
    /** @summary Get a transaction by hash. */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetTransactionsHashSchema,
        GetTransactionsHashData,
        GetTransactionsHashParameters,
        GetTransactionsHashError
      >
    ): Promise<GetTransactionsHashData>;
    /** @summary Get a transaction by hash. */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters> | DeepReadonly<GetTransactionsHashParameters>
    ): OperationInfiniteData<GetTransactionsHashData, GetTransactionsHashParameters> | undefined;
    /** @summary Get a transaction by hash. */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTransactionsHashSchema, GetTransactionsHashData, TInfinite, GetTransactionsHashParameters, GetTransactionsHashError>
        | QueryFiltersByQueryKey<GetTransactionsHashSchema, GetTransactionsHashData, TInfinite, GetTransactionsHashParameters, GetTransactionsHashError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters>,
            data: NoInfer<OperationInfiniteData<GetTransactionsHashData, GetTransactionsHashParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters>, data: GetTransactionsHashData | undefined]>;
    /** @summary Get a transaction by hash. */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters> | DeepReadonly<GetTransactionsHashParameters>
    ): GetTransactionsHashData | undefined;
    /** @summary Get a transaction by hash. */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters> | DeepReadonly<GetTransactionsHashParameters>
    ): QueryState<GetTransactionsHashData, GetTransactionsHashError> | undefined;
    /** @summary Get a transaction by hash. */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetTransactionsHashParameters> | ServiceOperationInfiniteQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters>
    ): QueryState<OperationInfiniteData<GetTransactionsHashData, GetTransactionsHashParameters>, GetTransactionsHashError> | undefined;
    /** @summary Get a transaction by hash. */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetTransactionsHashSchema, GetTransactionsHashData, TInfinite, GetTransactionsHashParameters, GetTransactionsHashError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get a transaction by hash. */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTransactionsHashSchema, GetTransactionsHashData, TInfinite, GetTransactionsHashParameters, GetTransactionsHashError>
        | QueryFiltersByQueryKey<GetTransactionsHashSchema, GetTransactionsHashData, TInfinite, GetTransactionsHashParameters, GetTransactionsHashError>
    ): number;
    /** @summary Get a transaction by hash. */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetTransactionsHashParameters, TMeta, TSignal>,
      client?: (
        schema: GetTransactionsHashSchema,
        options: {
          parameters: GetTransactionsHashParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetTransactionsHashData, GetTransactionsHashError>>
    ): Promise<RequestFnResponse<GetTransactionsHashData, GetTransactionsHashError>>;
    /** @summary Get a transaction by hash. */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTransactionsHashSchema, GetTransactionsHashData, TInfinite, GetTransactionsHashParameters, GetTransactionsHashError>
        | QueryFiltersByQueryKey<GetTransactionsHashSchema, GetTransactionsHashData, TInfinite, GetTransactionsHashParameters, GetTransactionsHashError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get a transaction by hash. */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTransactionsHashSchema, GetTransactionsHashData, TInfinite, GetTransactionsHashParameters, GetTransactionsHashError>
        | QueryFiltersByQueryKey<GetTransactionsHashSchema, GetTransactionsHashData, TInfinite, GetTransactionsHashParameters, GetTransactionsHashError>
    ): void;
    /** @summary Get a transaction by hash. */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTransactionsHashSchema, GetTransactionsHashData, TInfinite, GetTransactionsHashParameters, GetTransactionsHashError>
        | QueryFiltersByQueryKey<GetTransactionsHashSchema, GetTransactionsHashData, TInfinite, GetTransactionsHashParameters, GetTransactionsHashError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get a transaction by hash. */
    setInfiniteQueryData(
      parameters: DeepReadonly<GetTransactionsHashParameters> | ServiceOperationInfiniteQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetTransactionsHashData, GetTransactionsHashParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetTransactionsHashData, GetTransactionsHashParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetTransactionsHashData, GetTransactionsHashParameters> | undefined;
    /** @summary Get a transaction by hash. */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetTransactionsHashSchema, GetTransactionsHashData, TInfinite, GetTransactionsHashParameters, GetTransactionsHashError>
        | QueryFiltersByQueryKey<GetTransactionsHashSchema, GetTransactionsHashData, TInfinite, GetTransactionsHashParameters, GetTransactionsHashError>,
      updater: Updater<NoInfer<GetTransactionsHashData> | undefined, NoInfer<GetTransactionsHashData> | undefined>,
      options?: SetDataOptions
    ): Array<GetTransactionsHashData | undefined>;
    /** @summary Get a transaction by hash. */
    setQueryData(
      parameters: DeepReadonly<GetTransactionsHashParameters> | ServiceOperationQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters>,
      updater: Updater<NoInfer<GetTransactionsHashData> | undefined, NoInfer<DeepReadonly<GetTransactionsHashData>> | undefined>,
      options?: SetDataOptions
    ): GetTransactionsHashData | undefined;
    /** @summary Get a transaction by hash. */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetTransactionsHashParameters>
    ): ServiceOperationInfiniteQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a transaction by hash.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getTransactionsHash.useInfiniteQuery({
     *     path: {
     *         hash: hash
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetTransactionsHashParameters,
      TQueryFnData = GetTransactionsHashData,
      TData = OperationInfiniteData<TQueryFnData, GetTransactionsHashParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters> | DeepReadonly<GetTransactionsHashParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetTransactionsHashError,
          TData,
          ServiceOperationInfiniteQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetTransactionsHashError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a transaction by hash.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getTransactionsHash.useInfiniteQuery({
     *     path: {
     *         hash: hash
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetTransactionsHashParameters,
      TQueryFnData = GetTransactionsHashData,
      TData = OperationInfiniteData<TQueryFnData, GetTransactionsHashParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters> | DeepReadonly<GetTransactionsHashParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetTransactionsHashError,
          TData,
          ServiceOperationInfiniteQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetTransactionsHashData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetTransactionsHashError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get a transaction by hash.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getTransactionsHashTotal = qraft.v1Service.getTransactionsHash.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getTransactionsHashByParametersTotal = qraft.v1Service.getTransactionsHash.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             hash: hash
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTransactionsHashSchema, GetTransactionsHashData, TInfinite, GetTransactionsHashParameters, GetTransactionsHashError>
        | QueryFiltersByQueryKey<GetTransactionsHashSchema, GetTransactionsHashData, TInfinite, GetTransactionsHashParameters, GetTransactionsHashError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get a transaction by hash.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getTransactionsHashResults = qraft.v1Service.getTransactionsHash.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 hash: hash1
     *             }
     *         },
     *         {
     *             path: {
     *                 hash: hash2
     *             }
     *         }
     *     ]
     * });
     * getTransactionsHashResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getTransactionsHashCombinedResults = qraft.v1Service.getTransactionsHash.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 hash: hash1
     *             }
     *         },
     *         {
     *             path: {
     *                 hash: hash2
     *             }
     *         }
     *     ]
     * });
     * getTransactionsHashCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<GetTransactionsHashSchema, GetTransactionsHashParameters, GetTransactionsHashData, GetTransactionsHashError>
      >,
      TCombinedResult = Array<UseQueryResult<GetTransactionsHashData, GetTransactionsHashError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetTransactionsHashData, GetTransactionsHashError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get a transaction by hash. */
    getQueryKey(parameters: DeepReadonly<GetTransactionsHashParameters>): ServiceOperationQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a transaction by hash.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getTransactionsHash.useQuery({
     *     path: {
     *         hash: hash
     *     }
     * })
     * ```
     */
    useQuery<TData = GetTransactionsHashData>(
      parameters: ServiceOperationQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters> | DeepReadonly<GetTransactionsHashParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetTransactionsHashData,
          GetTransactionsHashError,
          TData,
          ServiceOperationQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetTransactionsHashError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a transaction by hash.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getTransactionsHash.useQuery({
     *     path: {
     *         hash: hash
     *     }
     * })
     * ```
     */
    useQuery<TData = GetTransactionsHashData>(
      parameters: ServiceOperationQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters> | DeepReadonly<GetTransactionsHashParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetTransactionsHashData,
          GetTransactionsHashError,
          TData,
          ServiceOperationQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetTransactionsHashError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get a transaction by hash.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getTransactionsHash.useSuspenseInfiniteQuery({
     *     path: {
     *         hash: hash
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetTransactionsHashParameters, TData = GetTransactionsHashData>(
      parameters: ServiceOperationInfiniteQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters> | DeepReadonly<GetTransactionsHashParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetTransactionsHashData,
          GetTransactionsHashError,
          OperationInfiniteData<TData, GetTransactionsHashParameters>,
          GetTransactionsHashData,
          ServiceOperationInfiniteQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetTransactionsHashData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetTransactionsHashParameters>, GetTransactionsHashError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get a transaction by hash.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getTransactionsHashData = qraft.v1Service.getTransactionsHash.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 hash: hash1
     *             }
     *         },
     *         {
     *             path: {
     *                 hash: hash2
     *             }
     *         }
     *     ]
     * });
     * getTransactionsHashResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getTransactionsHashCombinedData = qraft.v1Service.getTransactionsHash.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 hash: hash1
     *             }
     *         },
     *         {
     *             path: {
     *                 hash: hash2
     *             }
     *         }
     *     ]
     * });
     * getTransactionsHashCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<GetTransactionsHashSchema, GetTransactionsHashParameters, GetTransactionsHashData, GetTransactionsHashError>
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetTransactionsHashData, GetTransactionsHashError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetTransactionsHashData, GetTransactionsHashError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get a transaction by hash.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getTransactionsHash.useSuspenseQuery({
     *     path: {
     *         hash: hash
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetTransactionsHashData>(
      parameters: ServiceOperationQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters> | DeepReadonly<GetTransactionsHashParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<
          GetTransactionsHashData,
          GetTransactionsHashError,
          TData,
          ServiceOperationQueryKey<GetTransactionsHashSchema, GetTransactionsHashParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetTransactionsHashError | Error>;
    schema: GetTransactionsHashSchema;
    types: {
      parameters: GetTransactionsHashParameters;
      data: GetTransactionsHashData;
      error: GetTransactionsHashError;
    };
  };
  getMarketDataCoin: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetMarketDataCoinSchema, GetMarketDataCoinData, TInfinite, GetMarketDataCoinParameters, GetMarketDataCoinError>
        | QueryFiltersByQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinData, TInfinite, GetMarketDataCoinParameters, GetMarketDataCoinError>,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(parameters: DeepReadonly<GetMarketDataCoinParameters> | void): ServiceOperationQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getMarketDataCoin.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getMarketDataCoin.useQuery({
     *     path: {
     *         coin: coin
     *     }
     * })
     * ```
     */
    useQuery<TData = GetMarketDataCoinData>(
      parameters: ServiceOperationQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters> | (DeepReadonly<GetMarketDataCoinParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetMarketDataCoinData,
          GetMarketDataCoinError,
          TData,
          ServiceOperationQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetMarketDataCoinError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getMarketDataCoin.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getMarketDataCoin.useQuery({
     *     path: {
     *         coin: coin
     *     }
     * })
     * ```
     */
    useQuery<TData = GetMarketDataCoinData>(
      parameters: ServiceOperationQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters> | (DeepReadonly<GetMarketDataCoinParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetMarketDataCoinData,
          GetMarketDataCoinError,
          TData,
          ServiceOperationQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetMarketDataCoinError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetMarketDataCoinParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetMarketDataCoinSchema,
        GetMarketDataCoinData,
        GetMarketDataCoinParameters,
        DeepReadonly<TPageParam>,
        GetMarketDataCoinError
      > | void
    ): Promise<OperationInfiniteData<GetMarketDataCoinData, GetMarketDataCoinParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetMarketDataCoinParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetMarketDataCoinSchema,
        GetMarketDataCoinData,
        GetMarketDataCoinParameters,
        DeepReadonly<TPageParam>,
        GetMarketDataCoinError
      > | void
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetMarketDataCoinParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetMarketDataCoinSchema,
        GetMarketDataCoinData,
        GetMarketDataCoinParameters,
        DeepReadonly<TPageParam>,
        GetMarketDataCoinError
      > | void
    ): Promise<OperationInfiniteData<GetMarketDataCoinData, GetMarketDataCoinParameters>>;
    /**/
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetMarketDataCoinSchema, GetMarketDataCoinData, GetMarketDataCoinParameters, GetMarketDataCoinError> | void
    ): Promise<GetMarketDataCoinData>;
    /**/
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetMarketDataCoinSchema, GetMarketDataCoinData, GetMarketDataCoinParameters, GetMarketDataCoinError> | void
    ): Promise<void>;
    /**/
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetMarketDataCoinSchema,
        GetMarketDataCoinData,
        GetMarketDataCoinParameters,
        GetMarketDataCoinError
      > | void
    ): Promise<GetMarketDataCoinData>;
    /**/
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters> | (DeepReadonly<GetMarketDataCoinParameters> | void)
    ): OperationInfiniteData<GetMarketDataCoinData, GetMarketDataCoinParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetMarketDataCoinSchema, GetMarketDataCoinData, TInfinite, GetMarketDataCoinParameters, GetMarketDataCoinError>
        | QueryFiltersByQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinData, TInfinite, GetMarketDataCoinParameters, GetMarketDataCoinError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters>,
            data: NoInfer<OperationInfiniteData<GetMarketDataCoinData, GetMarketDataCoinParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters>, data: GetMarketDataCoinData | undefined]>;
    /**/
    getQueryData(
      parameters: ServiceOperationQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters> | (DeepReadonly<GetMarketDataCoinParameters> | void)
    ): GetMarketDataCoinData | undefined;
    /**/
    getQueryState(
      parameters: ServiceOperationQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters> | (DeepReadonly<GetMarketDataCoinParameters> | void)
    ): QueryState<GetMarketDataCoinData, GetMarketDataCoinError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters: DeepReadonly<GetMarketDataCoinParameters> | ServiceOperationInfiniteQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters> | void
    ): QueryState<OperationInfiniteData<GetMarketDataCoinData, GetMarketDataCoinParameters>, GetMarketDataCoinError> | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetMarketDataCoinSchema, GetMarketDataCoinData, TInfinite, GetMarketDataCoinParameters, GetMarketDataCoinError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetMarketDataCoinSchema, GetMarketDataCoinData, TInfinite, GetMarketDataCoinParameters, GetMarketDataCoinError>
        | QueryFiltersByQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinData, TInfinite, GetMarketDataCoinParameters, GetMarketDataCoinError>
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetMarketDataCoinParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetMarketDataCoinSchema,
        options: {
          parameters: GetMarketDataCoinParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetMarketDataCoinData, GetMarketDataCoinError>>
    ): Promise<RequestFnResponse<GetMarketDataCoinData, GetMarketDataCoinError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetMarketDataCoinSchema, GetMarketDataCoinData, TInfinite, GetMarketDataCoinParameters, GetMarketDataCoinError>
        | QueryFiltersByQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinData, TInfinite, GetMarketDataCoinParameters, GetMarketDataCoinError>,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetMarketDataCoinSchema, GetMarketDataCoinData, TInfinite, GetMarketDataCoinParameters, GetMarketDataCoinError>
        | QueryFiltersByQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinData, TInfinite, GetMarketDataCoinParameters, GetMarketDataCoinError>
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetMarketDataCoinSchema, GetMarketDataCoinData, TInfinite, GetMarketDataCoinParameters, GetMarketDataCoinError>
        | QueryFiltersByQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinData, TInfinite, GetMarketDataCoinParameters, GetMarketDataCoinError>,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters:
        | (DeepReadonly<GetMarketDataCoinParameters> | undefined)
        | ServiceOperationInfiniteQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetMarketDataCoinData, GetMarketDataCoinParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetMarketDataCoinData, GetMarketDataCoinParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetMarketDataCoinData, GetMarketDataCoinParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetMarketDataCoinSchema, GetMarketDataCoinData, TInfinite, GetMarketDataCoinParameters, GetMarketDataCoinError>
        | QueryFiltersByQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinData, TInfinite, GetMarketDataCoinParameters, GetMarketDataCoinError>,
      updater: Updater<NoInfer<GetMarketDataCoinData> | undefined, NoInfer<GetMarketDataCoinData> | undefined>,
      options?: SetDataOptions
    ): Array<GetMarketDataCoinData | undefined>;
    /**/
    setQueryData(
      parameters: (DeepReadonly<GetMarketDataCoinParameters> | undefined) | ServiceOperationQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters>,
      updater: Updater<NoInfer<GetMarketDataCoinData> | undefined, NoInfer<DeepReadonly<GetMarketDataCoinData>> | undefined>,
      options?: SetDataOptions
    ): GetMarketDataCoinData | undefined;
    /**/
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetMarketDataCoinParameters> | void
    ): ServiceOperationInfiniteQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getMarketDataCoin.useInfiniteQuery({
     *     path: {
     *         coin: coin
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetMarketDataCoinParameters,
      TQueryFnData = GetMarketDataCoinData,
      TData = OperationInfiniteData<TQueryFnData, GetMarketDataCoinParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters> | (DeepReadonly<GetMarketDataCoinParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetMarketDataCoinError,
          TData,
          ServiceOperationInfiniteQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetMarketDataCoinError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getMarketDataCoin.useInfiniteQuery({
     *     path: {
     *         coin: coin
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetMarketDataCoinParameters,
      TQueryFnData = GetMarketDataCoinData,
      TData = OperationInfiniteData<TQueryFnData, GetMarketDataCoinParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters> | (DeepReadonly<GetMarketDataCoinParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetMarketDataCoinError,
          TData,
          ServiceOperationInfiniteQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetMarketDataCoinData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetMarketDataCoinError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getMarketDataCoinTotal = qraft.v1Service.getMarketDataCoin.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getMarketDataCoinByParametersTotal = qraft.v1Service.getMarketDataCoin.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             coin: coin
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetMarketDataCoinSchema, GetMarketDataCoinData, TInfinite, GetMarketDataCoinParameters, GetMarketDataCoinError>
        | QueryFiltersByQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinData, TInfinite, GetMarketDataCoinParameters, GetMarketDataCoinError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getMarketDataCoinResults = qraft.v1Service.getMarketDataCoin.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 coin: coin1
     *             }
     *         },
     *         {
     *             path: {
     *                 coin: coin2
     *             }
     *         }
     *     ]
     * });
     * getMarketDataCoinResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getMarketDataCoinCombinedResults = qraft.v1Service.getMarketDataCoin.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 coin: coin1
     *             }
     *         },
     *         {
     *             path: {
     *                 coin: coin2
     *             }
     *         }
     *     ]
     * });
     * getMarketDataCoinCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetMarketDataCoinSchema, GetMarketDataCoinParameters, GetMarketDataCoinData, GetMarketDataCoinError>>,
      TCombinedResult = Array<UseQueryResult<GetMarketDataCoinData, GetMarketDataCoinError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetMarketDataCoinData, GetMarketDataCoinError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(parameters: DeepReadonly<GetMarketDataCoinParameters> | void): ServiceOperationQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getMarketDataCoin.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getMarketDataCoin.useQuery({
     *     path: {
     *         coin: coin
     *     }
     * })
     * ```
     */
    useQuery<TData = GetMarketDataCoinData>(
      parameters: ServiceOperationQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters> | (DeepReadonly<GetMarketDataCoinParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetMarketDataCoinData,
          GetMarketDataCoinError,
          TData,
          ServiceOperationQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetMarketDataCoinError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getMarketDataCoin.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getMarketDataCoin.useQuery({
     *     path: {
     *         coin: coin
     *     }
     * })
     * ```
     */
    useQuery<TData = GetMarketDataCoinData>(
      parameters: ServiceOperationQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters> | (DeepReadonly<GetMarketDataCoinParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetMarketDataCoinData,
          GetMarketDataCoinError,
          TData,
          ServiceOperationQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetMarketDataCoinError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getMarketDataCoin.useSuspenseInfiniteQuery({
     *     path: {
     *         coin: coin
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetMarketDataCoinParameters, TData = GetMarketDataCoinData>(
      parameters: ServiceOperationInfiniteQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters> | (DeepReadonly<GetMarketDataCoinParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetMarketDataCoinData,
          GetMarketDataCoinError,
          OperationInfiniteData<TData, GetMarketDataCoinParameters>,
          GetMarketDataCoinData,
          ServiceOperationInfiniteQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetMarketDataCoinData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetMarketDataCoinParameters>, GetMarketDataCoinError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getMarketDataCoinData = qraft.v1Service.getMarketDataCoin.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 coin: coin1
     *             }
     *         },
     *         {
     *             path: {
     *                 coin: coin2
     *             }
     *         }
     *     ]
     * });
     * getMarketDataCoinResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getMarketDataCoinCombinedData = qraft.v1Service.getMarketDataCoin.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 coin: coin1
     *             }
     *         },
     *         {
     *             path: {
     *                 coin: coin2
     *             }
     *         }
     *     ]
     * });
     * getMarketDataCoinCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetMarketDataCoinSchema, GetMarketDataCoinParameters, GetMarketDataCoinData, GetMarketDataCoinError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetMarketDataCoinData, GetMarketDataCoinError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetMarketDataCoinData, GetMarketDataCoinError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getMarketDataCoin.useSuspenseQuery()
     * ```
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getMarketDataCoin.useSuspenseQuery({
     *     path: {
     *         coin: coin
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetMarketDataCoinData>(
      parameters: ServiceOperationQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters> | (DeepReadonly<GetMarketDataCoinParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<
          GetMarketDataCoinData,
          GetMarketDataCoinError,
          TData,
          ServiceOperationQueryKey<GetMarketDataCoinSchema, GetMarketDataCoinParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetMarketDataCoinError | Error>;
    schema: GetMarketDataCoinSchema;
    types: {
      parameters: GetMarketDataCoinParameters;
      data: GetMarketDataCoinData;
      error: GetMarketDataCoinError;
    };
  };
  getValidators: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetValidatorsSchema, GetValidatorsData, TInfinite, GetValidatorsParameters, GetValidatorsError>
        | QueryFiltersByQueryKey<GetValidatorsSchema, GetValidatorsData, TInfinite, GetValidatorsParameters, GetValidatorsError>,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(parameters: DeepReadonly<GetValidatorsParameters> | void): ServiceOperationQueryKey<GetValidatorsSchema, GetValidatorsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getValidators.useQuery()
     * ```
     */
    useQuery<TData = GetValidatorsData>(
      parameters: ServiceOperationQueryKey<GetValidatorsSchema, GetValidatorsParameters> | (DeepReadonly<GetValidatorsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetValidatorsData, GetValidatorsError, TData, ServiceOperationQueryKey<GetValidatorsSchema, GetValidatorsParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetValidatorsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getValidators.useQuery()
     * ```
     */
    useQuery<TData = GetValidatorsData>(
      parameters: ServiceOperationQueryKey<GetValidatorsSchema, GetValidatorsParameters> | (DeepReadonly<GetValidatorsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetValidatorsData, GetValidatorsError, TData, ServiceOperationQueryKey<GetValidatorsSchema, GetValidatorsParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetValidatorsError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetValidatorsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetValidatorsSchema,
        GetValidatorsData,
        GetValidatorsParameters,
        DeepReadonly<TPageParam>,
        GetValidatorsError
      > | void
    ): Promise<OperationInfiniteData<GetValidatorsData, GetValidatorsParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetValidatorsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetValidatorsSchema,
        GetValidatorsData,
        GetValidatorsParameters,
        DeepReadonly<TPageParam>,
        GetValidatorsError
      > | void
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetValidatorsParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetValidatorsSchema,
        GetValidatorsData,
        GetValidatorsParameters,
        DeepReadonly<TPageParam>,
        GetValidatorsError
      > | void
    ): Promise<OperationInfiniteData<GetValidatorsData, GetValidatorsParameters>>;
    /**/
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetValidatorsSchema, GetValidatorsData, GetValidatorsParameters, GetValidatorsError> | void
    ): Promise<GetValidatorsData>;
    /**/
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetValidatorsSchema, GetValidatorsData, GetValidatorsParameters, GetValidatorsError> | void
    ): Promise<void>;
    /**/
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetValidatorsSchema, GetValidatorsData, GetValidatorsParameters, GetValidatorsError> | void
    ): Promise<GetValidatorsData>;
    /**/
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetValidatorsSchema, GetValidatorsParameters> | (DeepReadonly<GetValidatorsParameters> | void)
    ): OperationInfiniteData<GetValidatorsData, GetValidatorsParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetValidatorsSchema, GetValidatorsData, TInfinite, GetValidatorsParameters, GetValidatorsError>
        | QueryFiltersByQueryKey<GetValidatorsSchema, GetValidatorsData, TInfinite, GetValidatorsParameters, GetValidatorsError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetValidatorsSchema, GetValidatorsParameters>,
            data: NoInfer<OperationInfiniteData<GetValidatorsData, GetValidatorsParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetValidatorsSchema, GetValidatorsParameters>, data: GetValidatorsData | undefined]>;
    /**/
    getQueryData(
      parameters: ServiceOperationQueryKey<GetValidatorsSchema, GetValidatorsParameters> | (DeepReadonly<GetValidatorsParameters> | void)
    ): GetValidatorsData | undefined;
    /**/
    getQueryState(
      parameters: ServiceOperationQueryKey<GetValidatorsSchema, GetValidatorsParameters> | (DeepReadonly<GetValidatorsParameters> | void)
    ): QueryState<GetValidatorsData, GetValidatorsError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters: DeepReadonly<GetValidatorsParameters> | ServiceOperationInfiniteQueryKey<GetValidatorsSchema, GetValidatorsParameters> | void
    ): QueryState<OperationInfiniteData<GetValidatorsData, GetValidatorsParameters>, GetValidatorsError> | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetValidatorsSchema, GetValidatorsData, TInfinite, GetValidatorsParameters, GetValidatorsError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetValidatorsSchema, GetValidatorsData, TInfinite, GetValidatorsParameters, GetValidatorsError>
        | QueryFiltersByQueryKey<GetValidatorsSchema, GetValidatorsData, TInfinite, GetValidatorsParameters, GetValidatorsError>
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetValidatorsSchema, GetValidatorsParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetValidatorsParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetValidatorsSchema,
        options: {
          parameters: GetValidatorsParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetValidatorsData, GetValidatorsError>>
    ): Promise<RequestFnResponse<GetValidatorsData, GetValidatorsError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetValidatorsSchema, GetValidatorsData, TInfinite, GetValidatorsParameters, GetValidatorsError>
        | QueryFiltersByQueryKey<GetValidatorsSchema, GetValidatorsData, TInfinite, GetValidatorsParameters, GetValidatorsError>,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetValidatorsSchema, GetValidatorsData, TInfinite, GetValidatorsParameters, GetValidatorsError>
        | QueryFiltersByQueryKey<GetValidatorsSchema, GetValidatorsData, TInfinite, GetValidatorsParameters, GetValidatorsError>
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetValidatorsSchema, GetValidatorsData, TInfinite, GetValidatorsParameters, GetValidatorsError>
        | QueryFiltersByQueryKey<GetValidatorsSchema, GetValidatorsData, TInfinite, GetValidatorsParameters, GetValidatorsError>,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters: (DeepReadonly<GetValidatorsParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetValidatorsSchema, GetValidatorsParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetValidatorsData, GetValidatorsParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetValidatorsData, GetValidatorsParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetValidatorsData, GetValidatorsParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetValidatorsSchema, GetValidatorsData, TInfinite, GetValidatorsParameters, GetValidatorsError>
        | QueryFiltersByQueryKey<GetValidatorsSchema, GetValidatorsData, TInfinite, GetValidatorsParameters, GetValidatorsError>,
      updater: Updater<NoInfer<GetValidatorsData> | undefined, NoInfer<GetValidatorsData> | undefined>,
      options?: SetDataOptions
    ): Array<GetValidatorsData | undefined>;
    /**/
    setQueryData(
      parameters: (DeepReadonly<GetValidatorsParameters> | undefined) | ServiceOperationQueryKey<GetValidatorsSchema, GetValidatorsParameters>,
      updater: Updater<NoInfer<GetValidatorsData> | undefined, NoInfer<DeepReadonly<GetValidatorsData>> | undefined>,
      options?: SetDataOptions
    ): GetValidatorsData | undefined;
    /**/
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetValidatorsParameters> | void
    ): ServiceOperationInfiniteQueryKey<GetValidatorsSchema, GetValidatorsParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getValidators.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetValidatorsParameters,
      TQueryFnData = GetValidatorsData,
      TData = OperationInfiniteData<TQueryFnData, GetValidatorsParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetValidatorsSchema, GetValidatorsParameters> | (DeepReadonly<GetValidatorsParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetValidatorsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetValidatorsSchema, GetValidatorsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetValidatorsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getValidators.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetValidatorsParameters,
      TQueryFnData = GetValidatorsData,
      TData = OperationInfiniteData<TQueryFnData, GetValidatorsParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetValidatorsSchema, GetValidatorsParameters> | (DeepReadonly<GetValidatorsParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetValidatorsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetValidatorsSchema, GetValidatorsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetValidatorsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetValidatorsError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getValidatorsTotal = qraft.v1Service.getValidators.useIsFetching()
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetValidatorsSchema, GetValidatorsData, TInfinite, GetValidatorsParameters, GetValidatorsError>
        | QueryFiltersByQueryKey<GetValidatorsSchema, GetValidatorsData, TInfinite, GetValidatorsParameters, GetValidatorsError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getValidatorsResults = qraft.v1Service.getValidators.useQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getValidatorsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getValidatorsCombinedResults = qraft.v1Service.getValidators.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getValidatorsCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetValidatorsSchema, GetValidatorsParameters, GetValidatorsData, GetValidatorsError>>,
      TCombinedResult = Array<UseQueryResult<GetValidatorsData, GetValidatorsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetValidatorsData, GetValidatorsError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(parameters: DeepReadonly<GetValidatorsParameters> | void): ServiceOperationQueryKey<GetValidatorsSchema, GetValidatorsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getValidators.useQuery()
     * ```
     */
    useQuery<TData = GetValidatorsData>(
      parameters: ServiceOperationQueryKey<GetValidatorsSchema, GetValidatorsParameters> | (DeepReadonly<GetValidatorsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetValidatorsData, GetValidatorsError, TData, ServiceOperationQueryKey<GetValidatorsSchema, GetValidatorsParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetValidatorsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getValidators.useQuery()
     * ```
     */
    useQuery<TData = GetValidatorsData>(
      parameters: ServiceOperationQueryKey<GetValidatorsSchema, GetValidatorsParameters> | (DeepReadonly<GetValidatorsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetValidatorsData, GetValidatorsError, TData, ServiceOperationQueryKey<GetValidatorsSchema, GetValidatorsParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetValidatorsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getValidators.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetValidatorsParameters, TData = GetValidatorsData>(
      parameters: ServiceOperationInfiniteQueryKey<GetValidatorsSchema, GetValidatorsParameters> | (DeepReadonly<GetValidatorsParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetValidatorsData,
          GetValidatorsError,
          OperationInfiniteData<TData, GetValidatorsParameters>,
          GetValidatorsData,
          ServiceOperationInfiniteQueryKey<GetValidatorsSchema, GetValidatorsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetValidatorsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetValidatorsParameters>, GetValidatorsError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getValidatorsData = qraft.v1Service.getValidators.useSuspenseQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getValidatorsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getValidatorsCombinedData = qraft.v1Service.getValidators.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getValidatorsCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetValidatorsSchema, GetValidatorsParameters, GetValidatorsData, GetValidatorsError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetValidatorsData, GetValidatorsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetValidatorsData, GetValidatorsError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getValidators.useSuspenseQuery()
     * ```
     */
    useSuspenseQuery<TData = GetValidatorsData>(
      parameters: ServiceOperationQueryKey<GetValidatorsSchema, GetValidatorsParameters> | (DeepReadonly<GetValidatorsParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<GetValidatorsData, GetValidatorsError, TData, ServiceOperationQueryKey<GetValidatorsSchema, GetValidatorsParameters>>,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetValidatorsError | Error>;
    schema: GetValidatorsSchema;
    types: {
      parameters: GetValidatorsParameters;
      data: GetValidatorsData;
      error: GetValidatorsError;
    };
  };
  getValidatorsAddress: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetValidatorsAddressSchema, GetValidatorsAddressData, TInfinite, GetValidatorsAddressParameters, GetValidatorsAddressError>
        | QueryFiltersByQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressData, TInfinite, GetValidatorsAddressParameters, GetValidatorsAddressError>,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(parameters: DeepReadonly<GetValidatorsAddressParameters>): ServiceOperationQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getValidatorsAddress.useQuery({
     *     path: {
     *         address: address
     *     }
     * })
     * ```
     */
    useQuery<TData = GetValidatorsAddressData>(
      parameters: ServiceOperationQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters> | DeepReadonly<GetValidatorsAddressParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetValidatorsAddressData,
          GetValidatorsAddressError,
          TData,
          ServiceOperationQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetValidatorsAddressError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getValidatorsAddress.useQuery({
     *     path: {
     *         address: address
     *     }
     * })
     * ```
     */
    useQuery<TData = GetValidatorsAddressData>(
      parameters: ServiceOperationQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters> | DeepReadonly<GetValidatorsAddressParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetValidatorsAddressData,
          GetValidatorsAddressError,
          TData,
          ServiceOperationQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetValidatorsAddressError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetValidatorsAddressParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetValidatorsAddressSchema,
        GetValidatorsAddressData,
        GetValidatorsAddressParameters,
        DeepReadonly<TPageParam>,
        GetValidatorsAddressError
      >
    ): Promise<OperationInfiniteData<GetValidatorsAddressData, GetValidatorsAddressParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetValidatorsAddressParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetValidatorsAddressSchema,
        GetValidatorsAddressData,
        GetValidatorsAddressParameters,
        DeepReadonly<TPageParam>,
        GetValidatorsAddressError
      >
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetValidatorsAddressParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetValidatorsAddressSchema,
        GetValidatorsAddressData,
        GetValidatorsAddressParameters,
        DeepReadonly<TPageParam>,
        GetValidatorsAddressError
      >
    ): Promise<OperationInfiniteData<GetValidatorsAddressData, GetValidatorsAddressParameters>>;
    /**/
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetValidatorsAddressSchema,
        GetValidatorsAddressData,
        GetValidatorsAddressParameters,
        GetValidatorsAddressError
      >
    ): Promise<GetValidatorsAddressData>;
    /**/
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetValidatorsAddressSchema,
        GetValidatorsAddressData,
        GetValidatorsAddressParameters,
        GetValidatorsAddressError
      >
    ): Promise<void>;
    /**/
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetValidatorsAddressSchema,
        GetValidatorsAddressData,
        GetValidatorsAddressParameters,
        GetValidatorsAddressError
      >
    ): Promise<GetValidatorsAddressData>;
    /**/
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters> | DeepReadonly<GetValidatorsAddressParameters>
    ): OperationInfiniteData<GetValidatorsAddressData, GetValidatorsAddressParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetValidatorsAddressSchema, GetValidatorsAddressData, TInfinite, GetValidatorsAddressParameters, GetValidatorsAddressError>
        | QueryFiltersByQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressData, TInfinite, GetValidatorsAddressParameters, GetValidatorsAddressError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters>,
            data: NoInfer<OperationInfiniteData<GetValidatorsAddressData, GetValidatorsAddressParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters>, data: GetValidatorsAddressData | undefined]>;
    /**/
    getQueryData(
      parameters: ServiceOperationQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters> | DeepReadonly<GetValidatorsAddressParameters>
    ): GetValidatorsAddressData | undefined;
    /**/
    getQueryState(
      parameters: ServiceOperationQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters> | DeepReadonly<GetValidatorsAddressParameters>
    ): QueryState<GetValidatorsAddressData, GetValidatorsAddressError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters: DeepReadonly<GetValidatorsAddressParameters> | ServiceOperationInfiniteQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters>
    ): QueryState<OperationInfiniteData<GetValidatorsAddressData, GetValidatorsAddressParameters>, GetValidatorsAddressError> | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<
        GetValidatorsAddressSchema,
        GetValidatorsAddressData,
        TInfinite,
        GetValidatorsAddressParameters,
        GetValidatorsAddressError
      >,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetValidatorsAddressSchema, GetValidatorsAddressData, TInfinite, GetValidatorsAddressParameters, GetValidatorsAddressError>
        | QueryFiltersByQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressData, TInfinite, GetValidatorsAddressParameters, GetValidatorsAddressError>
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetValidatorsAddressParameters, TMeta, TSignal>,
      client?: (
        schema: GetValidatorsAddressSchema,
        options: {
          parameters: GetValidatorsAddressParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetValidatorsAddressData, GetValidatorsAddressError>>
    ): Promise<RequestFnResponse<GetValidatorsAddressData, GetValidatorsAddressError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetValidatorsAddressSchema, GetValidatorsAddressData, TInfinite, GetValidatorsAddressParameters, GetValidatorsAddressError>
        | QueryFiltersByQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressData, TInfinite, GetValidatorsAddressParameters, GetValidatorsAddressError>,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetValidatorsAddressSchema, GetValidatorsAddressData, TInfinite, GetValidatorsAddressParameters, GetValidatorsAddressError>
        | QueryFiltersByQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressData, TInfinite, GetValidatorsAddressParameters, GetValidatorsAddressError>
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetValidatorsAddressSchema, GetValidatorsAddressData, TInfinite, GetValidatorsAddressParameters, GetValidatorsAddressError>
        | QueryFiltersByQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressData, TInfinite, GetValidatorsAddressParameters, GetValidatorsAddressError>,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters: DeepReadonly<GetValidatorsAddressParameters> | ServiceOperationInfiniteQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetValidatorsAddressData, GetValidatorsAddressParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetValidatorsAddressData, GetValidatorsAddressParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetValidatorsAddressData, GetValidatorsAddressParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetValidatorsAddressSchema, GetValidatorsAddressData, TInfinite, GetValidatorsAddressParameters, GetValidatorsAddressError>
        | QueryFiltersByQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressData, TInfinite, GetValidatorsAddressParameters, GetValidatorsAddressError>,
      updater: Updater<NoInfer<GetValidatorsAddressData> | undefined, NoInfer<GetValidatorsAddressData> | undefined>,
      options?: SetDataOptions
    ): Array<GetValidatorsAddressData | undefined>;
    /**/
    setQueryData(
      parameters: DeepReadonly<GetValidatorsAddressParameters> | ServiceOperationQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters>,
      updater: Updater<NoInfer<GetValidatorsAddressData> | undefined, NoInfer<DeepReadonly<GetValidatorsAddressData>> | undefined>,
      options?: SetDataOptions
    ): GetValidatorsAddressData | undefined;
    /**/
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetValidatorsAddressParameters>
    ): ServiceOperationInfiniteQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getValidatorsAddress.useInfiniteQuery({
     *     path: {
     *         address: address
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetValidatorsAddressParameters,
      TQueryFnData = GetValidatorsAddressData,
      TData = OperationInfiniteData<TQueryFnData, GetValidatorsAddressParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters> | DeepReadonly<GetValidatorsAddressParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetValidatorsAddressError,
          TData,
          ServiceOperationInfiniteQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetValidatorsAddressError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getValidatorsAddress.useInfiniteQuery({
     *     path: {
     *         address: address
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetValidatorsAddressParameters,
      TQueryFnData = GetValidatorsAddressData,
      TData = OperationInfiniteData<TQueryFnData, GetValidatorsAddressParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters> | DeepReadonly<GetValidatorsAddressParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetValidatorsAddressError,
          TData,
          ServiceOperationInfiniteQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetValidatorsAddressData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetValidatorsAddressError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getValidatorsAddressTotal = qraft.v1Service.getValidatorsAddress.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getValidatorsAddressByParametersTotal = qraft.v1Service.getValidatorsAddress.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             address: address
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetValidatorsAddressSchema, GetValidatorsAddressData, TInfinite, GetValidatorsAddressParameters, GetValidatorsAddressError>
        | QueryFiltersByQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressData, TInfinite, GetValidatorsAddressParameters, GetValidatorsAddressError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getValidatorsAddressResults = qraft.v1Service.getValidatorsAddress.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 address: address1
     *             }
     *         },
     *         {
     *             path: {
     *                 address: address2
     *             }
     *         }
     *     ]
     * });
     * getValidatorsAddressResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getValidatorsAddressCombinedResults = qraft.v1Service.getValidatorsAddress.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 address: address1
     *             }
     *         },
     *         {
     *             path: {
     *                 address: address2
     *             }
     *         }
     *     ]
     * });
     * getValidatorsAddressCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<GetValidatorsAddressSchema, GetValidatorsAddressParameters, GetValidatorsAddressData, GetValidatorsAddressError>
      >,
      TCombinedResult = Array<UseQueryResult<GetValidatorsAddressData, GetValidatorsAddressError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetValidatorsAddressData, GetValidatorsAddressError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(parameters: DeepReadonly<GetValidatorsAddressParameters>): ServiceOperationQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getValidatorsAddress.useQuery({
     *     path: {
     *         address: address
     *     }
     * })
     * ```
     */
    useQuery<TData = GetValidatorsAddressData>(
      parameters: ServiceOperationQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters> | DeepReadonly<GetValidatorsAddressParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetValidatorsAddressData,
          GetValidatorsAddressError,
          TData,
          ServiceOperationQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetValidatorsAddressError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getValidatorsAddress.useQuery({
     *     path: {
     *         address: address
     *     }
     * })
     * ```
     */
    useQuery<TData = GetValidatorsAddressData>(
      parameters: ServiceOperationQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters> | DeepReadonly<GetValidatorsAddressParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetValidatorsAddressData,
          GetValidatorsAddressError,
          TData,
          ServiceOperationQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetValidatorsAddressError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getValidatorsAddress.useSuspenseInfiniteQuery({
     *     path: {
     *         address: address
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetValidatorsAddressParameters, TData = GetValidatorsAddressData>(
      parameters: ServiceOperationInfiniteQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters> | DeepReadonly<GetValidatorsAddressParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetValidatorsAddressData,
          GetValidatorsAddressError,
          OperationInfiniteData<TData, GetValidatorsAddressParameters>,
          GetValidatorsAddressData,
          ServiceOperationInfiniteQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetValidatorsAddressData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetValidatorsAddressParameters>, GetValidatorsAddressError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getValidatorsAddressData = qraft.v1Service.getValidatorsAddress.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 address: address1
     *             }
     *         },
     *         {
     *             path: {
     *                 address: address2
     *             }
     *         }
     *     ]
     * });
     * getValidatorsAddressResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getValidatorsAddressCombinedData = qraft.v1Service.getValidatorsAddress.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 address: address1
     *             }
     *         },
     *         {
     *             path: {
     *                 address: address2
     *             }
     *         }
     *     ]
     * });
     * getValidatorsAddressCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<GetValidatorsAddressSchema, GetValidatorsAddressParameters, GetValidatorsAddressData, GetValidatorsAddressError>
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetValidatorsAddressData, GetValidatorsAddressError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetValidatorsAddressData, GetValidatorsAddressError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getValidatorsAddress.useSuspenseQuery({
     *     path: {
     *         address: address
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetValidatorsAddressData>(
      parameters: ServiceOperationQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters> | DeepReadonly<GetValidatorsAddressParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<
          GetValidatorsAddressData,
          GetValidatorsAddressError,
          TData,
          ServiceOperationQueryKey<GetValidatorsAddressSchema, GetValidatorsAddressParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetValidatorsAddressError | Error>;
    schema: GetValidatorsAddressSchema;
    types: {
      parameters: GetValidatorsAddressParameters;
      data: GetValidatorsAddressData;
      error: GetValidatorsAddressError;
    };
  };
  /** @summary Estimate the price of a deployment on akash and other cloud providers. */
  postPricing: {
    /** @summary Estimate the price of a deployment on akash and other cloud providers. */
    getMutationKey(parameters: DeepReadonly<PostPricingParameters> | void): ServiceOperationMutationKey<PostPricingSchema, PostPricingParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Estimate the price of a deployment on akash and other cloud providers.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postPricing.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postPricing.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends PostPricingBody, TContext = unknown>(
      parameters: DeepReadonly<PostPricingParameters>,
      options?: ServiceOperationUseMutationOptions<PostPricingSchema, PostPricingData, PostPricingParameters, TVariables, PostPricingError | Error, TContext>
    ): UseMutationResult<PostPricingData, PostPricingError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @summary Estimate the price of a deployment on akash and other cloud providers.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postPricing.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.postPricing.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PostPricingBody, PostPricingParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<PostPricingSchema, PostPricingData, PostPricingParameters, TVariables, PostPricingError | Error, TContext>
    ): UseMutationResult<PostPricingData, PostPricingError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @summary Estimate the price of a deployment on akash and other cloud providers.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const postPricingTotal = qraft.v1Service.postPricing.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const postPricingTotal = qraft.v1Service.postPricing.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<PostPricingBody, PostPricingData, PostPricingParameters, PostPricingError | Error, TContext>
        | MutationFiltersByMutationKey<PostPricingSchema, PostPricingBody, PostPricingData, PostPricingParameters, PostPricingError | Error, TContext>
    ): number;
    /** @summary Estimate the price of a deployment on akash and other cloud providers. */
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<PostPricingBody, PostPricingData, PostPricingParameters, PostPricingError | Error, TContext>
        | MutationFiltersByMutationKey<PostPricingSchema, PostPricingBody, PostPricingData, PostPricingParameters, PostPricingError | Error, TContext>
    ): number;
    /** @summary Estimate the price of a deployment on akash and other cloud providers. */
    (
      options: ServiceOperationMutationFnOptions<PostPricingBody, PostPricingParameters>,
      client?: (
        schema: PostPricingSchema,
        options: ServiceOperationMutationFnOptions<PostPricingBody, PostPricingParameters>
      ) => Promise<RequestFnResponse<PostPricingData, PostPricingError>>
    ): Promise<RequestFnResponse<PostPricingData, PostPricingError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @summary Estimate the price of a deployment on akash and other cloud providers.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const postPricingPendingMutationVariables = qraft.v1Service.postPricing.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const postPricingMutationData = qraft.v1Service.postPricing.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<PostPricingData, PostPricingError | Error, MutationVariables<PostPricingBody, PostPricingParameters>, TContext>
    >(options?: {
      filters?:
        | MutationFiltersByParameters<PostPricingBody, PostPricingData, PostPricingParameters, PostPricingError | Error, TContext>
        | MutationFiltersByMutationKey<PostPricingSchema, PostPricingBody, PostPricingData, PostPricingParameters, PostPricingError | Error, TContext>;
      select?: (mutation: Mutation<PostPricingData, PostPricingError | Error, MutationVariables<PostPricingBody, PostPricingParameters>, TContext>) => TResult;
    }): Array<TResult>;
    schema: PostPricingSchema;
    types: {
      parameters: PostPricingParameters;
      data: PostPricingData;
      error: PostPricingError;
      body: PostPricingBody;
    };
  };
  /** @summary Get a list of gpu models and their availability. */
  getGpu: {
    /** @summary Get a list of gpu models and their availability. */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuSchema, GetGpuData, TInfinite, GetGpuParameters, GetGpuError>
        | QueryFiltersByQueryKey<GetGpuSchema, GetGpuData, TInfinite, GetGpuParameters, GetGpuError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get a list of gpu models and their availability. */
    getQueryKey(parameters: DeepReadonly<GetGpuParameters> | void): ServiceOperationQueryKey<GetGpuSchema, GetGpuParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of gpu models and their availability.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGpu.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGpu.useQuery({
     *     query: {
     *         provider: provider
     *     }
     * })
     * ```
     */
    useQuery<TData = GetGpuData>(
      parameters: ServiceOperationQueryKey<GetGpuSchema, GetGpuParameters> | (DeepReadonly<GetGpuParameters> | void),
      options?: Omit<UndefinedInitialDataOptions<GetGpuData, GetGpuError, TData, ServiceOperationQueryKey<GetGpuSchema, GetGpuParameters>>, "queryKey">
    ): UseQueryResult<TData, GetGpuError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of gpu models and their availability.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGpu.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGpu.useQuery({
     *     query: {
     *         provider: provider
     *     }
     * })
     * ```
     */
    useQuery<TData = GetGpuData>(
      parameters: ServiceOperationQueryKey<GetGpuSchema, GetGpuParameters> | (DeepReadonly<GetGpuParameters> | void),
      options: Omit<DefinedInitialDataOptions<GetGpuData, GetGpuError, TData, ServiceOperationQueryKey<GetGpuSchema, GetGpuParameters>>, "queryKey">
    ): DefinedUseQueryResult<TData, GetGpuError | Error>;
    /** @summary Get a list of gpu models and their availability. */
    fetchInfiniteQuery<TPageParam extends GetGpuParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<GetGpuSchema, GetGpuData, GetGpuParameters, DeepReadonly<TPageParam>, GetGpuError> | void
    ): Promise<OperationInfiniteData<GetGpuData, GetGpuParameters>>;
    /** @summary Get a list of gpu models and their availability. */
    prefetchInfiniteQuery<TPageParam extends GetGpuParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<GetGpuSchema, GetGpuData, GetGpuParameters, DeepReadonly<TPageParam>, GetGpuError> | void
    ): Promise<void>;
    /** @summary Get a list of gpu models and their availability. */
    ensureInfiniteQueryData<TPageParam extends GetGpuParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<GetGpuSchema, GetGpuData, GetGpuParameters, DeepReadonly<TPageParam>, GetGpuError> | void
    ): Promise<OperationInfiniteData<GetGpuData, GetGpuParameters>>;
    /** @summary Get a list of gpu models and their availability. */
    fetchQuery(options: ServiceOperationFetchQueryOptions<GetGpuSchema, GetGpuData, GetGpuParameters, GetGpuError> | void): Promise<GetGpuData>;
    /** @summary Get a list of gpu models and their availability. */
    prefetchQuery(options: ServiceOperationFetchQueryOptions<GetGpuSchema, GetGpuData, GetGpuParameters, GetGpuError> | void): Promise<void>;
    /** @summary Get a list of gpu models and their availability. */
    ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetGpuSchema, GetGpuData, GetGpuParameters, GetGpuError> | void): Promise<GetGpuData>;
    /** @summary Get a list of gpu models and their availability. */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetGpuSchema, GetGpuParameters> | (DeepReadonly<GetGpuParameters> | void)
    ): OperationInfiniteData<GetGpuData, GetGpuParameters> | undefined;
    /** @summary Get a list of gpu models and their availability. */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuSchema, GetGpuData, TInfinite, GetGpuParameters, GetGpuError>
        | QueryFiltersByQueryKey<GetGpuSchema, GetGpuData, TInfinite, GetGpuParameters, GetGpuError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetGpuSchema, GetGpuParameters>,
            data: NoInfer<OperationInfiniteData<GetGpuData, GetGpuParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetGpuSchema, GetGpuParameters>, data: GetGpuData | undefined]>;
    /** @summary Get a list of gpu models and their availability. */
    getQueryData(parameters: ServiceOperationQueryKey<GetGpuSchema, GetGpuParameters> | (DeepReadonly<GetGpuParameters> | void)): GetGpuData | undefined;
    /** @summary Get a list of gpu models and their availability. */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetGpuSchema, GetGpuParameters> | (DeepReadonly<GetGpuParameters> | void)
    ): QueryState<GetGpuData, GetGpuError> | undefined;
    /** @summary Get a list of gpu models and their availability. */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetGpuParameters> | ServiceOperationInfiniteQueryKey<GetGpuSchema, GetGpuParameters> | void
    ): QueryState<OperationInfiniteData<GetGpuData, GetGpuParameters>, GetGpuError> | undefined;
    /** @summary Get a list of gpu models and their availability. */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetGpuSchema, GetGpuData, TInfinite, GetGpuParameters, GetGpuError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get a list of gpu models and their availability. */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuSchema, GetGpuData, TInfinite, GetGpuParameters, GetGpuError>
        | QueryFiltersByQueryKey<GetGpuSchema, GetGpuData, TInfinite, GetGpuParameters, GetGpuError>
    ): number;
    /** @summary Get a list of gpu models and their availability. */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options: QueryFnOptionsByQueryKey<GetGpuSchema, GetGpuParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetGpuParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetGpuSchema,
        options: {
          parameters: GetGpuParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetGpuData, GetGpuError>>
    ): Promise<RequestFnResponse<GetGpuData, GetGpuError>>;
    /** @summary Get a list of gpu models and their availability. */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuSchema, GetGpuData, TInfinite, GetGpuParameters, GetGpuError>
        | QueryFiltersByQueryKey<GetGpuSchema, GetGpuData, TInfinite, GetGpuParameters, GetGpuError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get a list of gpu models and their availability. */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuSchema, GetGpuData, TInfinite, GetGpuParameters, GetGpuError>
        | QueryFiltersByQueryKey<GetGpuSchema, GetGpuData, TInfinite, GetGpuParameters, GetGpuError>
    ): void;
    /** @summary Get a list of gpu models and their availability. */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuSchema, GetGpuData, TInfinite, GetGpuParameters, GetGpuError>
        | QueryFiltersByQueryKey<GetGpuSchema, GetGpuData, TInfinite, GetGpuParameters, GetGpuError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get a list of gpu models and their availability. */
    setInfiniteQueryData(
      parameters: (DeepReadonly<GetGpuParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetGpuSchema, GetGpuParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetGpuData, GetGpuParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetGpuData, GetGpuParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetGpuData, GetGpuParameters> | undefined;
    /** @summary Get a list of gpu models and their availability. */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetGpuSchema, GetGpuData, TInfinite, GetGpuParameters, GetGpuError>
        | QueryFiltersByQueryKey<GetGpuSchema, GetGpuData, TInfinite, GetGpuParameters, GetGpuError>,
      updater: Updater<NoInfer<GetGpuData> | undefined, NoInfer<GetGpuData> | undefined>,
      options?: SetDataOptions
    ): Array<GetGpuData | undefined>;
    /** @summary Get a list of gpu models and their availability. */
    setQueryData(
      parameters: (DeepReadonly<GetGpuParameters> | undefined) | ServiceOperationQueryKey<GetGpuSchema, GetGpuParameters>,
      updater: Updater<NoInfer<GetGpuData> | undefined, NoInfer<DeepReadonly<GetGpuData>> | undefined>,
      options?: SetDataOptions
    ): GetGpuData | undefined;
    /** @summary Get a list of gpu models and their availability. */
    getInfiniteQueryKey(parameters: DeepReadonly<GetGpuParameters> | void): ServiceOperationInfiniteQueryKey<GetGpuSchema, GetGpuParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of gpu models and their availability.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGpu.useInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             provider: initialProvider
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<TPageParam extends GetGpuParameters, TQueryFnData = GetGpuData, TData = OperationInfiniteData<TQueryFnData, GetGpuParameters>>(
      parameters: ServiceOperationInfiniteQueryKey<GetGpuSchema, GetGpuParameters> | (DeepReadonly<GetGpuParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetGpuError,
          TData,
          ServiceOperationInfiniteQueryKey<GetGpuSchema, GetGpuParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetGpuError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of gpu models and their availability.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGpu.useInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             provider: initialProvider
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<TPageParam extends GetGpuParameters, TQueryFnData = GetGpuData, TData = OperationInfiniteData<TQueryFnData, GetGpuParameters>>(
      parameters: ServiceOperationInfiniteQueryKey<GetGpuSchema, GetGpuParameters> | (DeepReadonly<GetGpuParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetGpuError,
          TData,
          ServiceOperationInfiniteQueryKey<GetGpuSchema, GetGpuParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetGpuData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetGpuError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get a list of gpu models and their availability.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getGpuTotal = qraft.v1Service.getGpu.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getGpuByParametersTotal = qraft.v1Service.getGpu.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         query: {
     *             provider: provider
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuSchema, GetGpuData, TInfinite, GetGpuParameters, GetGpuError>
        | QueryFiltersByQueryKey<GetGpuSchema, GetGpuData, TInfinite, GetGpuParameters, GetGpuError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get a list of gpu models and their availability.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getGpuResults = qraft.v1Service.getGpu.useQueries({
     *     queries: [
     *         {
     *             query: {
     *                 provider: provider1
     *             }
     *         },
     *         {
     *             query: {
     *                 provider: provider2
     *             }
     *         }
     *     ]
     * });
     * getGpuResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getGpuCombinedResults = qraft.v1Service.getGpu.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 provider: provider1
     *             }
     *         },
     *         {
     *             query: {
     *                 provider: provider2
     *             }
     *         }
     *     ]
     * });
     * getGpuCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetGpuSchema, GetGpuParameters, GetGpuData, GetGpuError>>,
      TCombinedResult = Array<UseQueryResult<GetGpuData, GetGpuError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetGpuData, GetGpuError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get a list of gpu models and their availability. */
    getQueryKey(parameters: DeepReadonly<GetGpuParameters> | void): ServiceOperationQueryKey<GetGpuSchema, GetGpuParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of gpu models and their availability.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGpu.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGpu.useQuery({
     *     query: {
     *         provider: provider
     *     }
     * })
     * ```
     */
    useQuery<TData = GetGpuData>(
      parameters: ServiceOperationQueryKey<GetGpuSchema, GetGpuParameters> | (DeepReadonly<GetGpuParameters> | void),
      options?: Omit<UndefinedInitialDataOptions<GetGpuData, GetGpuError, TData, ServiceOperationQueryKey<GetGpuSchema, GetGpuParameters>>, "queryKey">
    ): UseQueryResult<TData, GetGpuError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of gpu models and their availability.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGpu.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGpu.useQuery({
     *     query: {
     *         provider: provider
     *     }
     * })
     * ```
     */
    useQuery<TData = GetGpuData>(
      parameters: ServiceOperationQueryKey<GetGpuSchema, GetGpuParameters> | (DeepReadonly<GetGpuParameters> | void),
      options: Omit<DefinedInitialDataOptions<GetGpuData, GetGpuError, TData, ServiceOperationQueryKey<GetGpuSchema, GetGpuParameters>>, "queryKey">
    ): DefinedUseQueryResult<TData, GetGpuError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get a list of gpu models and their availability.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGpu.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             provider: initialProvider
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetGpuParameters, TData = GetGpuData>(
      parameters: ServiceOperationInfiniteQueryKey<GetGpuSchema, GetGpuParameters> | (DeepReadonly<GetGpuParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetGpuData,
          GetGpuError,
          OperationInfiniteData<TData, GetGpuParameters>,
          GetGpuData,
          ServiceOperationInfiniteQueryKey<GetGpuSchema, GetGpuParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetGpuData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetGpuParameters>, GetGpuError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get a list of gpu models and their availability.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getGpuData = qraft.v1Service.getGpu.useSuspenseQueries({
     *     queries: [
     *         {
     *             query: {
     *                 provider: provider1
     *             }
     *         },
     *         {
     *             query: {
     *                 provider: provider2
     *             }
     *         }
     *     ]
     * });
     * getGpuResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getGpuCombinedData = qraft.v1Service.getGpu.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 provider: provider1
     *             }
     *         },
     *         {
     *             query: {
     *                 provider: provider2
     *             }
     *         }
     *     ]
     * });
     * getGpuCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetGpuSchema, GetGpuParameters, GetGpuData, GetGpuError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetGpuData, GetGpuError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetGpuData, GetGpuError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get a list of gpu models and their availability.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getGpu.useSuspenseQuery()
     * ```
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getGpu.useSuspenseQuery({
     *     query: {
     *         provider: provider
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetGpuData>(
      parameters: ServiceOperationQueryKey<GetGpuSchema, GetGpuParameters> | (DeepReadonly<GetGpuParameters> | void),
      options?: Omit<UseSuspenseQueryOptions<GetGpuData, GetGpuError, TData, ServiceOperationQueryKey<GetGpuSchema, GetGpuParameters>>, "queryKey">
    ): UseSuspenseQueryResult<TData, GetGpuError | Error>;
    schema: GetGpuSchema;
    types: {
      parameters: GetGpuParameters;
      data: GetGpuData;
      error: GetGpuError;
    };
  };
  /** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
  getGpuModels: {
    /** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuModelsSchema, GetGpuModelsData, TInfinite, GetGpuModelsParameters, GetGpuModelsError>
        | QueryFiltersByQueryKey<GetGpuModelsSchema, GetGpuModelsData, TInfinite, GetGpuModelsParameters, GetGpuModelsError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
    getQueryKey(parameters: DeepReadonly<GetGpuModelsParameters> | void): ServiceOperationQueryKey<GetGpuModelsSchema, GetGpuModelsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGpuModels.useQuery()
     * ```
     */
    useQuery<TData = GetGpuModelsData>(
      parameters: ServiceOperationQueryKey<GetGpuModelsSchema, GetGpuModelsParameters> | (DeepReadonly<GetGpuModelsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetGpuModelsData, GetGpuModelsError, TData, ServiceOperationQueryKey<GetGpuModelsSchema, GetGpuModelsParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetGpuModelsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGpuModels.useQuery()
     * ```
     */
    useQuery<TData = GetGpuModelsData>(
      parameters: ServiceOperationQueryKey<GetGpuModelsSchema, GetGpuModelsParameters> | (DeepReadonly<GetGpuModelsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetGpuModelsData, GetGpuModelsError, TData, ServiceOperationQueryKey<GetGpuModelsSchema, GetGpuModelsParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetGpuModelsError | Error>;
    /** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
    fetchInfiniteQuery<TPageParam extends GetGpuModelsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetGpuModelsSchema,
        GetGpuModelsData,
        GetGpuModelsParameters,
        DeepReadonly<TPageParam>,
        GetGpuModelsError
      > | void
    ): Promise<OperationInfiniteData<GetGpuModelsData, GetGpuModelsParameters>>;
    /** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
    prefetchInfiniteQuery<TPageParam extends GetGpuModelsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetGpuModelsSchema,
        GetGpuModelsData,
        GetGpuModelsParameters,
        DeepReadonly<TPageParam>,
        GetGpuModelsError
      > | void
    ): Promise<void>;
    /** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
    ensureInfiniteQueryData<TPageParam extends GetGpuModelsParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetGpuModelsSchema,
        GetGpuModelsData,
        GetGpuModelsParameters,
        DeepReadonly<TPageParam>,
        GetGpuModelsError
      > | void
    ): Promise<OperationInfiniteData<GetGpuModelsData, GetGpuModelsParameters>>;
    /** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetGpuModelsSchema, GetGpuModelsData, GetGpuModelsParameters, GetGpuModelsError> | void
    ): Promise<GetGpuModelsData>;
    /** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetGpuModelsSchema, GetGpuModelsData, GetGpuModelsParameters, GetGpuModelsError> | void
    ): Promise<void>;
    /** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetGpuModelsSchema, GetGpuModelsData, GetGpuModelsParameters, GetGpuModelsError> | void
    ): Promise<GetGpuModelsData>;
    /** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetGpuModelsSchema, GetGpuModelsParameters> | (DeepReadonly<GetGpuModelsParameters> | void)
    ): OperationInfiniteData<GetGpuModelsData, GetGpuModelsParameters> | undefined;
    /** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuModelsSchema, GetGpuModelsData, TInfinite, GetGpuModelsParameters, GetGpuModelsError>
        | QueryFiltersByQueryKey<GetGpuModelsSchema, GetGpuModelsData, TInfinite, GetGpuModelsParameters, GetGpuModelsError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetGpuModelsSchema, GetGpuModelsParameters>,
            data: NoInfer<OperationInfiniteData<GetGpuModelsData, GetGpuModelsParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetGpuModelsSchema, GetGpuModelsParameters>, data: GetGpuModelsData | undefined]>;
    /** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetGpuModelsSchema, GetGpuModelsParameters> | (DeepReadonly<GetGpuModelsParameters> | void)
    ): GetGpuModelsData | undefined;
    /** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetGpuModelsSchema, GetGpuModelsParameters> | (DeepReadonly<GetGpuModelsParameters> | void)
    ): QueryState<GetGpuModelsData, GetGpuModelsError> | undefined;
    /** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetGpuModelsParameters> | ServiceOperationInfiniteQueryKey<GetGpuModelsSchema, GetGpuModelsParameters> | void
    ): QueryState<OperationInfiniteData<GetGpuModelsData, GetGpuModelsParameters>, GetGpuModelsError> | undefined;
    /** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetGpuModelsSchema, GetGpuModelsData, TInfinite, GetGpuModelsParameters, GetGpuModelsError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuModelsSchema, GetGpuModelsData, TInfinite, GetGpuModelsParameters, GetGpuModelsError>
        | QueryFiltersByQueryKey<GetGpuModelsSchema, GetGpuModelsData, TInfinite, GetGpuModelsParameters, GetGpuModelsError>
    ): number;
    /** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetGpuModelsSchema, GetGpuModelsParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetGpuModelsParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetGpuModelsSchema,
        options: {
          parameters: GetGpuModelsParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetGpuModelsData, GetGpuModelsError>>
    ): Promise<RequestFnResponse<GetGpuModelsData, GetGpuModelsError>>;
    /** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuModelsSchema, GetGpuModelsData, TInfinite, GetGpuModelsParameters, GetGpuModelsError>
        | QueryFiltersByQueryKey<GetGpuModelsSchema, GetGpuModelsData, TInfinite, GetGpuModelsParameters, GetGpuModelsError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuModelsSchema, GetGpuModelsData, TInfinite, GetGpuModelsParameters, GetGpuModelsError>
        | QueryFiltersByQueryKey<GetGpuModelsSchema, GetGpuModelsData, TInfinite, GetGpuModelsParameters, GetGpuModelsError>
    ): void;
    /** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuModelsSchema, GetGpuModelsData, TInfinite, GetGpuModelsParameters, GetGpuModelsError>
        | QueryFiltersByQueryKey<GetGpuModelsSchema, GetGpuModelsData, TInfinite, GetGpuModelsParameters, GetGpuModelsError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
    setInfiniteQueryData(
      parameters: (DeepReadonly<GetGpuModelsParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetGpuModelsSchema, GetGpuModelsParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetGpuModelsData, GetGpuModelsParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetGpuModelsData, GetGpuModelsParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetGpuModelsData, GetGpuModelsParameters> | undefined;
    /** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetGpuModelsSchema, GetGpuModelsData, TInfinite, GetGpuModelsParameters, GetGpuModelsError>
        | QueryFiltersByQueryKey<GetGpuModelsSchema, GetGpuModelsData, TInfinite, GetGpuModelsParameters, GetGpuModelsError>,
      updater: Updater<NoInfer<GetGpuModelsData> | undefined, NoInfer<GetGpuModelsData> | undefined>,
      options?: SetDataOptions
    ): Array<GetGpuModelsData | undefined>;
    /** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
    setQueryData(
      parameters: (DeepReadonly<GetGpuModelsParameters> | undefined) | ServiceOperationQueryKey<GetGpuModelsSchema, GetGpuModelsParameters>,
      updater: Updater<NoInfer<GetGpuModelsData> | undefined, NoInfer<DeepReadonly<GetGpuModelsData>> | undefined>,
      options?: SetDataOptions
    ): GetGpuModelsData | undefined;
    /** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
    getInfiniteQueryKey(parameters: DeepReadonly<GetGpuModelsParameters> | void): ServiceOperationInfiniteQueryKey<GetGpuModelsSchema, GetGpuModelsParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGpuModels.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetGpuModelsParameters,
      TQueryFnData = GetGpuModelsData,
      TData = OperationInfiniteData<TQueryFnData, GetGpuModelsParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetGpuModelsSchema, GetGpuModelsParameters> | (DeepReadonly<GetGpuModelsParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetGpuModelsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetGpuModelsSchema, GetGpuModelsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetGpuModelsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGpuModels.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetGpuModelsParameters,
      TQueryFnData = GetGpuModelsData,
      TData = OperationInfiniteData<TQueryFnData, GetGpuModelsParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetGpuModelsSchema, GetGpuModelsParameters> | (DeepReadonly<GetGpuModelsParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetGpuModelsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetGpuModelsSchema, GetGpuModelsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetGpuModelsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetGpuModelsError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getGpuModelsTotal = qraft.v1Service.getGpuModels.useIsFetching()
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuModelsSchema, GetGpuModelsData, TInfinite, GetGpuModelsParameters, GetGpuModelsError>
        | QueryFiltersByQueryKey<GetGpuModelsSchema, GetGpuModelsData, TInfinite, GetGpuModelsParameters, GetGpuModelsError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getGpuModelsResults = qraft.v1Service.getGpuModels.useQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getGpuModelsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getGpuModelsCombinedResults = qraft.v1Service.getGpuModels.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getGpuModelsCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetGpuModelsSchema, GetGpuModelsParameters, GetGpuModelsData, GetGpuModelsError>>,
      TCombinedResult = Array<UseQueryResult<GetGpuModelsData, GetGpuModelsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetGpuModelsData, GetGpuModelsError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
    getQueryKey(parameters: DeepReadonly<GetGpuModelsParameters> | void): ServiceOperationQueryKey<GetGpuModelsSchema, GetGpuModelsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGpuModels.useQuery()
     * ```
     */
    useQuery<TData = GetGpuModelsData>(
      parameters: ServiceOperationQueryKey<GetGpuModelsSchema, GetGpuModelsParameters> | (DeepReadonly<GetGpuModelsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetGpuModelsData, GetGpuModelsError, TData, ServiceOperationQueryKey<GetGpuModelsSchema, GetGpuModelsParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetGpuModelsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGpuModels.useQuery()
     * ```
     */
    useQuery<TData = GetGpuModelsData>(
      parameters: ServiceOperationQueryKey<GetGpuModelsSchema, GetGpuModelsParameters> | (DeepReadonly<GetGpuModelsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetGpuModelsData, GetGpuModelsError, TData, ServiceOperationQueryKey<GetGpuModelsSchema, GetGpuModelsParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetGpuModelsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGpuModels.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetGpuModelsParameters, TData = GetGpuModelsData>(
      parameters: ServiceOperationInfiniteQueryKey<GetGpuModelsSchema, GetGpuModelsParameters> | (DeepReadonly<GetGpuModelsParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetGpuModelsData,
          GetGpuModelsError,
          OperationInfiniteData<TData, GetGpuModelsParameters>,
          GetGpuModelsData,
          ServiceOperationInfiniteQueryKey<GetGpuModelsSchema, GetGpuModelsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetGpuModelsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetGpuModelsParameters>, GetGpuModelsError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getGpuModelsData = qraft.v1Service.getGpuModels.useSuspenseQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getGpuModelsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getGpuModelsCombinedData = qraft.v1Service.getGpuModels.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getGpuModelsCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetGpuModelsSchema, GetGpuModelsParameters, GetGpuModelsData, GetGpuModelsError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetGpuModelsData, GetGpuModelsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetGpuModelsData, GetGpuModelsError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getGpuModels.useSuspenseQuery()
     * ```
     */
    useSuspenseQuery<TData = GetGpuModelsData>(
      parameters: ServiceOperationQueryKey<GetGpuModelsSchema, GetGpuModelsParameters> | (DeepReadonly<GetGpuModelsParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<GetGpuModelsData, GetGpuModelsError, TData, ServiceOperationQueryKey<GetGpuModelsSchema, GetGpuModelsParameters>>,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetGpuModelsError | Error>;
    schema: GetGpuModelsSchema;
    types: {
      parameters: GetGpuModelsParameters;
      data: GetGpuModelsData;
      error: GetGpuModelsError;
    };
  };
  /** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
  getGpuBreakdown: {
    /** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuBreakdownSchema, GetGpuBreakdownData, TInfinite, GetGpuBreakdownParameters, GetGpuBreakdownError>
        | QueryFiltersByQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownData, TInfinite, GetGpuBreakdownParameters, GetGpuBreakdownError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
    getQueryKey(parameters: DeepReadonly<GetGpuBreakdownParameters> | void): ServiceOperationQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGpuBreakdown.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGpuBreakdown.useQuery({
     *     query: {
     *         vendor: vendor
     *     }
     * })
     * ```
     */
    useQuery<TData = GetGpuBreakdownData>(
      parameters: ServiceOperationQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters> | (DeepReadonly<GetGpuBreakdownParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetGpuBreakdownData,
          GetGpuBreakdownError,
          TData,
          ServiceOperationQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetGpuBreakdownError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGpuBreakdown.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGpuBreakdown.useQuery({
     *     query: {
     *         vendor: vendor
     *     }
     * })
     * ```
     */
    useQuery<TData = GetGpuBreakdownData>(
      parameters: ServiceOperationQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters> | (DeepReadonly<GetGpuBreakdownParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetGpuBreakdownData, GetGpuBreakdownError, TData, ServiceOperationQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetGpuBreakdownError | Error>;
    /** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
    fetchInfiniteQuery<TPageParam extends GetGpuBreakdownParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetGpuBreakdownSchema,
        GetGpuBreakdownData,
        GetGpuBreakdownParameters,
        DeepReadonly<TPageParam>,
        GetGpuBreakdownError
      > | void
    ): Promise<OperationInfiniteData<GetGpuBreakdownData, GetGpuBreakdownParameters>>;
    /** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
    prefetchInfiniteQuery<TPageParam extends GetGpuBreakdownParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetGpuBreakdownSchema,
        GetGpuBreakdownData,
        GetGpuBreakdownParameters,
        DeepReadonly<TPageParam>,
        GetGpuBreakdownError
      > | void
    ): Promise<void>;
    /** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
    ensureInfiniteQueryData<TPageParam extends GetGpuBreakdownParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetGpuBreakdownSchema,
        GetGpuBreakdownData,
        GetGpuBreakdownParameters,
        DeepReadonly<TPageParam>,
        GetGpuBreakdownError
      > | void
    ): Promise<OperationInfiniteData<GetGpuBreakdownData, GetGpuBreakdownParameters>>;
    /** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetGpuBreakdownSchema, GetGpuBreakdownData, GetGpuBreakdownParameters, GetGpuBreakdownError> | void
    ): Promise<GetGpuBreakdownData>;
    /** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetGpuBreakdownSchema, GetGpuBreakdownData, GetGpuBreakdownParameters, GetGpuBreakdownError> | void
    ): Promise<void>;
    /** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetGpuBreakdownSchema, GetGpuBreakdownData, GetGpuBreakdownParameters, GetGpuBreakdownError> | void
    ): Promise<GetGpuBreakdownData>;
    /** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters> | (DeepReadonly<GetGpuBreakdownParameters> | void)
    ): OperationInfiniteData<GetGpuBreakdownData, GetGpuBreakdownParameters> | undefined;
    /** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuBreakdownSchema, GetGpuBreakdownData, TInfinite, GetGpuBreakdownParameters, GetGpuBreakdownError>
        | QueryFiltersByQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownData, TInfinite, GetGpuBreakdownParameters, GetGpuBreakdownError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters>,
            data: NoInfer<OperationInfiniteData<GetGpuBreakdownData, GetGpuBreakdownParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters>, data: GetGpuBreakdownData | undefined]>;
    /** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters> | (DeepReadonly<GetGpuBreakdownParameters> | void)
    ): GetGpuBreakdownData | undefined;
    /** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters> | (DeepReadonly<GetGpuBreakdownParameters> | void)
    ): QueryState<GetGpuBreakdownData, GetGpuBreakdownError> | undefined;
    /** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetGpuBreakdownParameters> | ServiceOperationInfiniteQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters> | void
    ): QueryState<OperationInfiniteData<GetGpuBreakdownData, GetGpuBreakdownParameters>, GetGpuBreakdownError> | undefined;
    /** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetGpuBreakdownSchema, GetGpuBreakdownData, TInfinite, GetGpuBreakdownParameters, GetGpuBreakdownError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuBreakdownSchema, GetGpuBreakdownData, TInfinite, GetGpuBreakdownParameters, GetGpuBreakdownError>
        | QueryFiltersByQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownData, TInfinite, GetGpuBreakdownParameters, GetGpuBreakdownError>
    ): number;
    /** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetGpuBreakdownParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetGpuBreakdownSchema,
        options: {
          parameters: GetGpuBreakdownParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetGpuBreakdownData, GetGpuBreakdownError>>
    ): Promise<RequestFnResponse<GetGpuBreakdownData, GetGpuBreakdownError>>;
    /** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuBreakdownSchema, GetGpuBreakdownData, TInfinite, GetGpuBreakdownParameters, GetGpuBreakdownError>
        | QueryFiltersByQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownData, TInfinite, GetGpuBreakdownParameters, GetGpuBreakdownError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuBreakdownSchema, GetGpuBreakdownData, TInfinite, GetGpuBreakdownParameters, GetGpuBreakdownError>
        | QueryFiltersByQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownData, TInfinite, GetGpuBreakdownParameters, GetGpuBreakdownError>
    ): void;
    /** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuBreakdownSchema, GetGpuBreakdownData, TInfinite, GetGpuBreakdownParameters, GetGpuBreakdownError>
        | QueryFiltersByQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownData, TInfinite, GetGpuBreakdownParameters, GetGpuBreakdownError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
    setInfiniteQueryData(
      parameters: (DeepReadonly<GetGpuBreakdownParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetGpuBreakdownData, GetGpuBreakdownParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetGpuBreakdownData, GetGpuBreakdownParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetGpuBreakdownData, GetGpuBreakdownParameters> | undefined;
    /** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetGpuBreakdownSchema, GetGpuBreakdownData, TInfinite, GetGpuBreakdownParameters, GetGpuBreakdownError>
        | QueryFiltersByQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownData, TInfinite, GetGpuBreakdownParameters, GetGpuBreakdownError>,
      updater: Updater<NoInfer<GetGpuBreakdownData> | undefined, NoInfer<GetGpuBreakdownData> | undefined>,
      options?: SetDataOptions
    ): Array<GetGpuBreakdownData | undefined>;
    /** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
    setQueryData(
      parameters: (DeepReadonly<GetGpuBreakdownParameters> | undefined) | ServiceOperationQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters>,
      updater: Updater<NoInfer<GetGpuBreakdownData> | undefined, NoInfer<DeepReadonly<GetGpuBreakdownData>> | undefined>,
      options?: SetDataOptions
    ): GetGpuBreakdownData | undefined;
    /** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetGpuBreakdownParameters> | void
    ): ServiceOperationInfiniteQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGpuBreakdown.useInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             vendor: initialVendor
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetGpuBreakdownParameters,
      TQueryFnData = GetGpuBreakdownData,
      TData = OperationInfiniteData<TQueryFnData, GetGpuBreakdownParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters> | (DeepReadonly<GetGpuBreakdownParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetGpuBreakdownError,
          TData,
          ServiceOperationInfiniteQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetGpuBreakdownError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGpuBreakdown.useInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             vendor: initialVendor
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetGpuBreakdownParameters,
      TQueryFnData = GetGpuBreakdownData,
      TData = OperationInfiniteData<TQueryFnData, GetGpuBreakdownParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters> | (DeepReadonly<GetGpuBreakdownParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetGpuBreakdownError,
          TData,
          ServiceOperationInfiniteQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetGpuBreakdownData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetGpuBreakdownError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getGpuBreakdownTotal = qraft.v1Service.getGpuBreakdown.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getGpuBreakdownByParametersTotal = qraft.v1Service.getGpuBreakdown.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         query: {
     *             vendor: vendor
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuBreakdownSchema, GetGpuBreakdownData, TInfinite, GetGpuBreakdownParameters, GetGpuBreakdownError>
        | QueryFiltersByQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownData, TInfinite, GetGpuBreakdownParameters, GetGpuBreakdownError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getGpuBreakdownResults = qraft.v1Service.getGpuBreakdown.useQueries({
     *     queries: [
     *         {
     *             query: {
     *                 vendor: vendor1
     *             }
     *         },
     *         {
     *             query: {
     *                 vendor: vendor2
     *             }
     *         }
     *     ]
     * });
     * getGpuBreakdownResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getGpuBreakdownCombinedResults = qraft.v1Service.getGpuBreakdown.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 vendor: vendor1
     *             }
     *         },
     *         {
     *             query: {
     *                 vendor: vendor2
     *             }
     *         }
     *     ]
     * });
     * getGpuBreakdownCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetGpuBreakdownSchema, GetGpuBreakdownParameters, GetGpuBreakdownData, GetGpuBreakdownError>>,
      TCombinedResult = Array<UseQueryResult<GetGpuBreakdownData, GetGpuBreakdownError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetGpuBreakdownData, GetGpuBreakdownError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
    getQueryKey(parameters: DeepReadonly<GetGpuBreakdownParameters> | void): ServiceOperationQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGpuBreakdown.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGpuBreakdown.useQuery({
     *     query: {
     *         vendor: vendor
     *     }
     * })
     * ```
     */
    useQuery<TData = GetGpuBreakdownData>(
      parameters: ServiceOperationQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters> | (DeepReadonly<GetGpuBreakdownParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetGpuBreakdownData,
          GetGpuBreakdownError,
          TData,
          ServiceOperationQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetGpuBreakdownError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGpuBreakdown.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGpuBreakdown.useQuery({
     *     query: {
     *         vendor: vendor
     *     }
     * })
     * ```
     */
    useQuery<TData = GetGpuBreakdownData>(
      parameters: ServiceOperationQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters> | (DeepReadonly<GetGpuBreakdownParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetGpuBreakdownData, GetGpuBreakdownError, TData, ServiceOperationQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetGpuBreakdownError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGpuBreakdown.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {
     *         query: {
     *             vendor: initialVendor
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetGpuBreakdownParameters, TData = GetGpuBreakdownData>(
      parameters: ServiceOperationInfiniteQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters> | (DeepReadonly<GetGpuBreakdownParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetGpuBreakdownData,
          GetGpuBreakdownError,
          OperationInfiniteData<TData, GetGpuBreakdownParameters>,
          GetGpuBreakdownData,
          ServiceOperationInfiniteQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetGpuBreakdownData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetGpuBreakdownParameters>, GetGpuBreakdownError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getGpuBreakdownData = qraft.v1Service.getGpuBreakdown.useSuspenseQueries({
     *     queries: [
     *         {
     *             query: {
     *                 vendor: vendor1
     *             }
     *         },
     *         {
     *             query: {
     *                 vendor: vendor2
     *             }
     *         }
     *     ]
     * });
     * getGpuBreakdownResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getGpuBreakdownCombinedData = qraft.v1Service.getGpuBreakdown.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 vendor: vendor1
     *             }
     *         },
     *         {
     *             query: {
     *                 vendor: vendor2
     *             }
     *         }
     *     ]
     * });
     * getGpuBreakdownCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetGpuBreakdownSchema, GetGpuBreakdownParameters, GetGpuBreakdownData, GetGpuBreakdownError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetGpuBreakdownData, GetGpuBreakdownError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetGpuBreakdownData, GetGpuBreakdownError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getGpuBreakdown.useSuspenseQuery()
     * ```
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getGpuBreakdown.useSuspenseQuery({
     *     query: {
     *         vendor: vendor
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetGpuBreakdownData>(
      parameters: ServiceOperationQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters> | (DeepReadonly<GetGpuBreakdownParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<GetGpuBreakdownData, GetGpuBreakdownError, TData, ServiceOperationQueryKey<GetGpuBreakdownSchema, GetGpuBreakdownParameters>>,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetGpuBreakdownError | Error>;
    schema: GetGpuBreakdownSchema;
    types: {
      parameters: GetGpuBreakdownParameters;
      data: GetGpuBreakdownData;
      error: GetGpuBreakdownError;
    };
  };
  /** @summary Get a list of gpu models with their availability and pricing. */
  getGpuPrices: {
    /** @summary Get a list of gpu models with their availability and pricing. */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuPricesSchema, GetGpuPricesData, TInfinite, GetGpuPricesParameters, GetGpuPricesError>
        | QueryFiltersByQueryKey<GetGpuPricesSchema, GetGpuPricesData, TInfinite, GetGpuPricesParameters, GetGpuPricesError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get a list of gpu models with their availability and pricing. */
    getQueryKey(parameters: DeepReadonly<GetGpuPricesParameters> | void): ServiceOperationQueryKey<GetGpuPricesSchema, GetGpuPricesParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of gpu models with their availability and pricing.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGpuPrices.useQuery()
     * ```
     */
    useQuery<TData = GetGpuPricesData>(
      parameters: ServiceOperationQueryKey<GetGpuPricesSchema, GetGpuPricesParameters> | (DeepReadonly<GetGpuPricesParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetGpuPricesData, GetGpuPricesError, TData, ServiceOperationQueryKey<GetGpuPricesSchema, GetGpuPricesParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetGpuPricesError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of gpu models with their availability and pricing.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGpuPrices.useQuery()
     * ```
     */
    useQuery<TData = GetGpuPricesData>(
      parameters: ServiceOperationQueryKey<GetGpuPricesSchema, GetGpuPricesParameters> | (DeepReadonly<GetGpuPricesParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetGpuPricesData, GetGpuPricesError, TData, ServiceOperationQueryKey<GetGpuPricesSchema, GetGpuPricesParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetGpuPricesError | Error>;
    /** @summary Get a list of gpu models with their availability and pricing. */
    fetchInfiniteQuery<TPageParam extends GetGpuPricesParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetGpuPricesSchema,
        GetGpuPricesData,
        GetGpuPricesParameters,
        DeepReadonly<TPageParam>,
        GetGpuPricesError
      > | void
    ): Promise<OperationInfiniteData<GetGpuPricesData, GetGpuPricesParameters>>;
    /** @summary Get a list of gpu models with their availability and pricing. */
    prefetchInfiniteQuery<TPageParam extends GetGpuPricesParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetGpuPricesSchema,
        GetGpuPricesData,
        GetGpuPricesParameters,
        DeepReadonly<TPageParam>,
        GetGpuPricesError
      > | void
    ): Promise<void>;
    /** @summary Get a list of gpu models with their availability and pricing. */
    ensureInfiniteQueryData<TPageParam extends GetGpuPricesParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetGpuPricesSchema,
        GetGpuPricesData,
        GetGpuPricesParameters,
        DeepReadonly<TPageParam>,
        GetGpuPricesError
      > | void
    ): Promise<OperationInfiniteData<GetGpuPricesData, GetGpuPricesParameters>>;
    /** @summary Get a list of gpu models with their availability and pricing. */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetGpuPricesSchema, GetGpuPricesData, GetGpuPricesParameters, GetGpuPricesError> | void
    ): Promise<GetGpuPricesData>;
    /** @summary Get a list of gpu models with their availability and pricing. */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetGpuPricesSchema, GetGpuPricesData, GetGpuPricesParameters, GetGpuPricesError> | void
    ): Promise<void>;
    /** @summary Get a list of gpu models with their availability and pricing. */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetGpuPricesSchema, GetGpuPricesData, GetGpuPricesParameters, GetGpuPricesError> | void
    ): Promise<GetGpuPricesData>;
    /** @summary Get a list of gpu models with their availability and pricing. */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetGpuPricesSchema, GetGpuPricesParameters> | (DeepReadonly<GetGpuPricesParameters> | void)
    ): OperationInfiniteData<GetGpuPricesData, GetGpuPricesParameters> | undefined;
    /** @summary Get a list of gpu models with their availability and pricing. */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuPricesSchema, GetGpuPricesData, TInfinite, GetGpuPricesParameters, GetGpuPricesError>
        | QueryFiltersByQueryKey<GetGpuPricesSchema, GetGpuPricesData, TInfinite, GetGpuPricesParameters, GetGpuPricesError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetGpuPricesSchema, GetGpuPricesParameters>,
            data: NoInfer<OperationInfiniteData<GetGpuPricesData, GetGpuPricesParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetGpuPricesSchema, GetGpuPricesParameters>, data: GetGpuPricesData | undefined]>;
    /** @summary Get a list of gpu models with their availability and pricing. */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetGpuPricesSchema, GetGpuPricesParameters> | (DeepReadonly<GetGpuPricesParameters> | void)
    ): GetGpuPricesData | undefined;
    /** @summary Get a list of gpu models with their availability and pricing. */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetGpuPricesSchema, GetGpuPricesParameters> | (DeepReadonly<GetGpuPricesParameters> | void)
    ): QueryState<GetGpuPricesData, GetGpuPricesError> | undefined;
    /** @summary Get a list of gpu models with their availability and pricing. */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetGpuPricesParameters> | ServiceOperationInfiniteQueryKey<GetGpuPricesSchema, GetGpuPricesParameters> | void
    ): QueryState<OperationInfiniteData<GetGpuPricesData, GetGpuPricesParameters>, GetGpuPricesError> | undefined;
    /** @summary Get a list of gpu models with their availability and pricing. */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetGpuPricesSchema, GetGpuPricesData, TInfinite, GetGpuPricesParameters, GetGpuPricesError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get a list of gpu models with their availability and pricing. */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuPricesSchema, GetGpuPricesData, TInfinite, GetGpuPricesParameters, GetGpuPricesError>
        | QueryFiltersByQueryKey<GetGpuPricesSchema, GetGpuPricesData, TInfinite, GetGpuPricesParameters, GetGpuPricesError>
    ): number;
    /** @summary Get a list of gpu models with their availability and pricing. */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetGpuPricesSchema, GetGpuPricesParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetGpuPricesParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetGpuPricesSchema,
        options: {
          parameters: GetGpuPricesParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetGpuPricesData, GetGpuPricesError>>
    ): Promise<RequestFnResponse<GetGpuPricesData, GetGpuPricesError>>;
    /** @summary Get a list of gpu models with their availability and pricing. */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuPricesSchema, GetGpuPricesData, TInfinite, GetGpuPricesParameters, GetGpuPricesError>
        | QueryFiltersByQueryKey<GetGpuPricesSchema, GetGpuPricesData, TInfinite, GetGpuPricesParameters, GetGpuPricesError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get a list of gpu models with their availability and pricing. */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuPricesSchema, GetGpuPricesData, TInfinite, GetGpuPricesParameters, GetGpuPricesError>
        | QueryFiltersByQueryKey<GetGpuPricesSchema, GetGpuPricesData, TInfinite, GetGpuPricesParameters, GetGpuPricesError>
    ): void;
    /** @summary Get a list of gpu models with their availability and pricing. */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuPricesSchema, GetGpuPricesData, TInfinite, GetGpuPricesParameters, GetGpuPricesError>
        | QueryFiltersByQueryKey<GetGpuPricesSchema, GetGpuPricesData, TInfinite, GetGpuPricesParameters, GetGpuPricesError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get a list of gpu models with their availability and pricing. */
    setInfiniteQueryData(
      parameters: (DeepReadonly<GetGpuPricesParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetGpuPricesSchema, GetGpuPricesParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetGpuPricesData, GetGpuPricesParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetGpuPricesData, GetGpuPricesParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetGpuPricesData, GetGpuPricesParameters> | undefined;
    /** @summary Get a list of gpu models with their availability and pricing. */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetGpuPricesSchema, GetGpuPricesData, TInfinite, GetGpuPricesParameters, GetGpuPricesError>
        | QueryFiltersByQueryKey<GetGpuPricesSchema, GetGpuPricesData, TInfinite, GetGpuPricesParameters, GetGpuPricesError>,
      updater: Updater<NoInfer<GetGpuPricesData> | undefined, NoInfer<GetGpuPricesData> | undefined>,
      options?: SetDataOptions
    ): Array<GetGpuPricesData | undefined>;
    /** @summary Get a list of gpu models with their availability and pricing. */
    setQueryData(
      parameters: (DeepReadonly<GetGpuPricesParameters> | undefined) | ServiceOperationQueryKey<GetGpuPricesSchema, GetGpuPricesParameters>,
      updater: Updater<NoInfer<GetGpuPricesData> | undefined, NoInfer<DeepReadonly<GetGpuPricesData>> | undefined>,
      options?: SetDataOptions
    ): GetGpuPricesData | undefined;
    /** @summary Get a list of gpu models with their availability and pricing. */
    getInfiniteQueryKey(parameters: DeepReadonly<GetGpuPricesParameters> | void): ServiceOperationInfiniteQueryKey<GetGpuPricesSchema, GetGpuPricesParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of gpu models with their availability and pricing.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGpuPrices.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetGpuPricesParameters,
      TQueryFnData = GetGpuPricesData,
      TData = OperationInfiniteData<TQueryFnData, GetGpuPricesParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetGpuPricesSchema, GetGpuPricesParameters> | (DeepReadonly<GetGpuPricesParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetGpuPricesError,
          TData,
          ServiceOperationInfiniteQueryKey<GetGpuPricesSchema, GetGpuPricesParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetGpuPricesError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of gpu models with their availability and pricing.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGpuPrices.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetGpuPricesParameters,
      TQueryFnData = GetGpuPricesData,
      TData = OperationInfiniteData<TQueryFnData, GetGpuPricesParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetGpuPricesSchema, GetGpuPricesParameters> | (DeepReadonly<GetGpuPricesParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetGpuPricesError,
          TData,
          ServiceOperationInfiniteQueryKey<GetGpuPricesSchema, GetGpuPricesParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetGpuPricesData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetGpuPricesError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get a list of gpu models with their availability and pricing.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getGpuPricesTotal = qraft.v1Service.getGpuPrices.useIsFetching()
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetGpuPricesSchema, GetGpuPricesData, TInfinite, GetGpuPricesParameters, GetGpuPricesError>
        | QueryFiltersByQueryKey<GetGpuPricesSchema, GetGpuPricesData, TInfinite, GetGpuPricesParameters, GetGpuPricesError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get a list of gpu models with their availability and pricing.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getGpuPricesResults = qraft.v1Service.getGpuPrices.useQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getGpuPricesResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getGpuPricesCombinedResults = qraft.v1Service.getGpuPrices.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getGpuPricesCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetGpuPricesSchema, GetGpuPricesParameters, GetGpuPricesData, GetGpuPricesError>>,
      TCombinedResult = Array<UseQueryResult<GetGpuPricesData, GetGpuPricesError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetGpuPricesData, GetGpuPricesError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get a list of gpu models with their availability and pricing. */
    getQueryKey(parameters: DeepReadonly<GetGpuPricesParameters> | void): ServiceOperationQueryKey<GetGpuPricesSchema, GetGpuPricesParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of gpu models with their availability and pricing.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGpuPrices.useQuery()
     * ```
     */
    useQuery<TData = GetGpuPricesData>(
      parameters: ServiceOperationQueryKey<GetGpuPricesSchema, GetGpuPricesParameters> | (DeepReadonly<GetGpuPricesParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetGpuPricesData, GetGpuPricesError, TData, ServiceOperationQueryKey<GetGpuPricesSchema, GetGpuPricesParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetGpuPricesError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of gpu models with their availability and pricing.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getGpuPrices.useQuery()
     * ```
     */
    useQuery<TData = GetGpuPricesData>(
      parameters: ServiceOperationQueryKey<GetGpuPricesSchema, GetGpuPricesParameters> | (DeepReadonly<GetGpuPricesParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetGpuPricesData, GetGpuPricesError, TData, ServiceOperationQueryKey<GetGpuPricesSchema, GetGpuPricesParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetGpuPricesError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get a list of gpu models with their availability and pricing.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getGpuPrices.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetGpuPricesParameters, TData = GetGpuPricesData>(
      parameters: ServiceOperationInfiniteQueryKey<GetGpuPricesSchema, GetGpuPricesParameters> | (DeepReadonly<GetGpuPricesParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetGpuPricesData,
          GetGpuPricesError,
          OperationInfiniteData<TData, GetGpuPricesParameters>,
          GetGpuPricesData,
          ServiceOperationInfiniteQueryKey<GetGpuPricesSchema, GetGpuPricesParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetGpuPricesData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetGpuPricesParameters>, GetGpuPricesError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get a list of gpu models with their availability and pricing.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getGpuPricesData = qraft.v1Service.getGpuPrices.useSuspenseQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getGpuPricesResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getGpuPricesCombinedData = qraft.v1Service.getGpuPrices.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getGpuPricesCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetGpuPricesSchema, GetGpuPricesParameters, GetGpuPricesData, GetGpuPricesError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetGpuPricesData, GetGpuPricesError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetGpuPricesData, GetGpuPricesError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get a list of gpu models with their availability and pricing.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getGpuPrices.useSuspenseQuery()
     * ```
     */
    useSuspenseQuery<TData = GetGpuPricesData>(
      parameters: ServiceOperationQueryKey<GetGpuPricesSchema, GetGpuPricesParameters> | (DeepReadonly<GetGpuPricesParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<GetGpuPricesData, GetGpuPricesError, TData, ServiceOperationQueryKey<GetGpuPricesSchema, GetGpuPricesParameters>>,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetGpuPricesError | Error>;
    schema: GetGpuPricesSchema;
    types: {
      parameters: GetGpuPricesParameters;
      data: GetGpuPricesData;
      error: GetGpuPricesError;
    };
  };
  getProposals: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProposalsSchema, GetProposalsData, TInfinite, GetProposalsParameters, GetProposalsError>
        | QueryFiltersByQueryKey<GetProposalsSchema, GetProposalsData, TInfinite, GetProposalsParameters, GetProposalsError>,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(parameters: DeepReadonly<GetProposalsParameters> | void): ServiceOperationQueryKey<GetProposalsSchema, GetProposalsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProposals.useQuery()
     * ```
     */
    useQuery<TData = GetProposalsData>(
      parameters: ServiceOperationQueryKey<GetProposalsSchema, GetProposalsParameters> | (DeepReadonly<GetProposalsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetProposalsData, GetProposalsError, TData, ServiceOperationQueryKey<GetProposalsSchema, GetProposalsParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetProposalsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProposals.useQuery()
     * ```
     */
    useQuery<TData = GetProposalsData>(
      parameters: ServiceOperationQueryKey<GetProposalsSchema, GetProposalsParameters> | (DeepReadonly<GetProposalsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetProposalsData, GetProposalsError, TData, ServiceOperationQueryKey<GetProposalsSchema, GetProposalsParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetProposalsError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetProposalsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetProposalsSchema,
        GetProposalsData,
        GetProposalsParameters,
        DeepReadonly<TPageParam>,
        GetProposalsError
      > | void
    ): Promise<OperationInfiniteData<GetProposalsData, GetProposalsParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetProposalsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetProposalsSchema,
        GetProposalsData,
        GetProposalsParameters,
        DeepReadonly<TPageParam>,
        GetProposalsError
      > | void
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetProposalsParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetProposalsSchema,
        GetProposalsData,
        GetProposalsParameters,
        DeepReadonly<TPageParam>,
        GetProposalsError
      > | void
    ): Promise<OperationInfiniteData<GetProposalsData, GetProposalsParameters>>;
    /**/
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetProposalsSchema, GetProposalsData, GetProposalsParameters, GetProposalsError> | void
    ): Promise<GetProposalsData>;
    /**/
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetProposalsSchema, GetProposalsData, GetProposalsParameters, GetProposalsError> | void
    ): Promise<void>;
    /**/
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetProposalsSchema, GetProposalsData, GetProposalsParameters, GetProposalsError> | void
    ): Promise<GetProposalsData>;
    /**/
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetProposalsSchema, GetProposalsParameters> | (DeepReadonly<GetProposalsParameters> | void)
    ): OperationInfiniteData<GetProposalsData, GetProposalsParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProposalsSchema, GetProposalsData, TInfinite, GetProposalsParameters, GetProposalsError>
        | QueryFiltersByQueryKey<GetProposalsSchema, GetProposalsData, TInfinite, GetProposalsParameters, GetProposalsError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetProposalsSchema, GetProposalsParameters>,
            data: NoInfer<OperationInfiniteData<GetProposalsData, GetProposalsParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetProposalsSchema, GetProposalsParameters>, data: GetProposalsData | undefined]>;
    /**/
    getQueryData(
      parameters: ServiceOperationQueryKey<GetProposalsSchema, GetProposalsParameters> | (DeepReadonly<GetProposalsParameters> | void)
    ): GetProposalsData | undefined;
    /**/
    getQueryState(
      parameters: ServiceOperationQueryKey<GetProposalsSchema, GetProposalsParameters> | (DeepReadonly<GetProposalsParameters> | void)
    ): QueryState<GetProposalsData, GetProposalsError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters: DeepReadonly<GetProposalsParameters> | ServiceOperationInfiniteQueryKey<GetProposalsSchema, GetProposalsParameters> | void
    ): QueryState<OperationInfiniteData<GetProposalsData, GetProposalsParameters>, GetProposalsError> | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetProposalsSchema, GetProposalsData, TInfinite, GetProposalsParameters, GetProposalsError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProposalsSchema, GetProposalsData, TInfinite, GetProposalsParameters, GetProposalsError>
        | QueryFiltersByQueryKey<GetProposalsSchema, GetProposalsData, TInfinite, GetProposalsParameters, GetProposalsError>
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetProposalsSchema, GetProposalsParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetProposalsParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetProposalsSchema,
        options: {
          parameters: GetProposalsParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetProposalsData, GetProposalsError>>
    ): Promise<RequestFnResponse<GetProposalsData, GetProposalsError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProposalsSchema, GetProposalsData, TInfinite, GetProposalsParameters, GetProposalsError>
        | QueryFiltersByQueryKey<GetProposalsSchema, GetProposalsData, TInfinite, GetProposalsParameters, GetProposalsError>,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProposalsSchema, GetProposalsData, TInfinite, GetProposalsParameters, GetProposalsError>
        | QueryFiltersByQueryKey<GetProposalsSchema, GetProposalsData, TInfinite, GetProposalsParameters, GetProposalsError>
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProposalsSchema, GetProposalsData, TInfinite, GetProposalsParameters, GetProposalsError>
        | QueryFiltersByQueryKey<GetProposalsSchema, GetProposalsData, TInfinite, GetProposalsParameters, GetProposalsError>,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters: (DeepReadonly<GetProposalsParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetProposalsSchema, GetProposalsParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetProposalsData, GetProposalsParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetProposalsData, GetProposalsParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetProposalsData, GetProposalsParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetProposalsSchema, GetProposalsData, TInfinite, GetProposalsParameters, GetProposalsError>
        | QueryFiltersByQueryKey<GetProposalsSchema, GetProposalsData, TInfinite, GetProposalsParameters, GetProposalsError>,
      updater: Updater<NoInfer<GetProposalsData> | undefined, NoInfer<GetProposalsData> | undefined>,
      options?: SetDataOptions
    ): Array<GetProposalsData | undefined>;
    /**/
    setQueryData(
      parameters: (DeepReadonly<GetProposalsParameters> | undefined) | ServiceOperationQueryKey<GetProposalsSchema, GetProposalsParameters>,
      updater: Updater<NoInfer<GetProposalsData> | undefined, NoInfer<DeepReadonly<GetProposalsData>> | undefined>,
      options?: SetDataOptions
    ): GetProposalsData | undefined;
    /**/
    getInfiniteQueryKey(parameters: DeepReadonly<GetProposalsParameters> | void): ServiceOperationInfiniteQueryKey<GetProposalsSchema, GetProposalsParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProposals.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetProposalsParameters,
      TQueryFnData = GetProposalsData,
      TData = OperationInfiniteData<TQueryFnData, GetProposalsParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetProposalsSchema, GetProposalsParameters> | (DeepReadonly<GetProposalsParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetProposalsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetProposalsSchema, GetProposalsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetProposalsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProposals.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetProposalsParameters,
      TQueryFnData = GetProposalsData,
      TData = OperationInfiniteData<TQueryFnData, GetProposalsParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetProposalsSchema, GetProposalsParameters> | (DeepReadonly<GetProposalsParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetProposalsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetProposalsSchema, GetProposalsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetProposalsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetProposalsError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getProposalsTotal = qraft.v1Service.getProposals.useIsFetching()
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProposalsSchema, GetProposalsData, TInfinite, GetProposalsParameters, GetProposalsError>
        | QueryFiltersByQueryKey<GetProposalsSchema, GetProposalsData, TInfinite, GetProposalsParameters, GetProposalsError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getProposalsResults = qraft.v1Service.getProposals.useQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getProposalsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getProposalsCombinedResults = qraft.v1Service.getProposals.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getProposalsCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetProposalsSchema, GetProposalsParameters, GetProposalsData, GetProposalsError>>,
      TCombinedResult = Array<UseQueryResult<GetProposalsData, GetProposalsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetProposalsData, GetProposalsError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(parameters: DeepReadonly<GetProposalsParameters> | void): ServiceOperationQueryKey<GetProposalsSchema, GetProposalsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProposals.useQuery()
     * ```
     */
    useQuery<TData = GetProposalsData>(
      parameters: ServiceOperationQueryKey<GetProposalsSchema, GetProposalsParameters> | (DeepReadonly<GetProposalsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetProposalsData, GetProposalsError, TData, ServiceOperationQueryKey<GetProposalsSchema, GetProposalsParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetProposalsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProposals.useQuery()
     * ```
     */
    useQuery<TData = GetProposalsData>(
      parameters: ServiceOperationQueryKey<GetProposalsSchema, GetProposalsParameters> | (DeepReadonly<GetProposalsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetProposalsData, GetProposalsError, TData, ServiceOperationQueryKey<GetProposalsSchema, GetProposalsParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetProposalsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProposals.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetProposalsParameters, TData = GetProposalsData>(
      parameters: ServiceOperationInfiniteQueryKey<GetProposalsSchema, GetProposalsParameters> | (DeepReadonly<GetProposalsParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetProposalsData,
          GetProposalsError,
          OperationInfiniteData<TData, GetProposalsParameters>,
          GetProposalsData,
          ServiceOperationInfiniteQueryKey<GetProposalsSchema, GetProposalsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetProposalsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetProposalsParameters>, GetProposalsError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getProposalsData = qraft.v1Service.getProposals.useSuspenseQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getProposalsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getProposalsCombinedData = qraft.v1Service.getProposals.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getProposalsCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetProposalsSchema, GetProposalsParameters, GetProposalsData, GetProposalsError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetProposalsData, GetProposalsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetProposalsData, GetProposalsError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getProposals.useSuspenseQuery()
     * ```
     */
    useSuspenseQuery<TData = GetProposalsData>(
      parameters: ServiceOperationQueryKey<GetProposalsSchema, GetProposalsParameters> | (DeepReadonly<GetProposalsParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<GetProposalsData, GetProposalsError, TData, ServiceOperationQueryKey<GetProposalsSchema, GetProposalsParameters>>,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetProposalsError | Error>;
    schema: GetProposalsSchema;
    types: {
      parameters: GetProposalsParameters;
      data: GetProposalsData;
      error: GetProposalsError;
    };
  };
  getProposalsId: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProposalsIdSchema, GetProposalsIdData, TInfinite, GetProposalsIdParameters, GetProposalsIdError>
        | QueryFiltersByQueryKey<GetProposalsIdSchema, GetProposalsIdData, TInfinite, GetProposalsIdParameters, GetProposalsIdError>,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(parameters: DeepReadonly<GetProposalsIdParameters> | void): ServiceOperationQueryKey<GetProposalsIdSchema, GetProposalsIdParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProposalsId.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProposalsId.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProposalsIdData>(
      parameters: ServiceOperationQueryKey<GetProposalsIdSchema, GetProposalsIdParameters> | (DeepReadonly<GetProposalsIdParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetProposalsIdData, GetProposalsIdError, TData, ServiceOperationQueryKey<GetProposalsIdSchema, GetProposalsIdParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetProposalsIdError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProposalsId.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProposalsId.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProposalsIdData>(
      parameters: ServiceOperationQueryKey<GetProposalsIdSchema, GetProposalsIdParameters> | (DeepReadonly<GetProposalsIdParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetProposalsIdData, GetProposalsIdError, TData, ServiceOperationQueryKey<GetProposalsIdSchema, GetProposalsIdParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetProposalsIdError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetProposalsIdParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetProposalsIdSchema,
        GetProposalsIdData,
        GetProposalsIdParameters,
        DeepReadonly<TPageParam>,
        GetProposalsIdError
      > | void
    ): Promise<OperationInfiniteData<GetProposalsIdData, GetProposalsIdParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetProposalsIdParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetProposalsIdSchema,
        GetProposalsIdData,
        GetProposalsIdParameters,
        DeepReadonly<TPageParam>,
        GetProposalsIdError
      > | void
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetProposalsIdParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetProposalsIdSchema,
        GetProposalsIdData,
        GetProposalsIdParameters,
        DeepReadonly<TPageParam>,
        GetProposalsIdError
      > | void
    ): Promise<OperationInfiniteData<GetProposalsIdData, GetProposalsIdParameters>>;
    /**/
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetProposalsIdSchema, GetProposalsIdData, GetProposalsIdParameters, GetProposalsIdError> | void
    ): Promise<GetProposalsIdData>;
    /**/
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetProposalsIdSchema, GetProposalsIdData, GetProposalsIdParameters, GetProposalsIdError> | void
    ): Promise<void>;
    /**/
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetProposalsIdSchema, GetProposalsIdData, GetProposalsIdParameters, GetProposalsIdError> | void
    ): Promise<GetProposalsIdData>;
    /**/
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetProposalsIdSchema, GetProposalsIdParameters> | (DeepReadonly<GetProposalsIdParameters> | void)
    ): OperationInfiniteData<GetProposalsIdData, GetProposalsIdParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProposalsIdSchema, GetProposalsIdData, TInfinite, GetProposalsIdParameters, GetProposalsIdError>
        | QueryFiltersByQueryKey<GetProposalsIdSchema, GetProposalsIdData, TInfinite, GetProposalsIdParameters, GetProposalsIdError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetProposalsIdSchema, GetProposalsIdParameters>,
            data: NoInfer<OperationInfiniteData<GetProposalsIdData, GetProposalsIdParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetProposalsIdSchema, GetProposalsIdParameters>, data: GetProposalsIdData | undefined]>;
    /**/
    getQueryData(
      parameters: ServiceOperationQueryKey<GetProposalsIdSchema, GetProposalsIdParameters> | (DeepReadonly<GetProposalsIdParameters> | void)
    ): GetProposalsIdData | undefined;
    /**/
    getQueryState(
      parameters: ServiceOperationQueryKey<GetProposalsIdSchema, GetProposalsIdParameters> | (DeepReadonly<GetProposalsIdParameters> | void)
    ): QueryState<GetProposalsIdData, GetProposalsIdError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters: DeepReadonly<GetProposalsIdParameters> | ServiceOperationInfiniteQueryKey<GetProposalsIdSchema, GetProposalsIdParameters> | void
    ): QueryState<OperationInfiniteData<GetProposalsIdData, GetProposalsIdParameters>, GetProposalsIdError> | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetProposalsIdSchema, GetProposalsIdData, TInfinite, GetProposalsIdParameters, GetProposalsIdError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProposalsIdSchema, GetProposalsIdData, TInfinite, GetProposalsIdParameters, GetProposalsIdError>
        | QueryFiltersByQueryKey<GetProposalsIdSchema, GetProposalsIdData, TInfinite, GetProposalsIdParameters, GetProposalsIdError>
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetProposalsIdSchema, GetProposalsIdParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetProposalsIdParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetProposalsIdSchema,
        options: {
          parameters: GetProposalsIdParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetProposalsIdData, GetProposalsIdError>>
    ): Promise<RequestFnResponse<GetProposalsIdData, GetProposalsIdError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProposalsIdSchema, GetProposalsIdData, TInfinite, GetProposalsIdParameters, GetProposalsIdError>
        | QueryFiltersByQueryKey<GetProposalsIdSchema, GetProposalsIdData, TInfinite, GetProposalsIdParameters, GetProposalsIdError>,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProposalsIdSchema, GetProposalsIdData, TInfinite, GetProposalsIdParameters, GetProposalsIdError>
        | QueryFiltersByQueryKey<GetProposalsIdSchema, GetProposalsIdData, TInfinite, GetProposalsIdParameters, GetProposalsIdError>
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProposalsIdSchema, GetProposalsIdData, TInfinite, GetProposalsIdParameters, GetProposalsIdError>
        | QueryFiltersByQueryKey<GetProposalsIdSchema, GetProposalsIdData, TInfinite, GetProposalsIdParameters, GetProposalsIdError>,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters: (DeepReadonly<GetProposalsIdParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetProposalsIdSchema, GetProposalsIdParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetProposalsIdData, GetProposalsIdParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetProposalsIdData, GetProposalsIdParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetProposalsIdData, GetProposalsIdParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetProposalsIdSchema, GetProposalsIdData, TInfinite, GetProposalsIdParameters, GetProposalsIdError>
        | QueryFiltersByQueryKey<GetProposalsIdSchema, GetProposalsIdData, TInfinite, GetProposalsIdParameters, GetProposalsIdError>,
      updater: Updater<NoInfer<GetProposalsIdData> | undefined, NoInfer<GetProposalsIdData> | undefined>,
      options?: SetDataOptions
    ): Array<GetProposalsIdData | undefined>;
    /**/
    setQueryData(
      parameters: (DeepReadonly<GetProposalsIdParameters> | undefined) | ServiceOperationQueryKey<GetProposalsIdSchema, GetProposalsIdParameters>,
      updater: Updater<NoInfer<GetProposalsIdData> | undefined, NoInfer<DeepReadonly<GetProposalsIdData>> | undefined>,
      options?: SetDataOptions
    ): GetProposalsIdData | undefined;
    /**/
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetProposalsIdParameters> | void
    ): ServiceOperationInfiniteQueryKey<GetProposalsIdSchema, GetProposalsIdParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProposalsId.useInfiniteQuery({
     *     path: {
     *         id: id
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetProposalsIdParameters,
      TQueryFnData = GetProposalsIdData,
      TData = OperationInfiniteData<TQueryFnData, GetProposalsIdParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetProposalsIdSchema, GetProposalsIdParameters> | (DeepReadonly<GetProposalsIdParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetProposalsIdError,
          TData,
          ServiceOperationInfiniteQueryKey<GetProposalsIdSchema, GetProposalsIdParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetProposalsIdError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProposalsId.useInfiniteQuery({
     *     path: {
     *         id: id
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetProposalsIdParameters,
      TQueryFnData = GetProposalsIdData,
      TData = OperationInfiniteData<TQueryFnData, GetProposalsIdParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetProposalsIdSchema, GetProposalsIdParameters> | (DeepReadonly<GetProposalsIdParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetProposalsIdError,
          TData,
          ServiceOperationInfiniteQueryKey<GetProposalsIdSchema, GetProposalsIdParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetProposalsIdData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetProposalsIdError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getProposalsIdTotal = qraft.v1Service.getProposalsId.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getProposalsIdByParametersTotal = qraft.v1Service.getProposalsId.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             id: id
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetProposalsIdSchema, GetProposalsIdData, TInfinite, GetProposalsIdParameters, GetProposalsIdError>
        | QueryFiltersByQueryKey<GetProposalsIdSchema, GetProposalsIdData, TInfinite, GetProposalsIdParameters, GetProposalsIdError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getProposalsIdResults = qraft.v1Service.getProposalsId.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getProposalsIdResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getProposalsIdCombinedResults = qraft.v1Service.getProposalsId.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getProposalsIdCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetProposalsIdSchema, GetProposalsIdParameters, GetProposalsIdData, GetProposalsIdError>>,
      TCombinedResult = Array<UseQueryResult<GetProposalsIdData, GetProposalsIdError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetProposalsIdData, GetProposalsIdError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(parameters: DeepReadonly<GetProposalsIdParameters> | void): ServiceOperationQueryKey<GetProposalsIdSchema, GetProposalsIdParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProposalsId.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProposalsId.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProposalsIdData>(
      parameters: ServiceOperationQueryKey<GetProposalsIdSchema, GetProposalsIdParameters> | (DeepReadonly<GetProposalsIdParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetProposalsIdData, GetProposalsIdError, TData, ServiceOperationQueryKey<GetProposalsIdSchema, GetProposalsIdParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetProposalsIdError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProposalsId.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getProposalsId.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetProposalsIdData>(
      parameters: ServiceOperationQueryKey<GetProposalsIdSchema, GetProposalsIdParameters> | (DeepReadonly<GetProposalsIdParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetProposalsIdData, GetProposalsIdError, TData, ServiceOperationQueryKey<GetProposalsIdSchema, GetProposalsIdParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetProposalsIdError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getProposalsId.useSuspenseInfiniteQuery({
     *     path: {
     *         id: id
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetProposalsIdParameters, TData = GetProposalsIdData>(
      parameters: ServiceOperationInfiniteQueryKey<GetProposalsIdSchema, GetProposalsIdParameters> | (DeepReadonly<GetProposalsIdParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetProposalsIdData,
          GetProposalsIdError,
          OperationInfiniteData<TData, GetProposalsIdParameters>,
          GetProposalsIdData,
          ServiceOperationInfiniteQueryKey<GetProposalsIdSchema, GetProposalsIdParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetProposalsIdData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetProposalsIdParameters>, GetProposalsIdError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getProposalsIdData = qraft.v1Service.getProposalsId.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getProposalsIdResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getProposalsIdCombinedData = qraft.v1Service.getProposalsId.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getProposalsIdCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetProposalsIdSchema, GetProposalsIdParameters, GetProposalsIdData, GetProposalsIdError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetProposalsIdData, GetProposalsIdError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetProposalsIdData, GetProposalsIdError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getProposalsId.useSuspenseQuery()
     * ```
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getProposalsId.useSuspenseQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetProposalsIdData>(
      parameters: ServiceOperationQueryKey<GetProposalsIdSchema, GetProposalsIdParameters> | (DeepReadonly<GetProposalsIdParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<GetProposalsIdData, GetProposalsIdError, TData, ServiceOperationQueryKey<GetProposalsIdSchema, GetProposalsIdParameters>>,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetProposalsIdError | Error>;
    schema: GetProposalsIdSchema;
    types: {
      parameters: GetProposalsIdParameters;
      data: GetProposalsIdData;
      error: GetProposalsIdError;
    };
  };
  getTemplates: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTemplatesSchema, GetTemplatesData, TInfinite, GetTemplatesParameters, GetTemplatesError>
        | QueryFiltersByQueryKey<GetTemplatesSchema, GetTemplatesData, TInfinite, GetTemplatesParameters, GetTemplatesError>,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(parameters: DeepReadonly<GetTemplatesParameters> | void): ServiceOperationQueryKey<GetTemplatesSchema, GetTemplatesParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getTemplates.useQuery()
     * ```
     */
    useQuery<TData = GetTemplatesData>(
      parameters: ServiceOperationQueryKey<GetTemplatesSchema, GetTemplatesParameters> | (DeepReadonly<GetTemplatesParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetTemplatesData, GetTemplatesError, TData, ServiceOperationQueryKey<GetTemplatesSchema, GetTemplatesParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetTemplatesError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getTemplates.useQuery()
     * ```
     */
    useQuery<TData = GetTemplatesData>(
      parameters: ServiceOperationQueryKey<GetTemplatesSchema, GetTemplatesParameters> | (DeepReadonly<GetTemplatesParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetTemplatesData, GetTemplatesError, TData, ServiceOperationQueryKey<GetTemplatesSchema, GetTemplatesParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetTemplatesError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetTemplatesParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetTemplatesSchema,
        GetTemplatesData,
        GetTemplatesParameters,
        DeepReadonly<TPageParam>,
        GetTemplatesError
      > | void
    ): Promise<OperationInfiniteData<GetTemplatesData, GetTemplatesParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetTemplatesParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetTemplatesSchema,
        GetTemplatesData,
        GetTemplatesParameters,
        DeepReadonly<TPageParam>,
        GetTemplatesError
      > | void
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetTemplatesParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetTemplatesSchema,
        GetTemplatesData,
        GetTemplatesParameters,
        DeepReadonly<TPageParam>,
        GetTemplatesError
      > | void
    ): Promise<OperationInfiniteData<GetTemplatesData, GetTemplatesParameters>>;
    /**/
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetTemplatesSchema, GetTemplatesData, GetTemplatesParameters, GetTemplatesError> | void
    ): Promise<GetTemplatesData>;
    /**/
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetTemplatesSchema, GetTemplatesData, GetTemplatesParameters, GetTemplatesError> | void
    ): Promise<void>;
    /**/
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetTemplatesSchema, GetTemplatesData, GetTemplatesParameters, GetTemplatesError> | void
    ): Promise<GetTemplatesData>;
    /**/
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetTemplatesSchema, GetTemplatesParameters> | (DeepReadonly<GetTemplatesParameters> | void)
    ): OperationInfiniteData<GetTemplatesData, GetTemplatesParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTemplatesSchema, GetTemplatesData, TInfinite, GetTemplatesParameters, GetTemplatesError>
        | QueryFiltersByQueryKey<GetTemplatesSchema, GetTemplatesData, TInfinite, GetTemplatesParameters, GetTemplatesError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetTemplatesSchema, GetTemplatesParameters>,
            data: NoInfer<OperationInfiniteData<GetTemplatesData, GetTemplatesParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetTemplatesSchema, GetTemplatesParameters>, data: GetTemplatesData | undefined]>;
    /**/
    getQueryData(
      parameters: ServiceOperationQueryKey<GetTemplatesSchema, GetTemplatesParameters> | (DeepReadonly<GetTemplatesParameters> | void)
    ): GetTemplatesData | undefined;
    /**/
    getQueryState(
      parameters: ServiceOperationQueryKey<GetTemplatesSchema, GetTemplatesParameters> | (DeepReadonly<GetTemplatesParameters> | void)
    ): QueryState<GetTemplatesData, GetTemplatesError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters: DeepReadonly<GetTemplatesParameters> | ServiceOperationInfiniteQueryKey<GetTemplatesSchema, GetTemplatesParameters> | void
    ): QueryState<OperationInfiniteData<GetTemplatesData, GetTemplatesParameters>, GetTemplatesError> | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetTemplatesSchema, GetTemplatesData, TInfinite, GetTemplatesParameters, GetTemplatesError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTemplatesSchema, GetTemplatesData, TInfinite, GetTemplatesParameters, GetTemplatesError>
        | QueryFiltersByQueryKey<GetTemplatesSchema, GetTemplatesData, TInfinite, GetTemplatesParameters, GetTemplatesError>
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetTemplatesSchema, GetTemplatesParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetTemplatesParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetTemplatesSchema,
        options: {
          parameters: GetTemplatesParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetTemplatesData, GetTemplatesError>>
    ): Promise<RequestFnResponse<GetTemplatesData, GetTemplatesError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTemplatesSchema, GetTemplatesData, TInfinite, GetTemplatesParameters, GetTemplatesError>
        | QueryFiltersByQueryKey<GetTemplatesSchema, GetTemplatesData, TInfinite, GetTemplatesParameters, GetTemplatesError>,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTemplatesSchema, GetTemplatesData, TInfinite, GetTemplatesParameters, GetTemplatesError>
        | QueryFiltersByQueryKey<GetTemplatesSchema, GetTemplatesData, TInfinite, GetTemplatesParameters, GetTemplatesError>
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTemplatesSchema, GetTemplatesData, TInfinite, GetTemplatesParameters, GetTemplatesError>
        | QueryFiltersByQueryKey<GetTemplatesSchema, GetTemplatesData, TInfinite, GetTemplatesParameters, GetTemplatesError>,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters: (DeepReadonly<GetTemplatesParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetTemplatesSchema, GetTemplatesParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetTemplatesData, GetTemplatesParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetTemplatesData, GetTemplatesParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetTemplatesData, GetTemplatesParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetTemplatesSchema, GetTemplatesData, TInfinite, GetTemplatesParameters, GetTemplatesError>
        | QueryFiltersByQueryKey<GetTemplatesSchema, GetTemplatesData, TInfinite, GetTemplatesParameters, GetTemplatesError>,
      updater: Updater<NoInfer<GetTemplatesData> | undefined, NoInfer<GetTemplatesData> | undefined>,
      options?: SetDataOptions
    ): Array<GetTemplatesData | undefined>;
    /**/
    setQueryData(
      parameters: (DeepReadonly<GetTemplatesParameters> | undefined) | ServiceOperationQueryKey<GetTemplatesSchema, GetTemplatesParameters>,
      updater: Updater<NoInfer<GetTemplatesData> | undefined, NoInfer<DeepReadonly<GetTemplatesData>> | undefined>,
      options?: SetDataOptions
    ): GetTemplatesData | undefined;
    /**/
    getInfiniteQueryKey(parameters: DeepReadonly<GetTemplatesParameters> | void): ServiceOperationInfiniteQueryKey<GetTemplatesSchema, GetTemplatesParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getTemplates.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetTemplatesParameters,
      TQueryFnData = GetTemplatesData,
      TData = OperationInfiniteData<TQueryFnData, GetTemplatesParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetTemplatesSchema, GetTemplatesParameters> | (DeepReadonly<GetTemplatesParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetTemplatesError,
          TData,
          ServiceOperationInfiniteQueryKey<GetTemplatesSchema, GetTemplatesParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetTemplatesError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getTemplates.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetTemplatesParameters,
      TQueryFnData = GetTemplatesData,
      TData = OperationInfiniteData<TQueryFnData, GetTemplatesParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetTemplatesSchema, GetTemplatesParameters> | (DeepReadonly<GetTemplatesParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetTemplatesError,
          TData,
          ServiceOperationInfiniteQueryKey<GetTemplatesSchema, GetTemplatesParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetTemplatesData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetTemplatesError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getTemplatesTotal = qraft.v1Service.getTemplates.useIsFetching()
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTemplatesSchema, GetTemplatesData, TInfinite, GetTemplatesParameters, GetTemplatesError>
        | QueryFiltersByQueryKey<GetTemplatesSchema, GetTemplatesData, TInfinite, GetTemplatesParameters, GetTemplatesError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getTemplatesResults = qraft.v1Service.getTemplates.useQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getTemplatesResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getTemplatesCombinedResults = qraft.v1Service.getTemplates.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getTemplatesCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetTemplatesSchema, GetTemplatesParameters, GetTemplatesData, GetTemplatesError>>,
      TCombinedResult = Array<UseQueryResult<GetTemplatesData, GetTemplatesError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetTemplatesData, GetTemplatesError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(parameters: DeepReadonly<GetTemplatesParameters> | void): ServiceOperationQueryKey<GetTemplatesSchema, GetTemplatesParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getTemplates.useQuery()
     * ```
     */
    useQuery<TData = GetTemplatesData>(
      parameters: ServiceOperationQueryKey<GetTemplatesSchema, GetTemplatesParameters> | (DeepReadonly<GetTemplatesParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetTemplatesData, GetTemplatesError, TData, ServiceOperationQueryKey<GetTemplatesSchema, GetTemplatesParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetTemplatesError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getTemplates.useQuery()
     * ```
     */
    useQuery<TData = GetTemplatesData>(
      parameters: ServiceOperationQueryKey<GetTemplatesSchema, GetTemplatesParameters> | (DeepReadonly<GetTemplatesParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<GetTemplatesData, GetTemplatesError, TData, ServiceOperationQueryKey<GetTemplatesSchema, GetTemplatesParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetTemplatesError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getTemplates.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetTemplatesParameters, TData = GetTemplatesData>(
      parameters: ServiceOperationInfiniteQueryKey<GetTemplatesSchema, GetTemplatesParameters> | (DeepReadonly<GetTemplatesParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetTemplatesData,
          GetTemplatesError,
          OperationInfiniteData<TData, GetTemplatesParameters>,
          GetTemplatesData,
          ServiceOperationInfiniteQueryKey<GetTemplatesSchema, GetTemplatesParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetTemplatesData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetTemplatesParameters>, GetTemplatesError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getTemplatesData = qraft.v1Service.getTemplates.useSuspenseQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getTemplatesResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getTemplatesCombinedData = qraft.v1Service.getTemplates.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getTemplatesCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetTemplatesSchema, GetTemplatesParameters, GetTemplatesData, GetTemplatesError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetTemplatesData, GetTemplatesError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetTemplatesData, GetTemplatesError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getTemplates.useSuspenseQuery()
     * ```
     */
    useSuspenseQuery<TData = GetTemplatesData>(
      parameters: ServiceOperationQueryKey<GetTemplatesSchema, GetTemplatesParameters> | (DeepReadonly<GetTemplatesParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<GetTemplatesData, GetTemplatesError, TData, ServiceOperationQueryKey<GetTemplatesSchema, GetTemplatesParameters>>,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetTemplatesError | Error>;
    schema: GetTemplatesSchema;
    types: {
      parameters: GetTemplatesParameters;
      data: GetTemplatesData;
      error: GetTemplatesError;
    };
  };
  getTemplatesList: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTemplatesListSchema, GetTemplatesListData, TInfinite, GetTemplatesListParameters, GetTemplatesListError>
        | QueryFiltersByQueryKey<GetTemplatesListSchema, GetTemplatesListData, TInfinite, GetTemplatesListParameters, GetTemplatesListError>,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(parameters: DeepReadonly<GetTemplatesListParameters> | void): ServiceOperationQueryKey<GetTemplatesListSchema, GetTemplatesListParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getTemplatesList.useQuery()
     * ```
     */
    useQuery<TData = GetTemplatesListData>(
      parameters: ServiceOperationQueryKey<GetTemplatesListSchema, GetTemplatesListParameters> | (DeepReadonly<GetTemplatesListParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetTemplatesListData,
          GetTemplatesListError,
          TData,
          ServiceOperationQueryKey<GetTemplatesListSchema, GetTemplatesListParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetTemplatesListError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getTemplatesList.useQuery()
     * ```
     */
    useQuery<TData = GetTemplatesListData>(
      parameters: ServiceOperationQueryKey<GetTemplatesListSchema, GetTemplatesListParameters> | (DeepReadonly<GetTemplatesListParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetTemplatesListData,
          GetTemplatesListError,
          TData,
          ServiceOperationQueryKey<GetTemplatesListSchema, GetTemplatesListParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetTemplatesListError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetTemplatesListParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetTemplatesListSchema,
        GetTemplatesListData,
        GetTemplatesListParameters,
        DeepReadonly<TPageParam>,
        GetTemplatesListError
      > | void
    ): Promise<OperationInfiniteData<GetTemplatesListData, GetTemplatesListParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetTemplatesListParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetTemplatesListSchema,
        GetTemplatesListData,
        GetTemplatesListParameters,
        DeepReadonly<TPageParam>,
        GetTemplatesListError
      > | void
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetTemplatesListParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetTemplatesListSchema,
        GetTemplatesListData,
        GetTemplatesListParameters,
        DeepReadonly<TPageParam>,
        GetTemplatesListError
      > | void
    ): Promise<OperationInfiniteData<GetTemplatesListData, GetTemplatesListParameters>>;
    /**/
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetTemplatesListSchema, GetTemplatesListData, GetTemplatesListParameters, GetTemplatesListError> | void
    ): Promise<GetTemplatesListData>;
    /**/
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetTemplatesListSchema, GetTemplatesListData, GetTemplatesListParameters, GetTemplatesListError> | void
    ): Promise<void>;
    /**/
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetTemplatesListSchema, GetTemplatesListData, GetTemplatesListParameters, GetTemplatesListError> | void
    ): Promise<GetTemplatesListData>;
    /**/
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetTemplatesListSchema, GetTemplatesListParameters> | (DeepReadonly<GetTemplatesListParameters> | void)
    ): OperationInfiniteData<GetTemplatesListData, GetTemplatesListParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTemplatesListSchema, GetTemplatesListData, TInfinite, GetTemplatesListParameters, GetTemplatesListError>
        | QueryFiltersByQueryKey<GetTemplatesListSchema, GetTemplatesListData, TInfinite, GetTemplatesListParameters, GetTemplatesListError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetTemplatesListSchema, GetTemplatesListParameters>,
            data: NoInfer<OperationInfiniteData<GetTemplatesListData, GetTemplatesListParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetTemplatesListSchema, GetTemplatesListParameters>, data: GetTemplatesListData | undefined]>;
    /**/
    getQueryData(
      parameters: ServiceOperationQueryKey<GetTemplatesListSchema, GetTemplatesListParameters> | (DeepReadonly<GetTemplatesListParameters> | void)
    ): GetTemplatesListData | undefined;
    /**/
    getQueryState(
      parameters: ServiceOperationQueryKey<GetTemplatesListSchema, GetTemplatesListParameters> | (DeepReadonly<GetTemplatesListParameters> | void)
    ): QueryState<GetTemplatesListData, GetTemplatesListError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters: DeepReadonly<GetTemplatesListParameters> | ServiceOperationInfiniteQueryKey<GetTemplatesListSchema, GetTemplatesListParameters> | void
    ): QueryState<OperationInfiniteData<GetTemplatesListData, GetTemplatesListParameters>, GetTemplatesListError> | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetTemplatesListSchema, GetTemplatesListData, TInfinite, GetTemplatesListParameters, GetTemplatesListError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTemplatesListSchema, GetTemplatesListData, TInfinite, GetTemplatesListParameters, GetTemplatesListError>
        | QueryFiltersByQueryKey<GetTemplatesListSchema, GetTemplatesListData, TInfinite, GetTemplatesListParameters, GetTemplatesListError>
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetTemplatesListSchema, GetTemplatesListParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetTemplatesListParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetTemplatesListSchema,
        options: {
          parameters: GetTemplatesListParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetTemplatesListData, GetTemplatesListError>>
    ): Promise<RequestFnResponse<GetTemplatesListData, GetTemplatesListError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTemplatesListSchema, GetTemplatesListData, TInfinite, GetTemplatesListParameters, GetTemplatesListError>
        | QueryFiltersByQueryKey<GetTemplatesListSchema, GetTemplatesListData, TInfinite, GetTemplatesListParameters, GetTemplatesListError>,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTemplatesListSchema, GetTemplatesListData, TInfinite, GetTemplatesListParameters, GetTemplatesListError>
        | QueryFiltersByQueryKey<GetTemplatesListSchema, GetTemplatesListData, TInfinite, GetTemplatesListParameters, GetTemplatesListError>
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTemplatesListSchema, GetTemplatesListData, TInfinite, GetTemplatesListParameters, GetTemplatesListError>
        | QueryFiltersByQueryKey<GetTemplatesListSchema, GetTemplatesListData, TInfinite, GetTemplatesListParameters, GetTemplatesListError>,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters: (DeepReadonly<GetTemplatesListParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetTemplatesListSchema, GetTemplatesListParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetTemplatesListData, GetTemplatesListParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetTemplatesListData, GetTemplatesListParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetTemplatesListData, GetTemplatesListParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetTemplatesListSchema, GetTemplatesListData, TInfinite, GetTemplatesListParameters, GetTemplatesListError>
        | QueryFiltersByQueryKey<GetTemplatesListSchema, GetTemplatesListData, TInfinite, GetTemplatesListParameters, GetTemplatesListError>,
      updater: Updater<NoInfer<GetTemplatesListData> | undefined, NoInfer<GetTemplatesListData> | undefined>,
      options?: SetDataOptions
    ): Array<GetTemplatesListData | undefined>;
    /**/
    setQueryData(
      parameters: (DeepReadonly<GetTemplatesListParameters> | undefined) | ServiceOperationQueryKey<GetTemplatesListSchema, GetTemplatesListParameters>,
      updater: Updater<NoInfer<GetTemplatesListData> | undefined, NoInfer<DeepReadonly<GetTemplatesListData>> | undefined>,
      options?: SetDataOptions
    ): GetTemplatesListData | undefined;
    /**/
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetTemplatesListParameters> | void
    ): ServiceOperationInfiniteQueryKey<GetTemplatesListSchema, GetTemplatesListParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getTemplatesList.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetTemplatesListParameters,
      TQueryFnData = GetTemplatesListData,
      TData = OperationInfiniteData<TQueryFnData, GetTemplatesListParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetTemplatesListSchema, GetTemplatesListParameters> | (DeepReadonly<GetTemplatesListParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetTemplatesListError,
          TData,
          ServiceOperationInfiniteQueryKey<GetTemplatesListSchema, GetTemplatesListParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetTemplatesListError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getTemplatesList.useInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetTemplatesListParameters,
      TQueryFnData = GetTemplatesListData,
      TData = OperationInfiniteData<TQueryFnData, GetTemplatesListParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetTemplatesListSchema, GetTemplatesListParameters> | (DeepReadonly<GetTemplatesListParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetTemplatesListError,
          TData,
          ServiceOperationInfiniteQueryKey<GetTemplatesListSchema, GetTemplatesListParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetTemplatesListData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetTemplatesListError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getTemplatesListTotal = qraft.v1Service.getTemplatesList.useIsFetching()
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTemplatesListSchema, GetTemplatesListData, TInfinite, GetTemplatesListParameters, GetTemplatesListError>
        | QueryFiltersByQueryKey<GetTemplatesListSchema, GetTemplatesListData, TInfinite, GetTemplatesListParameters, GetTemplatesListError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getTemplatesListResults = qraft.v1Service.getTemplatesList.useQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getTemplatesListResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getTemplatesListCombinedResults = qraft.v1Service.getTemplatesList.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getTemplatesListCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetTemplatesListSchema, GetTemplatesListParameters, GetTemplatesListData, GetTemplatesListError>>,
      TCombinedResult = Array<UseQueryResult<GetTemplatesListData, GetTemplatesListError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetTemplatesListData, GetTemplatesListError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(parameters: DeepReadonly<GetTemplatesListParameters> | void): ServiceOperationQueryKey<GetTemplatesListSchema, GetTemplatesListParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getTemplatesList.useQuery()
     * ```
     */
    useQuery<TData = GetTemplatesListData>(
      parameters: ServiceOperationQueryKey<GetTemplatesListSchema, GetTemplatesListParameters> | (DeepReadonly<GetTemplatesListParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetTemplatesListData,
          GetTemplatesListError,
          TData,
          ServiceOperationQueryKey<GetTemplatesListSchema, GetTemplatesListParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetTemplatesListError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getTemplatesList.useQuery()
     * ```
     */
    useQuery<TData = GetTemplatesListData>(
      parameters: ServiceOperationQueryKey<GetTemplatesListSchema, GetTemplatesListParameters> | (DeepReadonly<GetTemplatesListParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetTemplatesListData,
          GetTemplatesListError,
          TData,
          ServiceOperationQueryKey<GetTemplatesListSchema, GetTemplatesListParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetTemplatesListError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getTemplatesList.useSuspenseInfiniteQuery({}, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetTemplatesListParameters, TData = GetTemplatesListData>(
      parameters: ServiceOperationInfiniteQueryKey<GetTemplatesListSchema, GetTemplatesListParameters> | (DeepReadonly<GetTemplatesListParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetTemplatesListData,
          GetTemplatesListError,
          OperationInfiniteData<TData, GetTemplatesListParameters>,
          GetTemplatesListData,
          ServiceOperationInfiniteQueryKey<GetTemplatesListSchema, GetTemplatesListParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetTemplatesListData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetTemplatesListParameters>, GetTemplatesListError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getTemplatesListData = qraft.v1Service.getTemplatesList.useSuspenseQueries({
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getTemplatesListResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getTemplatesListCombinedData = qraft.v1Service.getTemplatesList.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {},
     *         {}
     *     ]
     * });
     * getTemplatesListCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetTemplatesListSchema, GetTemplatesListParameters, GetTemplatesListData, GetTemplatesListError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetTemplatesListData, GetTemplatesListError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetTemplatesListData, GetTemplatesListError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getTemplatesList.useSuspenseQuery()
     * ```
     */
    useSuspenseQuery<TData = GetTemplatesListData>(
      parameters: ServiceOperationQueryKey<GetTemplatesListSchema, GetTemplatesListParameters> | (DeepReadonly<GetTemplatesListParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<
          GetTemplatesListData,
          GetTemplatesListError,
          TData,
          ServiceOperationQueryKey<GetTemplatesListSchema, GetTemplatesListParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetTemplatesListError | Error>;
    schema: GetTemplatesListSchema;
    types: {
      parameters: GetTemplatesListParameters;
      data: GetTemplatesListData;
      error: GetTemplatesListError;
    };
  };
  getTemplatesId: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTemplatesIdSchema, GetTemplatesIdData, TInfinite, GetTemplatesIdParameters, GetTemplatesIdError>
        | QueryFiltersByQueryKey<GetTemplatesIdSchema, GetTemplatesIdData, TInfinite, GetTemplatesIdParameters, GetTemplatesIdError>,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(parameters: DeepReadonly<GetTemplatesIdParameters>): ServiceOperationQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getTemplatesId.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetTemplatesIdData>(
      parameters: ServiceOperationQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters> | DeepReadonly<GetTemplatesIdParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<GetTemplatesIdData, GetTemplatesIdError, TData, ServiceOperationQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetTemplatesIdError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getTemplatesId.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetTemplatesIdData>(
      parameters: ServiceOperationQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters> | DeepReadonly<GetTemplatesIdParameters>,
      options: Omit<
        DefinedInitialDataOptions<GetTemplatesIdData, GetTemplatesIdError, TData, ServiceOperationQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetTemplatesIdError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetTemplatesIdParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetTemplatesIdSchema,
        GetTemplatesIdData,
        GetTemplatesIdParameters,
        DeepReadonly<TPageParam>,
        GetTemplatesIdError
      >
    ): Promise<OperationInfiniteData<GetTemplatesIdData, GetTemplatesIdParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetTemplatesIdParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetTemplatesIdSchema,
        GetTemplatesIdData,
        GetTemplatesIdParameters,
        DeepReadonly<TPageParam>,
        GetTemplatesIdError
      >
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetTemplatesIdParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetTemplatesIdSchema,
        GetTemplatesIdData,
        GetTemplatesIdParameters,
        DeepReadonly<TPageParam>,
        GetTemplatesIdError
      >
    ): Promise<OperationInfiniteData<GetTemplatesIdData, GetTemplatesIdParameters>>;
    /**/
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetTemplatesIdSchema, GetTemplatesIdData, GetTemplatesIdParameters, GetTemplatesIdError>
    ): Promise<GetTemplatesIdData>;
    /**/
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetTemplatesIdSchema, GetTemplatesIdData, GetTemplatesIdParameters, GetTemplatesIdError>
    ): Promise<void>;
    /**/
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetTemplatesIdSchema, GetTemplatesIdData, GetTemplatesIdParameters, GetTemplatesIdError>
    ): Promise<GetTemplatesIdData>;
    /**/
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters> | DeepReadonly<GetTemplatesIdParameters>
    ): OperationInfiniteData<GetTemplatesIdData, GetTemplatesIdParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTemplatesIdSchema, GetTemplatesIdData, TInfinite, GetTemplatesIdParameters, GetTemplatesIdError>
        | QueryFiltersByQueryKey<GetTemplatesIdSchema, GetTemplatesIdData, TInfinite, GetTemplatesIdParameters, GetTemplatesIdError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters>,
            data: NoInfer<OperationInfiniteData<GetTemplatesIdData, GetTemplatesIdParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters>, data: GetTemplatesIdData | undefined]>;
    /**/
    getQueryData(
      parameters: ServiceOperationQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters> | DeepReadonly<GetTemplatesIdParameters>
    ): GetTemplatesIdData | undefined;
    /**/
    getQueryState(
      parameters: ServiceOperationQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters> | DeepReadonly<GetTemplatesIdParameters>
    ): QueryState<GetTemplatesIdData, GetTemplatesIdError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters: DeepReadonly<GetTemplatesIdParameters> | ServiceOperationInfiniteQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters>
    ): QueryState<OperationInfiniteData<GetTemplatesIdData, GetTemplatesIdParameters>, GetTemplatesIdError> | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetTemplatesIdSchema, GetTemplatesIdData, TInfinite, GetTemplatesIdParameters, GetTemplatesIdError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTemplatesIdSchema, GetTemplatesIdData, TInfinite, GetTemplatesIdParameters, GetTemplatesIdError>
        | QueryFiltersByQueryKey<GetTemplatesIdSchema, GetTemplatesIdData, TInfinite, GetTemplatesIdParameters, GetTemplatesIdError>
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetTemplatesIdParameters, TMeta, TSignal>,
      client?: (
        schema: GetTemplatesIdSchema,
        options: {
          parameters: GetTemplatesIdParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetTemplatesIdData, GetTemplatesIdError>>
    ): Promise<RequestFnResponse<GetTemplatesIdData, GetTemplatesIdError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTemplatesIdSchema, GetTemplatesIdData, TInfinite, GetTemplatesIdParameters, GetTemplatesIdError>
        | QueryFiltersByQueryKey<GetTemplatesIdSchema, GetTemplatesIdData, TInfinite, GetTemplatesIdParameters, GetTemplatesIdError>,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTemplatesIdSchema, GetTemplatesIdData, TInfinite, GetTemplatesIdParameters, GetTemplatesIdError>
        | QueryFiltersByQueryKey<GetTemplatesIdSchema, GetTemplatesIdData, TInfinite, GetTemplatesIdParameters, GetTemplatesIdError>
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTemplatesIdSchema, GetTemplatesIdData, TInfinite, GetTemplatesIdParameters, GetTemplatesIdError>
        | QueryFiltersByQueryKey<GetTemplatesIdSchema, GetTemplatesIdData, TInfinite, GetTemplatesIdParameters, GetTemplatesIdError>,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters: DeepReadonly<GetTemplatesIdParameters> | ServiceOperationInfiniteQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetTemplatesIdData, GetTemplatesIdParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetTemplatesIdData, GetTemplatesIdParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetTemplatesIdData, GetTemplatesIdParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetTemplatesIdSchema, GetTemplatesIdData, TInfinite, GetTemplatesIdParameters, GetTemplatesIdError>
        | QueryFiltersByQueryKey<GetTemplatesIdSchema, GetTemplatesIdData, TInfinite, GetTemplatesIdParameters, GetTemplatesIdError>,
      updater: Updater<NoInfer<GetTemplatesIdData> | undefined, NoInfer<GetTemplatesIdData> | undefined>,
      options?: SetDataOptions
    ): Array<GetTemplatesIdData | undefined>;
    /**/
    setQueryData(
      parameters: DeepReadonly<GetTemplatesIdParameters> | ServiceOperationQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters>,
      updater: Updater<NoInfer<GetTemplatesIdData> | undefined, NoInfer<DeepReadonly<GetTemplatesIdData>> | undefined>,
      options?: SetDataOptions
    ): GetTemplatesIdData | undefined;
    /**/
    getInfiniteQueryKey(parameters: DeepReadonly<GetTemplatesIdParameters>): ServiceOperationInfiniteQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getTemplatesId.useInfiniteQuery({
     *     path: {
     *         id: id
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetTemplatesIdParameters,
      TQueryFnData = GetTemplatesIdData,
      TData = OperationInfiniteData<TQueryFnData, GetTemplatesIdParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters> | DeepReadonly<GetTemplatesIdParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetTemplatesIdError,
          TData,
          ServiceOperationInfiniteQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetTemplatesIdError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getTemplatesId.useInfiniteQuery({
     *     path: {
     *         id: id
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetTemplatesIdParameters,
      TQueryFnData = GetTemplatesIdData,
      TData = OperationInfiniteData<TQueryFnData, GetTemplatesIdParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters> | DeepReadonly<GetTemplatesIdParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetTemplatesIdError,
          TData,
          ServiceOperationInfiniteQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetTemplatesIdData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetTemplatesIdError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getTemplatesIdTotal = qraft.v1Service.getTemplatesId.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getTemplatesIdByParametersTotal = qraft.v1Service.getTemplatesId.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             id: id
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetTemplatesIdSchema, GetTemplatesIdData, TInfinite, GetTemplatesIdParameters, GetTemplatesIdError>
        | QueryFiltersByQueryKey<GetTemplatesIdSchema, GetTemplatesIdData, TInfinite, GetTemplatesIdParameters, GetTemplatesIdError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getTemplatesIdResults = qraft.v1Service.getTemplatesId.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getTemplatesIdResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getTemplatesIdCombinedResults = qraft.v1Service.getTemplatesId.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getTemplatesIdCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetTemplatesIdSchema, GetTemplatesIdParameters, GetTemplatesIdData, GetTemplatesIdError>>,
      TCombinedResult = Array<UseQueryResult<GetTemplatesIdData, GetTemplatesIdError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetTemplatesIdData, GetTemplatesIdError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(parameters: DeepReadonly<GetTemplatesIdParameters>): ServiceOperationQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getTemplatesId.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetTemplatesIdData>(
      parameters: ServiceOperationQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters> | DeepReadonly<GetTemplatesIdParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<GetTemplatesIdData, GetTemplatesIdError, TData, ServiceOperationQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetTemplatesIdError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getTemplatesId.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetTemplatesIdData>(
      parameters: ServiceOperationQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters> | DeepReadonly<GetTemplatesIdParameters>,
      options: Omit<
        DefinedInitialDataOptions<GetTemplatesIdData, GetTemplatesIdError, TData, ServiceOperationQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetTemplatesIdError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getTemplatesId.useSuspenseInfiniteQuery({
     *     path: {
     *         id: id
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetTemplatesIdParameters, TData = GetTemplatesIdData>(
      parameters: ServiceOperationInfiniteQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters> | DeepReadonly<GetTemplatesIdParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetTemplatesIdData,
          GetTemplatesIdError,
          OperationInfiniteData<TData, GetTemplatesIdParameters>,
          GetTemplatesIdData,
          ServiceOperationInfiniteQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetTemplatesIdData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetTemplatesIdParameters>, GetTemplatesIdError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getTemplatesIdData = qraft.v1Service.getTemplatesId.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getTemplatesIdResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getTemplatesIdCombinedData = qraft.v1Service.getTemplatesId.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getTemplatesIdCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetTemplatesIdSchema, GetTemplatesIdParameters, GetTemplatesIdData, GetTemplatesIdError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetTemplatesIdData, GetTemplatesIdError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetTemplatesIdData, GetTemplatesIdError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getTemplatesId.useSuspenseQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetTemplatesIdData>(
      parameters: ServiceOperationQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters> | DeepReadonly<GetTemplatesIdParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<GetTemplatesIdData, GetTemplatesIdError, TData, ServiceOperationQueryKey<GetTemplatesIdSchema, GetTemplatesIdParameters>>,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetTemplatesIdError | Error>;
    schema: GetTemplatesIdSchema;
    types: {
      parameters: GetTemplatesIdParameters;
      data: GetTemplatesIdData;
      error: GetTemplatesIdError;
    };
  };
  /** @summary Get leases durations. */
  getLeasesDurationOwner: {
    /** @summary Get leases durations. */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetLeasesDurationOwnerSchema,
            GetLeasesDurationOwnerData,
            TInfinite,
            GetLeasesDurationOwnerParameters,
            GetLeasesDurationOwnerError
          >
        | QueryFiltersByQueryKey<
            GetLeasesDurationOwnerSchema,
            GetLeasesDurationOwnerData,
            TInfinite,
            GetLeasesDurationOwnerParameters,
            GetLeasesDurationOwnerError
          >,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get leases durations. */
    getQueryKey(
      parameters: DeepReadonly<GetLeasesDurationOwnerParameters>
    ): ServiceOperationQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get leases durations.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getLeasesDurationOwner.useQuery({
     *     path: {
     *         owner: owner
     *     },
     *     query: {
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useQuery<TData = GetLeasesDurationOwnerData>(
      parameters: ServiceOperationQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters> | DeepReadonly<GetLeasesDurationOwnerParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetLeasesDurationOwnerData,
          GetLeasesDurationOwnerError,
          TData,
          ServiceOperationQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetLeasesDurationOwnerError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get leases durations.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getLeasesDurationOwner.useQuery({
     *     path: {
     *         owner: owner
     *     },
     *     query: {
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useQuery<TData = GetLeasesDurationOwnerData>(
      parameters: ServiceOperationQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters> | DeepReadonly<GetLeasesDurationOwnerParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetLeasesDurationOwnerData,
          GetLeasesDurationOwnerError,
          TData,
          ServiceOperationQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetLeasesDurationOwnerError | Error>;
    /** @summary Get leases durations. */
    fetchInfiniteQuery<TPageParam extends GetLeasesDurationOwnerParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetLeasesDurationOwnerSchema,
        GetLeasesDurationOwnerData,
        GetLeasesDurationOwnerParameters,
        DeepReadonly<TPageParam>,
        GetLeasesDurationOwnerError
      >
    ): Promise<OperationInfiniteData<GetLeasesDurationOwnerData, GetLeasesDurationOwnerParameters>>;
    /** @summary Get leases durations. */
    prefetchInfiniteQuery<TPageParam extends GetLeasesDurationOwnerParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetLeasesDurationOwnerSchema,
        GetLeasesDurationOwnerData,
        GetLeasesDurationOwnerParameters,
        DeepReadonly<TPageParam>,
        GetLeasesDurationOwnerError
      >
    ): Promise<void>;
    /** @summary Get leases durations. */
    ensureInfiniteQueryData<TPageParam extends GetLeasesDurationOwnerParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetLeasesDurationOwnerSchema,
        GetLeasesDurationOwnerData,
        GetLeasesDurationOwnerParameters,
        DeepReadonly<TPageParam>,
        GetLeasesDurationOwnerError
      >
    ): Promise<OperationInfiniteData<GetLeasesDurationOwnerData, GetLeasesDurationOwnerParameters>>;
    /** @summary Get leases durations. */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetLeasesDurationOwnerSchema,
        GetLeasesDurationOwnerData,
        GetLeasesDurationOwnerParameters,
        GetLeasesDurationOwnerError
      >
    ): Promise<GetLeasesDurationOwnerData>;
    /** @summary Get leases durations. */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetLeasesDurationOwnerSchema,
        GetLeasesDurationOwnerData,
        GetLeasesDurationOwnerParameters,
        GetLeasesDurationOwnerError
      >
    ): Promise<void>;
    /** @summary Get leases durations. */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetLeasesDurationOwnerSchema,
        GetLeasesDurationOwnerData,
        GetLeasesDurationOwnerParameters,
        GetLeasesDurationOwnerError
      >
    ): Promise<GetLeasesDurationOwnerData>;
    /** @summary Get leases durations. */
    getInfiniteQueryData(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters>
        | DeepReadonly<GetLeasesDurationOwnerParameters>
    ): OperationInfiniteData<GetLeasesDurationOwnerData, GetLeasesDurationOwnerParameters> | undefined;
    /** @summary Get leases durations. */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetLeasesDurationOwnerSchema,
            GetLeasesDurationOwnerData,
            TInfinite,
            GetLeasesDurationOwnerParameters,
            GetLeasesDurationOwnerError
          >
        | QueryFiltersByQueryKey<
            GetLeasesDurationOwnerSchema,
            GetLeasesDurationOwnerData,
            TInfinite,
            GetLeasesDurationOwnerParameters,
            GetLeasesDurationOwnerError
          >
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters>,
            data: NoInfer<OperationInfiniteData<GetLeasesDurationOwnerData, GetLeasesDurationOwnerParameters>> | undefined
          ]
        >
      : Array<
          [queryKey: ServiceOperationQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters>, data: GetLeasesDurationOwnerData | undefined]
        >;
    /** @summary Get leases durations. */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters> | DeepReadonly<GetLeasesDurationOwnerParameters>
    ): GetLeasesDurationOwnerData | undefined;
    /** @summary Get leases durations. */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters> | DeepReadonly<GetLeasesDurationOwnerParameters>
    ): QueryState<GetLeasesDurationOwnerData, GetLeasesDurationOwnerError> | undefined;
    /** @summary Get leases durations. */
    getInfiniteQueryState(
      parameters:
        | DeepReadonly<GetLeasesDurationOwnerParameters>
        | ServiceOperationInfiniteQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters>
    ): QueryState<OperationInfiniteData<GetLeasesDurationOwnerData, GetLeasesDurationOwnerParameters>, GetLeasesDurationOwnerError> | undefined;
    /** @summary Get leases durations. */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<
        GetLeasesDurationOwnerSchema,
        GetLeasesDurationOwnerData,
        TInfinite,
        GetLeasesDurationOwnerParameters,
        GetLeasesDurationOwnerError
      >,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get leases durations. */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetLeasesDurationOwnerSchema,
            GetLeasesDurationOwnerData,
            TInfinite,
            GetLeasesDurationOwnerParameters,
            GetLeasesDurationOwnerError
          >
        | QueryFiltersByQueryKey<
            GetLeasesDurationOwnerSchema,
            GetLeasesDurationOwnerData,
            TInfinite,
            GetLeasesDurationOwnerParameters,
            GetLeasesDurationOwnerError
          >
    ): number;
    /** @summary Get leases durations. */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetLeasesDurationOwnerParameters, TMeta, TSignal>,
      client?: (
        schema: GetLeasesDurationOwnerSchema,
        options: {
          parameters: GetLeasesDurationOwnerParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetLeasesDurationOwnerData, GetLeasesDurationOwnerError>>
    ): Promise<RequestFnResponse<GetLeasesDurationOwnerData, GetLeasesDurationOwnerError>>;
    /** @summary Get leases durations. */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetLeasesDurationOwnerSchema,
            GetLeasesDurationOwnerData,
            TInfinite,
            GetLeasesDurationOwnerParameters,
            GetLeasesDurationOwnerError
          >
        | QueryFiltersByQueryKey<
            GetLeasesDurationOwnerSchema,
            GetLeasesDurationOwnerData,
            TInfinite,
            GetLeasesDurationOwnerParameters,
            GetLeasesDurationOwnerError
          >,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get leases durations. */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetLeasesDurationOwnerSchema,
            GetLeasesDurationOwnerData,
            TInfinite,
            GetLeasesDurationOwnerParameters,
            GetLeasesDurationOwnerError
          >
        | QueryFiltersByQueryKey<
            GetLeasesDurationOwnerSchema,
            GetLeasesDurationOwnerData,
            TInfinite,
            GetLeasesDurationOwnerParameters,
            GetLeasesDurationOwnerError
          >
    ): void;
    /** @summary Get leases durations. */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetLeasesDurationOwnerSchema,
            GetLeasesDurationOwnerData,
            TInfinite,
            GetLeasesDurationOwnerParameters,
            GetLeasesDurationOwnerError
          >
        | QueryFiltersByQueryKey<
            GetLeasesDurationOwnerSchema,
            GetLeasesDurationOwnerData,
            TInfinite,
            GetLeasesDurationOwnerParameters,
            GetLeasesDurationOwnerError
          >,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get leases durations. */
    setInfiniteQueryData(
      parameters:
        | DeepReadonly<GetLeasesDurationOwnerParameters>
        | ServiceOperationInfiniteQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetLeasesDurationOwnerData, GetLeasesDurationOwnerParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetLeasesDurationOwnerData, GetLeasesDurationOwnerParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetLeasesDurationOwnerData, GetLeasesDurationOwnerParameters> | undefined;
    /** @summary Get leases durations. */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<
            GetLeasesDurationOwnerSchema,
            GetLeasesDurationOwnerData,
            TInfinite,
            GetLeasesDurationOwnerParameters,
            GetLeasesDurationOwnerError
          >
        | QueryFiltersByQueryKey<
            GetLeasesDurationOwnerSchema,
            GetLeasesDurationOwnerData,
            TInfinite,
            GetLeasesDurationOwnerParameters,
            GetLeasesDurationOwnerError
          >,
      updater: Updater<NoInfer<GetLeasesDurationOwnerData> | undefined, NoInfer<GetLeasesDurationOwnerData> | undefined>,
      options?: SetDataOptions
    ): Array<GetLeasesDurationOwnerData | undefined>;
    /** @summary Get leases durations. */
    setQueryData(
      parameters: DeepReadonly<GetLeasesDurationOwnerParameters> | ServiceOperationQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters>,
      updater: Updater<NoInfer<GetLeasesDurationOwnerData> | undefined, NoInfer<DeepReadonly<GetLeasesDurationOwnerData>> | undefined>,
      options?: SetDataOptions
    ): GetLeasesDurationOwnerData | undefined;
    /** @summary Get leases durations. */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetLeasesDurationOwnerParameters>
    ): ServiceOperationInfiniteQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get leases durations.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getLeasesDurationOwner.useInfiniteQuery({
     *     path: {
     *         owner: owner
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             dseq: initialDseq
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetLeasesDurationOwnerParameters,
      TQueryFnData = GetLeasesDurationOwnerData,
      TData = OperationInfiniteData<TQueryFnData, GetLeasesDurationOwnerParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters>
        | DeepReadonly<GetLeasesDurationOwnerParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetLeasesDurationOwnerError,
          TData,
          ServiceOperationInfiniteQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetLeasesDurationOwnerError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get leases durations.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getLeasesDurationOwner.useInfiniteQuery({
     *     path: {
     *         owner: owner
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             dseq: initialDseq
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetLeasesDurationOwnerParameters,
      TQueryFnData = GetLeasesDurationOwnerData,
      TData = OperationInfiniteData<TQueryFnData, GetLeasesDurationOwnerParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters>
        | DeepReadonly<GetLeasesDurationOwnerParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetLeasesDurationOwnerError,
          TData,
          ServiceOperationInfiniteQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetLeasesDurationOwnerData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetLeasesDurationOwnerError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get leases durations.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getLeasesDurationOwnerTotal = qraft.v1Service.getLeasesDurationOwner.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getLeasesDurationOwnerByParametersTotal = qraft.v1Service.getLeasesDurationOwner.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             owner: owner
     *         },
     *         query: {
     *             dseq: dseq
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetLeasesDurationOwnerSchema,
            GetLeasesDurationOwnerData,
            TInfinite,
            GetLeasesDurationOwnerParameters,
            GetLeasesDurationOwnerError
          >
        | QueryFiltersByQueryKey<
            GetLeasesDurationOwnerSchema,
            GetLeasesDurationOwnerData,
            TInfinite,
            GetLeasesDurationOwnerParameters,
            GetLeasesDurationOwnerError
          >
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get leases durations.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getLeasesDurationOwnerResults = qraft.v1Service.getLeasesDurationOwner.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 owner: owner1
     *             },
     *             query: {
     *                 dseq: dseq1
     *             }
     *         },
     *         {
     *             path: {
     *                 owner: owner2
     *             },
     *             query: {
     *                 dseq: dseq2
     *             }
     *         }
     *     ]
     * });
     * getLeasesDurationOwnerResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getLeasesDurationOwnerCombinedResults = qraft.v1Service.getLeasesDurationOwner.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 owner: owner1
     *             },
     *             query: {
     *                 dseq: dseq1
     *             }
     *         },
     *         {
     *             path: {
     *                 owner: owner2
     *             },
     *             query: {
     *                 dseq: dseq2
     *             }
     *         }
     *     ]
     * });
     * getLeasesDurationOwnerCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters, GetLeasesDurationOwnerData, GetLeasesDurationOwnerError>
      >,
      TCombinedResult = Array<UseQueryResult<GetLeasesDurationOwnerData, GetLeasesDurationOwnerError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetLeasesDurationOwnerData, GetLeasesDurationOwnerError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get leases durations. */
    getQueryKey(
      parameters: DeepReadonly<GetLeasesDurationOwnerParameters>
    ): ServiceOperationQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get leases durations.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getLeasesDurationOwner.useQuery({
     *     path: {
     *         owner: owner
     *     },
     *     query: {
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useQuery<TData = GetLeasesDurationOwnerData>(
      parameters: ServiceOperationQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters> | DeepReadonly<GetLeasesDurationOwnerParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetLeasesDurationOwnerData,
          GetLeasesDurationOwnerError,
          TData,
          ServiceOperationQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetLeasesDurationOwnerError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get leases durations.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getLeasesDurationOwner.useQuery({
     *     path: {
     *         owner: owner
     *     },
     *     query: {
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useQuery<TData = GetLeasesDurationOwnerData>(
      parameters: ServiceOperationQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters> | DeepReadonly<GetLeasesDurationOwnerParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetLeasesDurationOwnerData,
          GetLeasesDurationOwnerError,
          TData,
          ServiceOperationQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetLeasesDurationOwnerError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get leases durations.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getLeasesDurationOwner.useSuspenseInfiniteQuery({
     *     path: {
     *         owner: owner
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             dseq: initialDseq
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetLeasesDurationOwnerParameters, TData = GetLeasesDurationOwnerData>(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters>
        | DeepReadonly<GetLeasesDurationOwnerParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetLeasesDurationOwnerData,
          GetLeasesDurationOwnerError,
          OperationInfiniteData<TData, GetLeasesDurationOwnerParameters>,
          GetLeasesDurationOwnerData,
          ServiceOperationInfiniteQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetLeasesDurationOwnerData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetLeasesDurationOwnerParameters>, GetLeasesDurationOwnerError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get leases durations.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getLeasesDurationOwnerData = qraft.v1Service.getLeasesDurationOwner.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 owner: owner1
     *             },
     *             query: {
     *                 dseq: dseq1
     *             }
     *         },
     *         {
     *             path: {
     *                 owner: owner2
     *             },
     *             query: {
     *                 dseq: dseq2
     *             }
     *         }
     *     ]
     * });
     * getLeasesDurationOwnerResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getLeasesDurationOwnerCombinedData = qraft.v1Service.getLeasesDurationOwner.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 owner: owner1
     *             },
     *             query: {
     *                 dseq: dseq1
     *             }
     *         },
     *         {
     *             path: {
     *                 owner: owner2
     *             },
     *             query: {
     *                 dseq: dseq2
     *             }
     *         }
     *     ]
     * });
     * getLeasesDurationOwnerCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<
          GetLeasesDurationOwnerSchema,
          GetLeasesDurationOwnerParameters,
          GetLeasesDurationOwnerData,
          GetLeasesDurationOwnerError
        >
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetLeasesDurationOwnerData, GetLeasesDurationOwnerError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetLeasesDurationOwnerData, GetLeasesDurationOwnerError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get leases durations.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getLeasesDurationOwner.useSuspenseQuery({
     *     path: {
     *         owner: owner
     *     },
     *     query: {
     *         dseq: dseq
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetLeasesDurationOwnerData>(
      parameters: ServiceOperationQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters> | DeepReadonly<GetLeasesDurationOwnerParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<
          GetLeasesDurationOwnerData,
          GetLeasesDurationOwnerError,
          TData,
          ServiceOperationQueryKey<GetLeasesDurationOwnerSchema, GetLeasesDurationOwnerParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetLeasesDurationOwnerError | Error>;
    schema: GetLeasesDurationOwnerSchema;
    types: {
      parameters: GetLeasesDurationOwnerParameters;
      data: GetLeasesDurationOwnerData;
      error: GetLeasesDurationOwnerError;
    };
  };
  /** @summary Get address details */
  getAddressesAddress: {
    /** @summary Get address details */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAddressesAddressSchema, GetAddressesAddressData, TInfinite, GetAddressesAddressParameters, GetAddressesAddressError>
        | QueryFiltersByQueryKey<GetAddressesAddressSchema, GetAddressesAddressData, TInfinite, GetAddressesAddressParameters, GetAddressesAddressError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get address details */
    getQueryKey(parameters: DeepReadonly<GetAddressesAddressParameters>): ServiceOperationQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get address details
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAddressesAddress.useQuery({
     *     path: {
     *         address: address
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAddressesAddressData>(
      parameters: ServiceOperationQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters> | DeepReadonly<GetAddressesAddressParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetAddressesAddressData,
          GetAddressesAddressError,
          TData,
          ServiceOperationQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetAddressesAddressError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get address details
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAddressesAddress.useQuery({
     *     path: {
     *         address: address
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAddressesAddressData>(
      parameters: ServiceOperationQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters> | DeepReadonly<GetAddressesAddressParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetAddressesAddressData,
          GetAddressesAddressError,
          TData,
          ServiceOperationQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetAddressesAddressError | Error>;
    /** @summary Get address details */
    fetchInfiniteQuery<TPageParam extends GetAddressesAddressParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetAddressesAddressSchema,
        GetAddressesAddressData,
        GetAddressesAddressParameters,
        DeepReadonly<TPageParam>,
        GetAddressesAddressError
      >
    ): Promise<OperationInfiniteData<GetAddressesAddressData, GetAddressesAddressParameters>>;
    /** @summary Get address details */
    prefetchInfiniteQuery<TPageParam extends GetAddressesAddressParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetAddressesAddressSchema,
        GetAddressesAddressData,
        GetAddressesAddressParameters,
        DeepReadonly<TPageParam>,
        GetAddressesAddressError
      >
    ): Promise<void>;
    /** @summary Get address details */
    ensureInfiniteQueryData<TPageParam extends GetAddressesAddressParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetAddressesAddressSchema,
        GetAddressesAddressData,
        GetAddressesAddressParameters,
        DeepReadonly<TPageParam>,
        GetAddressesAddressError
      >
    ): Promise<OperationInfiniteData<GetAddressesAddressData, GetAddressesAddressParameters>>;
    /** @summary Get address details */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetAddressesAddressSchema, GetAddressesAddressData, GetAddressesAddressParameters, GetAddressesAddressError>
    ): Promise<GetAddressesAddressData>;
    /** @summary Get address details */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetAddressesAddressSchema, GetAddressesAddressData, GetAddressesAddressParameters, GetAddressesAddressError>
    ): Promise<void>;
    /** @summary Get address details */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetAddressesAddressSchema,
        GetAddressesAddressData,
        GetAddressesAddressParameters,
        GetAddressesAddressError
      >
    ): Promise<GetAddressesAddressData>;
    /** @summary Get address details */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters> | DeepReadonly<GetAddressesAddressParameters>
    ): OperationInfiniteData<GetAddressesAddressData, GetAddressesAddressParameters> | undefined;
    /** @summary Get address details */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAddressesAddressSchema, GetAddressesAddressData, TInfinite, GetAddressesAddressParameters, GetAddressesAddressError>
        | QueryFiltersByQueryKey<GetAddressesAddressSchema, GetAddressesAddressData, TInfinite, GetAddressesAddressParameters, GetAddressesAddressError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters>,
            data: NoInfer<OperationInfiniteData<GetAddressesAddressData, GetAddressesAddressParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters>, data: GetAddressesAddressData | undefined]>;
    /** @summary Get address details */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters> | DeepReadonly<GetAddressesAddressParameters>
    ): GetAddressesAddressData | undefined;
    /** @summary Get address details */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters> | DeepReadonly<GetAddressesAddressParameters>
    ): QueryState<GetAddressesAddressData, GetAddressesAddressError> | undefined;
    /** @summary Get address details */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetAddressesAddressParameters> | ServiceOperationInfiniteQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters>
    ): QueryState<OperationInfiniteData<GetAddressesAddressData, GetAddressesAddressParameters>, GetAddressesAddressError> | undefined;
    /** @summary Get address details */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetAddressesAddressSchema, GetAddressesAddressData, TInfinite, GetAddressesAddressParameters, GetAddressesAddressError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get address details */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAddressesAddressSchema, GetAddressesAddressData, TInfinite, GetAddressesAddressParameters, GetAddressesAddressError>
        | QueryFiltersByQueryKey<GetAddressesAddressSchema, GetAddressesAddressData, TInfinite, GetAddressesAddressParameters, GetAddressesAddressError>
    ): number;
    /** @summary Get address details */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetAddressesAddressParameters, TMeta, TSignal>,
      client?: (
        schema: GetAddressesAddressSchema,
        options: {
          parameters: GetAddressesAddressParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetAddressesAddressData, GetAddressesAddressError>>
    ): Promise<RequestFnResponse<GetAddressesAddressData, GetAddressesAddressError>>;
    /** @summary Get address details */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAddressesAddressSchema, GetAddressesAddressData, TInfinite, GetAddressesAddressParameters, GetAddressesAddressError>
        | QueryFiltersByQueryKey<GetAddressesAddressSchema, GetAddressesAddressData, TInfinite, GetAddressesAddressParameters, GetAddressesAddressError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get address details */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAddressesAddressSchema, GetAddressesAddressData, TInfinite, GetAddressesAddressParameters, GetAddressesAddressError>
        | QueryFiltersByQueryKey<GetAddressesAddressSchema, GetAddressesAddressData, TInfinite, GetAddressesAddressParameters, GetAddressesAddressError>
    ): void;
    /** @summary Get address details */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAddressesAddressSchema, GetAddressesAddressData, TInfinite, GetAddressesAddressParameters, GetAddressesAddressError>
        | QueryFiltersByQueryKey<GetAddressesAddressSchema, GetAddressesAddressData, TInfinite, GetAddressesAddressParameters, GetAddressesAddressError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get address details */
    setInfiniteQueryData(
      parameters: DeepReadonly<GetAddressesAddressParameters> | ServiceOperationInfiniteQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetAddressesAddressData, GetAddressesAddressParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetAddressesAddressData, GetAddressesAddressParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetAddressesAddressData, GetAddressesAddressParameters> | undefined;
    /** @summary Get address details */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetAddressesAddressSchema, GetAddressesAddressData, TInfinite, GetAddressesAddressParameters, GetAddressesAddressError>
        | QueryFiltersByQueryKey<GetAddressesAddressSchema, GetAddressesAddressData, TInfinite, GetAddressesAddressParameters, GetAddressesAddressError>,
      updater: Updater<NoInfer<GetAddressesAddressData> | undefined, NoInfer<GetAddressesAddressData> | undefined>,
      options?: SetDataOptions
    ): Array<GetAddressesAddressData | undefined>;
    /** @summary Get address details */
    setQueryData(
      parameters: DeepReadonly<GetAddressesAddressParameters> | ServiceOperationQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters>,
      updater: Updater<NoInfer<GetAddressesAddressData> | undefined, NoInfer<DeepReadonly<GetAddressesAddressData>> | undefined>,
      options?: SetDataOptions
    ): GetAddressesAddressData | undefined;
    /** @summary Get address details */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetAddressesAddressParameters>
    ): ServiceOperationInfiniteQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get address details
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAddressesAddress.useInfiniteQuery({
     *     path: {
     *         address: address
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetAddressesAddressParameters,
      TQueryFnData = GetAddressesAddressData,
      TData = OperationInfiniteData<TQueryFnData, GetAddressesAddressParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters> | DeepReadonly<GetAddressesAddressParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetAddressesAddressError,
          TData,
          ServiceOperationInfiniteQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetAddressesAddressError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get address details
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAddressesAddress.useInfiniteQuery({
     *     path: {
     *         address: address
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetAddressesAddressParameters,
      TQueryFnData = GetAddressesAddressData,
      TData = OperationInfiniteData<TQueryFnData, GetAddressesAddressParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters> | DeepReadonly<GetAddressesAddressParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetAddressesAddressError,
          TData,
          ServiceOperationInfiniteQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetAddressesAddressData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetAddressesAddressError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get address details
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getAddressesAddressTotal = qraft.v1Service.getAddressesAddress.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getAddressesAddressByParametersTotal = qraft.v1Service.getAddressesAddress.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             address: address
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAddressesAddressSchema, GetAddressesAddressData, TInfinite, GetAddressesAddressParameters, GetAddressesAddressError>
        | QueryFiltersByQueryKey<GetAddressesAddressSchema, GetAddressesAddressData, TInfinite, GetAddressesAddressParameters, GetAddressesAddressError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get address details
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getAddressesAddressResults = qraft.v1Service.getAddressesAddress.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 address: address1
     *             }
     *         },
     *         {
     *             path: {
     *                 address: address2
     *             }
     *         }
     *     ]
     * });
     * getAddressesAddressResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getAddressesAddressCombinedResults = qraft.v1Service.getAddressesAddress.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 address: address1
     *             }
     *         },
     *         {
     *             path: {
     *                 address: address2
     *             }
     *         }
     *     ]
     * });
     * getAddressesAddressCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<GetAddressesAddressSchema, GetAddressesAddressParameters, GetAddressesAddressData, GetAddressesAddressError>
      >,
      TCombinedResult = Array<UseQueryResult<GetAddressesAddressData, GetAddressesAddressError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetAddressesAddressData, GetAddressesAddressError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get address details */
    getQueryKey(parameters: DeepReadonly<GetAddressesAddressParameters>): ServiceOperationQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get address details
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAddressesAddress.useQuery({
     *     path: {
     *         address: address
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAddressesAddressData>(
      parameters: ServiceOperationQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters> | DeepReadonly<GetAddressesAddressParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetAddressesAddressData,
          GetAddressesAddressError,
          TData,
          ServiceOperationQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetAddressesAddressError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get address details
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAddressesAddress.useQuery({
     *     path: {
     *         address: address
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAddressesAddressData>(
      parameters: ServiceOperationQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters> | DeepReadonly<GetAddressesAddressParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetAddressesAddressData,
          GetAddressesAddressError,
          TData,
          ServiceOperationQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetAddressesAddressError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get address details
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAddressesAddress.useSuspenseInfiniteQuery({
     *     path: {
     *         address: address
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetAddressesAddressParameters, TData = GetAddressesAddressData>(
      parameters: ServiceOperationInfiniteQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters> | DeepReadonly<GetAddressesAddressParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetAddressesAddressData,
          GetAddressesAddressError,
          OperationInfiniteData<TData, GetAddressesAddressParameters>,
          GetAddressesAddressData,
          ServiceOperationInfiniteQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetAddressesAddressData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetAddressesAddressParameters>, GetAddressesAddressError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get address details
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getAddressesAddressData = qraft.v1Service.getAddressesAddress.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 address: address1
     *             }
     *         },
     *         {
     *             path: {
     *                 address: address2
     *             }
     *         }
     *     ]
     * });
     * getAddressesAddressResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getAddressesAddressCombinedData = qraft.v1Service.getAddressesAddress.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 address: address1
     *             }
     *         },
     *         {
     *             path: {
     *                 address: address2
     *             }
     *         }
     *     ]
     * });
     * getAddressesAddressCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<GetAddressesAddressSchema, GetAddressesAddressParameters, GetAddressesAddressData, GetAddressesAddressError>
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetAddressesAddressData, GetAddressesAddressError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetAddressesAddressData, GetAddressesAddressError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get address details
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getAddressesAddress.useSuspenseQuery({
     *     path: {
     *         address: address
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetAddressesAddressData>(
      parameters: ServiceOperationQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters> | DeepReadonly<GetAddressesAddressParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<
          GetAddressesAddressData,
          GetAddressesAddressError,
          TData,
          ServiceOperationQueryKey<GetAddressesAddressSchema, GetAddressesAddressParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetAddressesAddressError | Error>;
    schema: GetAddressesAddressSchema;
    types: {
      parameters: GetAddressesAddressParameters;
      data: GetAddressesAddressData;
      error: GetAddressesAddressError;
    };
  };
  /** @summary Get a list of transactions for a given address. */
  getAddressesAddressTransactionsSkipLimit: {
    /** @summary Get a list of transactions for a given address. */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetAddressesAddressTransactionsSkipLimitSchema,
            GetAddressesAddressTransactionsSkipLimitData,
            TInfinite,
            GetAddressesAddressTransactionsSkipLimitParameters,
            GetAddressesAddressTransactionsSkipLimitError
          >
        | QueryFiltersByQueryKey<
            GetAddressesAddressTransactionsSkipLimitSchema,
            GetAddressesAddressTransactionsSkipLimitData,
            TInfinite,
            GetAddressesAddressTransactionsSkipLimitParameters,
            GetAddressesAddressTransactionsSkipLimitError
          >,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get a list of transactions for a given address. */
    getQueryKey(
      parameters: DeepReadonly<GetAddressesAddressTransactionsSkipLimitParameters>
    ): ServiceOperationQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of transactions for a given address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAddressesAddressTransactionsSkipLimit.useQuery({
     *     path: {
     *         address: address,
     *         limit: limit
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAddressesAddressTransactionsSkipLimitData>(
      parameters:
        | ServiceOperationQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>
        | DeepReadonly<GetAddressesAddressTransactionsSkipLimitParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetAddressesAddressTransactionsSkipLimitData,
          GetAddressesAddressTransactionsSkipLimitError,
          TData,
          ServiceOperationQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetAddressesAddressTransactionsSkipLimitError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of transactions for a given address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAddressesAddressTransactionsSkipLimit.useQuery({
     *     path: {
     *         address: address,
     *         limit: limit
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAddressesAddressTransactionsSkipLimitData>(
      parameters:
        | ServiceOperationQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>
        | DeepReadonly<GetAddressesAddressTransactionsSkipLimitParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetAddressesAddressTransactionsSkipLimitData,
          GetAddressesAddressTransactionsSkipLimitError,
          TData,
          ServiceOperationQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetAddressesAddressTransactionsSkipLimitError | Error>;
    /** @summary Get a list of transactions for a given address. */
    fetchInfiniteQuery<TPageParam extends GetAddressesAddressTransactionsSkipLimitParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetAddressesAddressTransactionsSkipLimitSchema,
        GetAddressesAddressTransactionsSkipLimitData,
        GetAddressesAddressTransactionsSkipLimitParameters,
        DeepReadonly<TPageParam>,
        GetAddressesAddressTransactionsSkipLimitError
      >
    ): Promise<OperationInfiniteData<GetAddressesAddressTransactionsSkipLimitData, GetAddressesAddressTransactionsSkipLimitParameters>>;
    /** @summary Get a list of transactions for a given address. */
    prefetchInfiniteQuery<TPageParam extends GetAddressesAddressTransactionsSkipLimitParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetAddressesAddressTransactionsSkipLimitSchema,
        GetAddressesAddressTransactionsSkipLimitData,
        GetAddressesAddressTransactionsSkipLimitParameters,
        DeepReadonly<TPageParam>,
        GetAddressesAddressTransactionsSkipLimitError
      >
    ): Promise<void>;
    /** @summary Get a list of transactions for a given address. */
    ensureInfiniteQueryData<TPageParam extends GetAddressesAddressTransactionsSkipLimitParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetAddressesAddressTransactionsSkipLimitSchema,
        GetAddressesAddressTransactionsSkipLimitData,
        GetAddressesAddressTransactionsSkipLimitParameters,
        DeepReadonly<TPageParam>,
        GetAddressesAddressTransactionsSkipLimitError
      >
    ): Promise<OperationInfiniteData<GetAddressesAddressTransactionsSkipLimitData, GetAddressesAddressTransactionsSkipLimitParameters>>;
    /** @summary Get a list of transactions for a given address. */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetAddressesAddressTransactionsSkipLimitSchema,
        GetAddressesAddressTransactionsSkipLimitData,
        GetAddressesAddressTransactionsSkipLimitParameters,
        GetAddressesAddressTransactionsSkipLimitError
      >
    ): Promise<GetAddressesAddressTransactionsSkipLimitData>;
    /** @summary Get a list of transactions for a given address. */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetAddressesAddressTransactionsSkipLimitSchema,
        GetAddressesAddressTransactionsSkipLimitData,
        GetAddressesAddressTransactionsSkipLimitParameters,
        GetAddressesAddressTransactionsSkipLimitError
      >
    ): Promise<void>;
    /** @summary Get a list of transactions for a given address. */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetAddressesAddressTransactionsSkipLimitSchema,
        GetAddressesAddressTransactionsSkipLimitData,
        GetAddressesAddressTransactionsSkipLimitParameters,
        GetAddressesAddressTransactionsSkipLimitError
      >
    ): Promise<GetAddressesAddressTransactionsSkipLimitData>;
    /** @summary Get a list of transactions for a given address. */
    getInfiniteQueryData(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>
        | DeepReadonly<GetAddressesAddressTransactionsSkipLimitParameters>
    ): OperationInfiniteData<GetAddressesAddressTransactionsSkipLimitData, GetAddressesAddressTransactionsSkipLimitParameters> | undefined;
    /** @summary Get a list of transactions for a given address. */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetAddressesAddressTransactionsSkipLimitSchema,
            GetAddressesAddressTransactionsSkipLimitData,
            TInfinite,
            GetAddressesAddressTransactionsSkipLimitParameters,
            GetAddressesAddressTransactionsSkipLimitError
          >
        | QueryFiltersByQueryKey<
            GetAddressesAddressTransactionsSkipLimitSchema,
            GetAddressesAddressTransactionsSkipLimitData,
            TInfinite,
            GetAddressesAddressTransactionsSkipLimitParameters,
            GetAddressesAddressTransactionsSkipLimitError
          >
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>,
            data: NoInfer<OperationInfiniteData<GetAddressesAddressTransactionsSkipLimitData, GetAddressesAddressTransactionsSkipLimitParameters>> | undefined
          ]
        >
      : Array<
          [
            queryKey: ServiceOperationQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>,
            data: GetAddressesAddressTransactionsSkipLimitData | undefined
          ]
        >;
    /** @summary Get a list of transactions for a given address. */
    getQueryData(
      parameters:
        | ServiceOperationQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>
        | DeepReadonly<GetAddressesAddressTransactionsSkipLimitParameters>
    ): GetAddressesAddressTransactionsSkipLimitData | undefined;
    /** @summary Get a list of transactions for a given address. */
    getQueryState(
      parameters:
        | ServiceOperationQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>
        | DeepReadonly<GetAddressesAddressTransactionsSkipLimitParameters>
    ): QueryState<GetAddressesAddressTransactionsSkipLimitData, GetAddressesAddressTransactionsSkipLimitError> | undefined;
    /** @summary Get a list of transactions for a given address. */
    getInfiniteQueryState(
      parameters:
        | DeepReadonly<GetAddressesAddressTransactionsSkipLimitParameters>
        | ServiceOperationInfiniteQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>
    ):
      | QueryState<
          OperationInfiniteData<GetAddressesAddressTransactionsSkipLimitData, GetAddressesAddressTransactionsSkipLimitParameters>,
          GetAddressesAddressTransactionsSkipLimitError
        >
      | undefined;
    /** @summary Get a list of transactions for a given address. */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<
        GetAddressesAddressTransactionsSkipLimitSchema,
        GetAddressesAddressTransactionsSkipLimitData,
        TInfinite,
        GetAddressesAddressTransactionsSkipLimitParameters,
        GetAddressesAddressTransactionsSkipLimitError
      >,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get a list of transactions for a given address. */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetAddressesAddressTransactionsSkipLimitSchema,
            GetAddressesAddressTransactionsSkipLimitData,
            TInfinite,
            GetAddressesAddressTransactionsSkipLimitParameters,
            GetAddressesAddressTransactionsSkipLimitError
          >
        | QueryFiltersByQueryKey<
            GetAddressesAddressTransactionsSkipLimitSchema,
            GetAddressesAddressTransactionsSkipLimitData,
            TInfinite,
            GetAddressesAddressTransactionsSkipLimitParameters,
            GetAddressesAddressTransactionsSkipLimitError
          >
    ): number;
    /** @summary Get a list of transactions for a given address. */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetAddressesAddressTransactionsSkipLimitParameters, TMeta, TSignal>,
      client?: (
        schema: GetAddressesAddressTransactionsSkipLimitSchema,
        options: {
          parameters: GetAddressesAddressTransactionsSkipLimitParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetAddressesAddressTransactionsSkipLimitData, GetAddressesAddressTransactionsSkipLimitError>>
    ): Promise<RequestFnResponse<GetAddressesAddressTransactionsSkipLimitData, GetAddressesAddressTransactionsSkipLimitError>>;
    /** @summary Get a list of transactions for a given address. */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetAddressesAddressTransactionsSkipLimitSchema,
            GetAddressesAddressTransactionsSkipLimitData,
            TInfinite,
            GetAddressesAddressTransactionsSkipLimitParameters,
            GetAddressesAddressTransactionsSkipLimitError
          >
        | QueryFiltersByQueryKey<
            GetAddressesAddressTransactionsSkipLimitSchema,
            GetAddressesAddressTransactionsSkipLimitData,
            TInfinite,
            GetAddressesAddressTransactionsSkipLimitParameters,
            GetAddressesAddressTransactionsSkipLimitError
          >,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get a list of transactions for a given address. */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetAddressesAddressTransactionsSkipLimitSchema,
            GetAddressesAddressTransactionsSkipLimitData,
            TInfinite,
            GetAddressesAddressTransactionsSkipLimitParameters,
            GetAddressesAddressTransactionsSkipLimitError
          >
        | QueryFiltersByQueryKey<
            GetAddressesAddressTransactionsSkipLimitSchema,
            GetAddressesAddressTransactionsSkipLimitData,
            TInfinite,
            GetAddressesAddressTransactionsSkipLimitParameters,
            GetAddressesAddressTransactionsSkipLimitError
          >
    ): void;
    /** @summary Get a list of transactions for a given address. */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetAddressesAddressTransactionsSkipLimitSchema,
            GetAddressesAddressTransactionsSkipLimitData,
            TInfinite,
            GetAddressesAddressTransactionsSkipLimitParameters,
            GetAddressesAddressTransactionsSkipLimitError
          >
        | QueryFiltersByQueryKey<
            GetAddressesAddressTransactionsSkipLimitSchema,
            GetAddressesAddressTransactionsSkipLimitData,
            TInfinite,
            GetAddressesAddressTransactionsSkipLimitParameters,
            GetAddressesAddressTransactionsSkipLimitError
          >,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get a list of transactions for a given address. */
    setInfiniteQueryData(
      parameters:
        | DeepReadonly<GetAddressesAddressTransactionsSkipLimitParameters>
        | ServiceOperationInfiniteQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetAddressesAddressTransactionsSkipLimitData, GetAddressesAddressTransactionsSkipLimitParameters>> | undefined,
        | NoInfer<DeepReadonly<OperationInfiniteData<GetAddressesAddressTransactionsSkipLimitData, GetAddressesAddressTransactionsSkipLimitParameters>>>
        | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetAddressesAddressTransactionsSkipLimitData, GetAddressesAddressTransactionsSkipLimitParameters> | undefined;
    /** @summary Get a list of transactions for a given address. */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<
            GetAddressesAddressTransactionsSkipLimitSchema,
            GetAddressesAddressTransactionsSkipLimitData,
            TInfinite,
            GetAddressesAddressTransactionsSkipLimitParameters,
            GetAddressesAddressTransactionsSkipLimitError
          >
        | QueryFiltersByQueryKey<
            GetAddressesAddressTransactionsSkipLimitSchema,
            GetAddressesAddressTransactionsSkipLimitData,
            TInfinite,
            GetAddressesAddressTransactionsSkipLimitParameters,
            GetAddressesAddressTransactionsSkipLimitError
          >,
      updater: Updater<NoInfer<GetAddressesAddressTransactionsSkipLimitData> | undefined, NoInfer<GetAddressesAddressTransactionsSkipLimitData> | undefined>,
      options?: SetDataOptions
    ): Array<GetAddressesAddressTransactionsSkipLimitData | undefined>;
    /** @summary Get a list of transactions for a given address. */
    setQueryData(
      parameters:
        | DeepReadonly<GetAddressesAddressTransactionsSkipLimitParameters>
        | ServiceOperationQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>,
      updater: Updater<
        NoInfer<GetAddressesAddressTransactionsSkipLimitData> | undefined,
        NoInfer<DeepReadonly<GetAddressesAddressTransactionsSkipLimitData>> | undefined
      >,
      options?: SetDataOptions
    ): GetAddressesAddressTransactionsSkipLimitData | undefined;
    /** @summary Get a list of transactions for a given address. */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetAddressesAddressTransactionsSkipLimitParameters>
    ): ServiceOperationInfiniteQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of transactions for a given address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAddressesAddressTransactionsSkipLimit.useInfiniteQuery({
     *     path: {
     *         address: address,
     *         limit: limit
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetAddressesAddressTransactionsSkipLimitParameters,
      TQueryFnData = GetAddressesAddressTransactionsSkipLimitData,
      TData = OperationInfiniteData<TQueryFnData, GetAddressesAddressTransactionsSkipLimitParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>
        | DeepReadonly<GetAddressesAddressTransactionsSkipLimitParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetAddressesAddressTransactionsSkipLimitError,
          TData,
          ServiceOperationInfiniteQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetAddressesAddressTransactionsSkipLimitError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of transactions for a given address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAddressesAddressTransactionsSkipLimit.useInfiniteQuery({
     *     path: {
     *         address: address,
     *         limit: limit
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetAddressesAddressTransactionsSkipLimitParameters,
      TQueryFnData = GetAddressesAddressTransactionsSkipLimitData,
      TData = OperationInfiniteData<TQueryFnData, GetAddressesAddressTransactionsSkipLimitParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>
        | DeepReadonly<GetAddressesAddressTransactionsSkipLimitParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetAddressesAddressTransactionsSkipLimitError,
          TData,
          ServiceOperationInfiniteQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetAddressesAddressTransactionsSkipLimitData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetAddressesAddressTransactionsSkipLimitError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get a list of transactions for a given address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getAddressesAddressTransactionsSkipLimitTotal = qraft.v1Service.getAddressesAddressTransactionsSkipLimit.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getAddressesAddressTransactionsSkipLimitByParametersTotal = qraft.v1Service.getAddressesAddressTransactionsSkipLimit.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             address: address,
     *             limit: limit
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetAddressesAddressTransactionsSkipLimitSchema,
            GetAddressesAddressTransactionsSkipLimitData,
            TInfinite,
            GetAddressesAddressTransactionsSkipLimitParameters,
            GetAddressesAddressTransactionsSkipLimitError
          >
        | QueryFiltersByQueryKey<
            GetAddressesAddressTransactionsSkipLimitSchema,
            GetAddressesAddressTransactionsSkipLimitData,
            TInfinite,
            GetAddressesAddressTransactionsSkipLimitParameters,
            GetAddressesAddressTransactionsSkipLimitError
          >
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get a list of transactions for a given address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getAddressesAddressTransactionsSkipLimitResults = qraft.v1Service.getAddressesAddressTransactionsSkipLimit.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 address: address1,
     *                 limit: limit1
     *             }
     *         },
     *         {
     *             path: {
     *                 address: address2,
     *                 limit: limit2
     *             }
     *         }
     *     ]
     * });
     * getAddressesAddressTransactionsSkipLimitResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getAddressesAddressTransactionsSkipLimitCombinedResults = qraft.v1Service.getAddressesAddressTransactionsSkipLimit.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 address: address1,
     *                 limit: limit1
     *             }
     *         },
     *         {
     *             path: {
     *                 address: address2,
     *                 limit: limit2
     *             }
     *         }
     *     ]
     * });
     * getAddressesAddressTransactionsSkipLimitCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<
          GetAddressesAddressTransactionsSkipLimitSchema,
          GetAddressesAddressTransactionsSkipLimitParameters,
          GetAddressesAddressTransactionsSkipLimitData,
          GetAddressesAddressTransactionsSkipLimitError
        >
      >,
      TCombinedResult = Array<UseQueryResult<GetAddressesAddressTransactionsSkipLimitData, GetAddressesAddressTransactionsSkipLimitError>>
    >(options: {
      queries: T;
      combine?: (
        results: Array<UseQueryResult<GetAddressesAddressTransactionsSkipLimitData, GetAddressesAddressTransactionsSkipLimitError>>
      ) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get a list of transactions for a given address. */
    getQueryKey(
      parameters: DeepReadonly<GetAddressesAddressTransactionsSkipLimitParameters>
    ): ServiceOperationQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of transactions for a given address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAddressesAddressTransactionsSkipLimit.useQuery({
     *     path: {
     *         address: address,
     *         limit: limit
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAddressesAddressTransactionsSkipLimitData>(
      parameters:
        | ServiceOperationQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>
        | DeepReadonly<GetAddressesAddressTransactionsSkipLimitParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetAddressesAddressTransactionsSkipLimitData,
          GetAddressesAddressTransactionsSkipLimitError,
          TData,
          ServiceOperationQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetAddressesAddressTransactionsSkipLimitError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of transactions for a given address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAddressesAddressTransactionsSkipLimit.useQuery({
     *     path: {
     *         address: address,
     *         limit: limit
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAddressesAddressTransactionsSkipLimitData>(
      parameters:
        | ServiceOperationQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>
        | DeepReadonly<GetAddressesAddressTransactionsSkipLimitParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetAddressesAddressTransactionsSkipLimitData,
          GetAddressesAddressTransactionsSkipLimitError,
          TData,
          ServiceOperationQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetAddressesAddressTransactionsSkipLimitError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get a list of transactions for a given address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAddressesAddressTransactionsSkipLimit.useSuspenseInfiniteQuery({
     *     path: {
     *         address: address,
     *         limit: limit
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetAddressesAddressTransactionsSkipLimitParameters, TData = GetAddressesAddressTransactionsSkipLimitData>(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>
        | DeepReadonly<GetAddressesAddressTransactionsSkipLimitParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetAddressesAddressTransactionsSkipLimitData,
          GetAddressesAddressTransactionsSkipLimitError,
          OperationInfiniteData<TData, GetAddressesAddressTransactionsSkipLimitParameters>,
          GetAddressesAddressTransactionsSkipLimitData,
          ServiceOperationInfiniteQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetAddressesAddressTransactionsSkipLimitData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<
      OperationInfiniteData<TData, GetAddressesAddressTransactionsSkipLimitParameters>,
      GetAddressesAddressTransactionsSkipLimitError | Error
    >;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get a list of transactions for a given address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getAddressesAddressTransactionsSkipLimitData = qraft.v1Service.getAddressesAddressTransactionsSkipLimit.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 address: address1,
     *                 limit: limit1
     *             }
     *         },
     *         {
     *             path: {
     *                 address: address2,
     *                 limit: limit2
     *             }
     *         }
     *     ]
     * });
     * getAddressesAddressTransactionsSkipLimitResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getAddressesAddressTransactionsSkipLimitCombinedData = qraft.v1Service.getAddressesAddressTransactionsSkipLimit.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 address: address1,
     *                 limit: limit1
     *             }
     *         },
     *         {
     *             path: {
     *                 address: address2,
     *                 limit: limit2
     *             }
     *         }
     *     ]
     * });
     * getAddressesAddressTransactionsSkipLimitCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<
          GetAddressesAddressTransactionsSkipLimitSchema,
          GetAddressesAddressTransactionsSkipLimitParameters,
          GetAddressesAddressTransactionsSkipLimitData,
          GetAddressesAddressTransactionsSkipLimitError
        >
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetAddressesAddressTransactionsSkipLimitData, GetAddressesAddressTransactionsSkipLimitError>>
    >(options: {
      queries: T;
      combine?: (
        results: Array<
          WithOptional<UseSuspenseQueryResult<GetAddressesAddressTransactionsSkipLimitData, GetAddressesAddressTransactionsSkipLimitError>, "data">
        >
      ) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get a list of transactions for a given address.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getAddressesAddressTransactionsSkipLimit.useSuspenseQuery({
     *     path: {
     *         address: address,
     *         limit: limit
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetAddressesAddressTransactionsSkipLimitData>(
      parameters:
        | ServiceOperationQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>
        | DeepReadonly<GetAddressesAddressTransactionsSkipLimitParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<
          GetAddressesAddressTransactionsSkipLimitData,
          GetAddressesAddressTransactionsSkipLimitError,
          TData,
          ServiceOperationQueryKey<GetAddressesAddressTransactionsSkipLimitSchema, GetAddressesAddressTransactionsSkipLimitParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetAddressesAddressTransactionsSkipLimitError | Error>;
    schema: GetAddressesAddressTransactionsSkipLimitSchema;
    types: {
      parameters: GetAddressesAddressTransactionsSkipLimitParameters;
      data: GetAddressesAddressTransactionsSkipLimitData;
      error: GetAddressesAddressTransactionsSkipLimitError;
    };
  };
  /** @summary Get a list of nodes (api/rpc) for a specific network. */
  getNodesNetwork: {
    /** @summary Get a list of nodes (api/rpc) for a specific network. */
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetNodesNetworkSchema, GetNodesNetworkData, TInfinite, GetNodesNetworkParameters, GetNodesNetworkError>
        | QueryFiltersByQueryKey<GetNodesNetworkSchema, GetNodesNetworkData, TInfinite, GetNodesNetworkParameters, GetNodesNetworkError>,
      options?: CancelOptions
    ): Promise<void>;
    /** @summary Get a list of nodes (api/rpc) for a specific network. */
    getQueryKey(parameters: DeepReadonly<GetNodesNetworkParameters>): ServiceOperationQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of nodes (api/rpc) for a specific network.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNodesNetwork.useQuery({
     *     path: {
     *         network: network
     *     }
     * })
     * ```
     */
    useQuery<TData = GetNodesNetworkData>(
      parameters: ServiceOperationQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters> | DeepReadonly<GetNodesNetworkParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetNodesNetworkData,
          GetNodesNetworkError,
          TData,
          ServiceOperationQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetNodesNetworkError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of nodes (api/rpc) for a specific network.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNodesNetwork.useQuery({
     *     path: {
     *         network: network
     *     }
     * })
     * ```
     */
    useQuery<TData = GetNodesNetworkData>(
      parameters: ServiceOperationQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters> | DeepReadonly<GetNodesNetworkParameters>,
      options: Omit<
        DefinedInitialDataOptions<GetNodesNetworkData, GetNodesNetworkError, TData, ServiceOperationQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetNodesNetworkError | Error>;
    /** @summary Get a list of nodes (api/rpc) for a specific network. */
    fetchInfiniteQuery<TPageParam extends GetNodesNetworkParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetNodesNetworkSchema,
        GetNodesNetworkData,
        GetNodesNetworkParameters,
        DeepReadonly<TPageParam>,
        GetNodesNetworkError
      >
    ): Promise<OperationInfiniteData<GetNodesNetworkData, GetNodesNetworkParameters>>;
    /** @summary Get a list of nodes (api/rpc) for a specific network. */
    prefetchInfiniteQuery<TPageParam extends GetNodesNetworkParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetNodesNetworkSchema,
        GetNodesNetworkData,
        GetNodesNetworkParameters,
        DeepReadonly<TPageParam>,
        GetNodesNetworkError
      >
    ): Promise<void>;
    /** @summary Get a list of nodes (api/rpc) for a specific network. */
    ensureInfiniteQueryData<TPageParam extends GetNodesNetworkParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetNodesNetworkSchema,
        GetNodesNetworkData,
        GetNodesNetworkParameters,
        DeepReadonly<TPageParam>,
        GetNodesNetworkError
      >
    ): Promise<OperationInfiniteData<GetNodesNetworkData, GetNodesNetworkParameters>>;
    /** @summary Get a list of nodes (api/rpc) for a specific network. */
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetNodesNetworkSchema, GetNodesNetworkData, GetNodesNetworkParameters, GetNodesNetworkError>
    ): Promise<GetNodesNetworkData>;
    /** @summary Get a list of nodes (api/rpc) for a specific network. */
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetNodesNetworkSchema, GetNodesNetworkData, GetNodesNetworkParameters, GetNodesNetworkError>
    ): Promise<void>;
    /** @summary Get a list of nodes (api/rpc) for a specific network. */
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetNodesNetworkSchema, GetNodesNetworkData, GetNodesNetworkParameters, GetNodesNetworkError>
    ): Promise<GetNodesNetworkData>;
    /** @summary Get a list of nodes (api/rpc) for a specific network. */
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters> | DeepReadonly<GetNodesNetworkParameters>
    ): OperationInfiniteData<GetNodesNetworkData, GetNodesNetworkParameters> | undefined;
    /** @summary Get a list of nodes (api/rpc) for a specific network. */
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetNodesNetworkSchema, GetNodesNetworkData, TInfinite, GetNodesNetworkParameters, GetNodesNetworkError>
        | QueryFiltersByQueryKey<GetNodesNetworkSchema, GetNodesNetworkData, TInfinite, GetNodesNetworkParameters, GetNodesNetworkError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters>,
            data: NoInfer<OperationInfiniteData<GetNodesNetworkData, GetNodesNetworkParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters>, data: GetNodesNetworkData | undefined]>;
    /** @summary Get a list of nodes (api/rpc) for a specific network. */
    getQueryData(
      parameters: ServiceOperationQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters> | DeepReadonly<GetNodesNetworkParameters>
    ): GetNodesNetworkData | undefined;
    /** @summary Get a list of nodes (api/rpc) for a specific network. */
    getQueryState(
      parameters: ServiceOperationQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters> | DeepReadonly<GetNodesNetworkParameters>
    ): QueryState<GetNodesNetworkData, GetNodesNetworkError> | undefined;
    /** @summary Get a list of nodes (api/rpc) for a specific network. */
    getInfiniteQueryState(
      parameters: DeepReadonly<GetNodesNetworkParameters> | ServiceOperationInfiniteQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters>
    ): QueryState<OperationInfiniteData<GetNodesNetworkData, GetNodesNetworkParameters>, GetNodesNetworkError> | undefined;
    /** @summary Get a list of nodes (api/rpc) for a specific network. */
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetNodesNetworkSchema, GetNodesNetworkData, TInfinite, GetNodesNetworkParameters, GetNodesNetworkError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /** @summary Get a list of nodes (api/rpc) for a specific network. */
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetNodesNetworkSchema, GetNodesNetworkData, TInfinite, GetNodesNetworkParameters, GetNodesNetworkError>
        | QueryFiltersByQueryKey<GetNodesNetworkSchema, GetNodesNetworkData, TInfinite, GetNodesNetworkParameters, GetNodesNetworkError>
    ): number;
    /** @summary Get a list of nodes (api/rpc) for a specific network. */
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetNodesNetworkParameters, TMeta, TSignal>,
      client?: (
        schema: GetNodesNetworkSchema,
        options: {
          parameters: GetNodesNetworkParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetNodesNetworkData, GetNodesNetworkError>>
    ): Promise<RequestFnResponse<GetNodesNetworkData, GetNodesNetworkError>>;
    /** @summary Get a list of nodes (api/rpc) for a specific network. */
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetNodesNetworkSchema, GetNodesNetworkData, TInfinite, GetNodesNetworkParameters, GetNodesNetworkError>
        | QueryFiltersByQueryKey<GetNodesNetworkSchema, GetNodesNetworkData, TInfinite, GetNodesNetworkParameters, GetNodesNetworkError>,
      options?: RefetchOptions
    ): Promise<void>;
    /** @summary Get a list of nodes (api/rpc) for a specific network. */
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetNodesNetworkSchema, GetNodesNetworkData, TInfinite, GetNodesNetworkParameters, GetNodesNetworkError>
        | QueryFiltersByQueryKey<GetNodesNetworkSchema, GetNodesNetworkData, TInfinite, GetNodesNetworkParameters, GetNodesNetworkError>
    ): void;
    /** @summary Get a list of nodes (api/rpc) for a specific network. */
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetNodesNetworkSchema, GetNodesNetworkData, TInfinite, GetNodesNetworkParameters, GetNodesNetworkError>
        | QueryFiltersByQueryKey<GetNodesNetworkSchema, GetNodesNetworkData, TInfinite, GetNodesNetworkParameters, GetNodesNetworkError>,
      options?: ResetOptions
    ): Promise<void>;
    /** @summary Get a list of nodes (api/rpc) for a specific network. */
    setInfiniteQueryData(
      parameters: DeepReadonly<GetNodesNetworkParameters> | ServiceOperationInfiniteQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetNodesNetworkData, GetNodesNetworkParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetNodesNetworkData, GetNodesNetworkParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetNodesNetworkData, GetNodesNetworkParameters> | undefined;
    /** @summary Get a list of nodes (api/rpc) for a specific network. */
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetNodesNetworkSchema, GetNodesNetworkData, TInfinite, GetNodesNetworkParameters, GetNodesNetworkError>
        | QueryFiltersByQueryKey<GetNodesNetworkSchema, GetNodesNetworkData, TInfinite, GetNodesNetworkParameters, GetNodesNetworkError>,
      updater: Updater<NoInfer<GetNodesNetworkData> | undefined, NoInfer<GetNodesNetworkData> | undefined>,
      options?: SetDataOptions
    ): Array<GetNodesNetworkData | undefined>;
    /** @summary Get a list of nodes (api/rpc) for a specific network. */
    setQueryData(
      parameters: DeepReadonly<GetNodesNetworkParameters> | ServiceOperationQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters>,
      updater: Updater<NoInfer<GetNodesNetworkData> | undefined, NoInfer<DeepReadonly<GetNodesNetworkData>> | undefined>,
      options?: SetDataOptions
    ): GetNodesNetworkData | undefined;
    /** @summary Get a list of nodes (api/rpc) for a specific network. */
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetNodesNetworkParameters>
    ): ServiceOperationInfiniteQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of nodes (api/rpc) for a specific network.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getNodesNetwork.useInfiniteQuery({
     *     path: {
     *         network: network
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetNodesNetworkParameters,
      TQueryFnData = GetNodesNetworkData,
      TData = OperationInfiniteData<TQueryFnData, GetNodesNetworkParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters> | DeepReadonly<GetNodesNetworkParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetNodesNetworkError,
          TData,
          ServiceOperationInfiniteQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetNodesNetworkError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @summary Get a list of nodes (api/rpc) for a specific network.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getNodesNetwork.useInfiniteQuery({
     *     path: {
     *         network: network
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetNodesNetworkParameters,
      TQueryFnData = GetNodesNetworkData,
      TData = OperationInfiniteData<TQueryFnData, GetNodesNetworkParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters> | DeepReadonly<GetNodesNetworkParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetNodesNetworkError,
          TData,
          ServiceOperationInfiniteQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetNodesNetworkData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetNodesNetworkError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @summary Get a list of nodes (api/rpc) for a specific network.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getNodesNetworkTotal = qraft.v1Service.getNodesNetwork.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getNodesNetworkByParametersTotal = qraft.v1Service.getNodesNetwork.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             network: network
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetNodesNetworkSchema, GetNodesNetworkData, TInfinite, GetNodesNetworkParameters, GetNodesNetworkError>
        | QueryFiltersByQueryKey<GetNodesNetworkSchema, GetNodesNetworkData, TInfinite, GetNodesNetworkParameters, GetNodesNetworkError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @summary Get a list of nodes (api/rpc) for a specific network.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getNodesNetworkResults = qraft.v1Service.getNodesNetwork.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 network: network1
     *             }
     *         },
     *         {
     *             path: {
     *                 network: network2
     *             }
     *         }
     *     ]
     * });
     * getNodesNetworkResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getNodesNetworkCombinedResults = qraft.v1Service.getNodesNetwork.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 network: network1
     *             }
     *         },
     *         {
     *             path: {
     *                 network: network2
     *             }
     *         }
     *     ]
     * });
     * getNodesNetworkCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetNodesNetworkSchema, GetNodesNetworkParameters, GetNodesNetworkData, GetNodesNetworkError>>,
      TCombinedResult = Array<UseQueryResult<GetNodesNetworkData, GetNodesNetworkError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetNodesNetworkData, GetNodesNetworkError>>) => TCombinedResult;
    }): TCombinedResult;
    /** @summary Get a list of nodes (api/rpc) for a specific network. */
    getQueryKey(parameters: DeepReadonly<GetNodesNetworkParameters>): ServiceOperationQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of nodes (api/rpc) for a specific network.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNodesNetwork.useQuery({
     *     path: {
     *         network: network
     *     }
     * })
     * ```
     */
    useQuery<TData = GetNodesNetworkData>(
      parameters: ServiceOperationQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters> | DeepReadonly<GetNodesNetworkParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetNodesNetworkData,
          GetNodesNetworkError,
          TData,
          ServiceOperationQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetNodesNetworkError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @summary Get a list of nodes (api/rpc) for a specific network.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNodesNetwork.useQuery({
     *     path: {
     *         network: network
     *     }
     * })
     * ```
     */
    useQuery<TData = GetNodesNetworkData>(
      parameters: ServiceOperationQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters> | DeepReadonly<GetNodesNetworkParameters>,
      options: Omit<
        DefinedInitialDataOptions<GetNodesNetworkData, GetNodesNetworkError, TData, ServiceOperationQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetNodesNetworkError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @summary Get a list of nodes (api/rpc) for a specific network.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getNodesNetwork.useSuspenseInfiniteQuery({
     *     path: {
     *         network: network
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetNodesNetworkParameters, TData = GetNodesNetworkData>(
      parameters: ServiceOperationInfiniteQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters> | DeepReadonly<GetNodesNetworkParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetNodesNetworkData,
          GetNodesNetworkError,
          OperationInfiniteData<TData, GetNodesNetworkParameters>,
          GetNodesNetworkData,
          ServiceOperationInfiniteQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetNodesNetworkData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetNodesNetworkParameters>, GetNodesNetworkError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @summary Get a list of nodes (api/rpc) for a specific network.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getNodesNetworkData = qraft.v1Service.getNodesNetwork.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 network: network1
     *             }
     *         },
     *         {
     *             path: {
     *                 network: network2
     *             }
     *         }
     *     ]
     * });
     * getNodesNetworkResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getNodesNetworkCombinedData = qraft.v1Service.getNodesNetwork.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 network: network1
     *             }
     *         },
     *         {
     *             path: {
     *                 network: network2
     *             }
     *         }
     *     ]
     * });
     * getNodesNetworkCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetNodesNetworkSchema, GetNodesNetworkParameters, GetNodesNetworkData, GetNodesNetworkError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetNodesNetworkData, GetNodesNetworkError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetNodesNetworkData, GetNodesNetworkError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @summary Get a list of nodes (api/rpc) for a specific network.
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getNodesNetwork.useSuspenseQuery({
     *     path: {
     *         network: network
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetNodesNetworkData>(
      parameters: ServiceOperationQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters> | DeepReadonly<GetNodesNetworkParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<GetNodesNetworkData, GetNodesNetworkError, TData, ServiceOperationQueryKey<GetNodesNetworkSchema, GetNodesNetworkParameters>>,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetNodesNetworkError | Error>;
    schema: GetNodesNetworkSchema;
    types: {
      parameters: GetNodesNetworkParameters;
      data: GetNodesNetworkData;
      error: GetNodesNetworkError;
    };
  };
  createAlert: {
    /**/
    getMutationKey(parameters: DeepReadonly<CreateAlertParameters> | void): ServiceOperationMutationKey<CreateAlertSchema, CreateAlertParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createAlert.useMutation({
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createAlert.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends CreateAlertBody, TContext = unknown>(
      parameters: DeepReadonly<CreateAlertParameters>,
      options?: ServiceOperationUseMutationOptions<CreateAlertSchema, CreateAlertData, CreateAlertParameters, TVariables, CreateAlertError | Error, TContext>
    ): UseMutationResult<CreateAlertData, CreateAlertError | Error, TVariables, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createAlert.useMutation({
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createAlert.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<CreateAlertBody, CreateAlertParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<CreateAlertSchema, CreateAlertData, CreateAlertParameters, TVariables, CreateAlertError | Error, TContext>
    ): UseMutationResult<CreateAlertData, CreateAlertError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const createAlertTotal = qraft.v1Service.createAlert.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const createAlertTotal = qraft.v1Service.createAlert.useIsMutating({
     *     parameters: {
     *         header: {
     *             Authorization: authorization
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<CreateAlertBody, CreateAlertData, CreateAlertParameters, CreateAlertError | Error, TContext>
        | MutationFiltersByMutationKey<CreateAlertSchema, CreateAlertBody, CreateAlertData, CreateAlertParameters, CreateAlertError | Error, TContext>
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<CreateAlertBody, CreateAlertData, CreateAlertParameters, CreateAlertError | Error, TContext>
        | MutationFiltersByMutationKey<CreateAlertSchema, CreateAlertBody, CreateAlertData, CreateAlertParameters, CreateAlertError | Error, TContext>
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<CreateAlertBody, CreateAlertParameters>,
      client?: (
        schema: CreateAlertSchema,
        options: ServiceOperationMutationFnOptions<CreateAlertBody, CreateAlertParameters>
      ) => Promise<RequestFnResponse<CreateAlertData, CreateAlertError>>
    ): Promise<RequestFnResponse<CreateAlertData, CreateAlertError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const createAlertPendingMutationVariables = qraft.v1Service.createAlert.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const createAlertMutationData = qraft.v1Service.createAlert.useMutationState({
     *     filters: {
     *         parameters: {
     *             header: {
     *                 Authorization: authorization
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<CreateAlertData, CreateAlertError | Error, MutationVariables<CreateAlertBody, CreateAlertParameters>, TContext>
    >(options?: {
      filters?:
        | MutationFiltersByParameters<CreateAlertBody, CreateAlertData, CreateAlertParameters, CreateAlertError | Error, TContext>
        | MutationFiltersByMutationKey<CreateAlertSchema, CreateAlertBody, CreateAlertData, CreateAlertParameters, CreateAlertError | Error, TContext>;
      select?: (mutation: Mutation<CreateAlertData, CreateAlertError | Error, MutationVariables<CreateAlertBody, CreateAlertParameters>, TContext>) => TResult;
    }): Array<TResult>;
    schema: CreateAlertSchema;
    types: {
      parameters: CreateAlertParameters;
      data: CreateAlertData;
      error: CreateAlertError;
      body: CreateAlertBody;
    };
  };
  getAlerts: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>
        | QueryFiltersByQueryKey<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(parameters: DeepReadonly<GetAlertsParameters> | void): ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlerts.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlerts.useQuery({
     *     query: {
     *         limit: limit
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAlertsData>(
      parameters: ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters> | (DeepReadonly<GetAlertsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetAlertsData, GetAlertsError, TData, ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetAlertsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlerts.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlerts.useQuery({
     *     query: {
     *         limit: limit
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAlertsData>(
      parameters: ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters> | (DeepReadonly<GetAlertsParameters> | void),
      options: Omit<DefinedInitialDataOptions<GetAlertsData, GetAlertsError, TData, ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters>>, "queryKey">
    ): DefinedUseQueryResult<TData, GetAlertsError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetAlertsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<GetAlertsSchema, GetAlertsData, GetAlertsParameters, DeepReadonly<TPageParam>, GetAlertsError> | void
    ): Promise<OperationInfiniteData<GetAlertsData, GetAlertsParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetAlertsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<GetAlertsSchema, GetAlertsData, GetAlertsParameters, DeepReadonly<TPageParam>, GetAlertsError> | void
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetAlertsParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetAlertsSchema,
        GetAlertsData,
        GetAlertsParameters,
        DeepReadonly<TPageParam>,
        GetAlertsError
      > | void
    ): Promise<OperationInfiniteData<GetAlertsData, GetAlertsParameters>>;
    /**/
    fetchQuery(options: ServiceOperationFetchQueryOptions<GetAlertsSchema, GetAlertsData, GetAlertsParameters, GetAlertsError> | void): Promise<GetAlertsData>;
    /**/
    prefetchQuery(options: ServiceOperationFetchQueryOptions<GetAlertsSchema, GetAlertsData, GetAlertsParameters, GetAlertsError> | void): Promise<void>;
    /**/
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetAlertsSchema, GetAlertsData, GetAlertsParameters, GetAlertsError> | void
    ): Promise<GetAlertsData>;
    /**/
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetAlertsSchema, GetAlertsParameters> | (DeepReadonly<GetAlertsParameters> | void)
    ): OperationInfiniteData<GetAlertsData, GetAlertsParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>
        | QueryFiltersByQueryKey<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetAlertsSchema, GetAlertsParameters>,
            data: NoInfer<OperationInfiniteData<GetAlertsData, GetAlertsParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters>, data: GetAlertsData | undefined]>;
    /**/
    getQueryData(
      parameters: ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters> | (DeepReadonly<GetAlertsParameters> | void)
    ): GetAlertsData | undefined;
    /**/
    getQueryState(
      parameters: ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters> | (DeepReadonly<GetAlertsParameters> | void)
    ): QueryState<GetAlertsData, GetAlertsError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters: DeepReadonly<GetAlertsParameters> | ServiceOperationInfiniteQueryKey<GetAlertsSchema, GetAlertsParameters> | void
    ): QueryState<OperationInfiniteData<GetAlertsData, GetAlertsParameters>, GetAlertsError> | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>
        | QueryFiltersByQueryKey<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetAlertsSchema, GetAlertsParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetAlertsParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetAlertsSchema,
        options: {
          parameters: GetAlertsParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetAlertsData, GetAlertsError>>
    ): Promise<RequestFnResponse<GetAlertsData, GetAlertsError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>
        | QueryFiltersByQueryKey<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>
        | QueryFiltersByQueryKey<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>
        | QueryFiltersByQueryKey<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters: (DeepReadonly<GetAlertsParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetAlertsSchema, GetAlertsParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetAlertsData, GetAlertsParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetAlertsData, GetAlertsParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetAlertsData, GetAlertsParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>
        | QueryFiltersByQueryKey<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>,
      updater: Updater<NoInfer<GetAlertsData> | undefined, NoInfer<GetAlertsData> | undefined>,
      options?: SetDataOptions
    ): Array<GetAlertsData | undefined>;
    /**/
    setQueryData(
      parameters: (DeepReadonly<GetAlertsParameters> | undefined) | ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters>,
      updater: Updater<NoInfer<GetAlertsData> | undefined, NoInfer<DeepReadonly<GetAlertsData>> | undefined>,
      options?: SetDataOptions
    ): GetAlertsData | undefined;
    /**/
    getInfiniteQueryKey(parameters: DeepReadonly<GetAlertsParameters> | void): ServiceOperationInfiniteQueryKey<GetAlertsSchema, GetAlertsParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAlerts.useInfiniteQuery({
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             limit: initialLimit
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<TPageParam extends GetAlertsParameters, TQueryFnData = GetAlertsData, TData = OperationInfiniteData<TQueryFnData, GetAlertsParameters>>(
      parameters: ServiceOperationInfiniteQueryKey<GetAlertsSchema, GetAlertsParameters> | (DeepReadonly<GetAlertsParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetAlertsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetAlertsSchema, GetAlertsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetAlertsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAlerts.useInfiniteQuery({
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             limit: initialLimit
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<TPageParam extends GetAlertsParameters, TQueryFnData = GetAlertsData, TData = OperationInfiniteData<TQueryFnData, GetAlertsParameters>>(
      parameters: ServiceOperationInfiniteQueryKey<GetAlertsSchema, GetAlertsParameters> | (DeepReadonly<GetAlertsParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetAlertsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetAlertsSchema, GetAlertsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetAlertsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetAlertsError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getAlertsTotal = qraft.v1Service.getAlerts.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getAlertsByParametersTotal = qraft.v1Service.getAlerts.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         query: {
     *             limit: limit
     *         },
     *         header: {
     *             Authorization: authorization
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>
        | QueryFiltersByQueryKey<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getAlertsResults = qraft.v1Service.getAlerts.useQueries({
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getAlertsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getAlertsCombinedResults = qraft.v1Service.getAlerts.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getAlertsCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetAlertsSchema, GetAlertsParameters, GetAlertsData, GetAlertsError>>,
      TCombinedResult = Array<UseQueryResult<GetAlertsData, GetAlertsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetAlertsData, GetAlertsError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(parameters: DeepReadonly<GetAlertsParameters> | void): ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlerts.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlerts.useQuery({
     *     query: {
     *         limit: limit
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAlertsData>(
      parameters: ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters> | (DeepReadonly<GetAlertsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetAlertsData, GetAlertsError, TData, ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetAlertsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlerts.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlerts.useQuery({
     *     query: {
     *         limit: limit
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAlertsData>(
      parameters: ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters> | (DeepReadonly<GetAlertsParameters> | void),
      options: Omit<DefinedInitialDataOptions<GetAlertsData, GetAlertsError, TData, ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters>>, "queryKey">
    ): DefinedUseQueryResult<TData, GetAlertsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAlerts.useSuspenseInfiniteQuery({
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             limit: initialLimit
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetAlertsParameters, TData = GetAlertsData>(
      parameters: ServiceOperationInfiniteQueryKey<GetAlertsSchema, GetAlertsParameters> | (DeepReadonly<GetAlertsParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetAlertsData,
          GetAlertsError,
          OperationInfiniteData<TData, GetAlertsParameters>,
          GetAlertsData,
          ServiceOperationInfiniteQueryKey<GetAlertsSchema, GetAlertsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetAlertsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetAlertsParameters>, GetAlertsError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getAlertsData = qraft.v1Service.getAlerts.useSuspenseQueries({
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getAlertsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getAlertsCombinedData = qraft.v1Service.getAlerts.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getAlertsCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetAlertsSchema, GetAlertsParameters, GetAlertsData, GetAlertsError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetAlertsData, GetAlertsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetAlertsData, GetAlertsError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getAlerts.useSuspenseQuery()
     * ```
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getAlerts.useSuspenseQuery({
     *     query: {
     *         limit: limit
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetAlertsData>(
      parameters: ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters> | (DeepReadonly<GetAlertsParameters> | void),
      options?: Omit<UseSuspenseQueryOptions<GetAlertsData, GetAlertsError, TData, ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters>>, "queryKey">
    ): UseSuspenseQueryResult<TData, GetAlertsError | Error>;
    schema: GetAlertsSchema;
    types: {
      parameters: GetAlertsParameters;
      data: GetAlertsData;
      error: GetAlertsError;
    };
  };
  getAlert: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(parameters: DeepReadonly<GetAlertParameters>): ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlert.useQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAlertData>(
      parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options?: Omit<UndefinedInitialDataOptions<GetAlertData, GetAlertError, TData, ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>>, "queryKey">
    ): UseQueryResult<TData, GetAlertError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlert.useQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAlertData>(
      parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options: Omit<DefinedInitialDataOptions<GetAlertData, GetAlertError, TData, ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>>, "queryKey">
    ): DefinedUseQueryResult<TData, GetAlertError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetAlertParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<GetAlertSchema, GetAlertData, GetAlertParameters, DeepReadonly<TPageParam>, GetAlertError>
    ): Promise<OperationInfiniteData<GetAlertData, GetAlertParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetAlertParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<GetAlertSchema, GetAlertData, GetAlertParameters, DeepReadonly<TPageParam>, GetAlertError>
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetAlertParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<GetAlertSchema, GetAlertData, GetAlertParameters, DeepReadonly<TPageParam>, GetAlertError>
    ): Promise<OperationInfiniteData<GetAlertData, GetAlertParameters>>;
    /**/
    fetchQuery(options: ServiceOperationFetchQueryOptions<GetAlertSchema, GetAlertData, GetAlertParameters, GetAlertError>): Promise<GetAlertData>;
    /**/
    prefetchQuery(options: ServiceOperationFetchQueryOptions<GetAlertSchema, GetAlertData, GetAlertParameters, GetAlertError>): Promise<void>;
    /**/
    ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetAlertSchema, GetAlertData, GetAlertParameters, GetAlertError>): Promise<GetAlertData>;
    /**/
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>
    ): OperationInfiniteData<GetAlertData, GetAlertParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>,
            data: NoInfer<OperationInfiniteData<GetAlertData, GetAlertParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>, data: GetAlertData | undefined]>;
    /**/
    getQueryData(parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>): GetAlertData | undefined;
    /**/
    getQueryState(
      parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>
    ): QueryState<GetAlertData, GetAlertError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters: DeepReadonly<GetAlertParameters> | ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>
    ): QueryState<OperationInfiniteData<GetAlertData, GetAlertParameters>, GetAlertError> | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options: QueryFnOptionsByQueryKey<GetAlertSchema, GetAlertParameters, TMeta, TSignal> | QueryFnOptionsByParameters<GetAlertParameters, TMeta, TSignal>,
      client?: (
        schema: GetAlertSchema,
        options: {
          parameters: GetAlertParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetAlertData, GetAlertError>>
    ): Promise<RequestFnResponse<GetAlertData, GetAlertError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters: DeepReadonly<GetAlertParameters> | ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetAlertData, GetAlertParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetAlertData, GetAlertParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetAlertData, GetAlertParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>,
      updater: Updater<NoInfer<GetAlertData> | undefined, NoInfer<GetAlertData> | undefined>,
      options?: SetDataOptions
    ): Array<GetAlertData | undefined>;
    /**/
    setQueryData(
      parameters: DeepReadonly<GetAlertParameters> | ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>,
      updater: Updater<NoInfer<GetAlertData> | undefined, NoInfer<DeepReadonly<GetAlertData>> | undefined>,
      options?: SetDataOptions
    ): GetAlertData | undefined;
    /**/
    getInfiniteQueryKey(parameters: DeepReadonly<GetAlertParameters>): ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAlert.useInfiniteQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<TPageParam extends GetAlertParameters, TQueryFnData = GetAlertData, TData = OperationInfiniteData<TQueryFnData, GetAlertParameters>>(
      parameters: ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetAlertError,
          TData,
          ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetAlertError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAlert.useInfiniteQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<TPageParam extends GetAlertParameters, TQueryFnData = GetAlertData, TData = OperationInfiniteData<TQueryFnData, GetAlertParameters>>(
      parameters: ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetAlertError,
          TData,
          ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetAlertData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetAlertError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getAlertTotal = qraft.v1Service.getAlert.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getAlertByParametersTotal = qraft.v1Service.getAlert.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             id: id
     *         },
     *         header: {
     *             Authorization: authorization
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getAlertResults = qraft.v1Service.getAlert.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getAlertResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getAlertCombinedResults = qraft.v1Service.getAlert.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getAlertCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetAlertSchema, GetAlertParameters, GetAlertData, GetAlertError>>,
      TCombinedResult = Array<UseQueryResult<GetAlertData, GetAlertError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetAlertData, GetAlertError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(parameters: DeepReadonly<GetAlertParameters>): ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlert.useQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAlertData>(
      parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options?: Omit<UndefinedInitialDataOptions<GetAlertData, GetAlertError, TData, ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>>, "queryKey">
    ): UseQueryResult<TData, GetAlertError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlert.useQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAlertData>(
      parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options: Omit<DefinedInitialDataOptions<GetAlertData, GetAlertError, TData, ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>>, "queryKey">
    ): DefinedUseQueryResult<TData, GetAlertError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAlert.useSuspenseInfiniteQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetAlertParameters, TData = GetAlertData>(
      parameters: ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetAlertData,
          GetAlertError,
          OperationInfiniteData<TData, GetAlertParameters>,
          GetAlertData,
          ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetAlertData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetAlertParameters>, GetAlertError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getAlertData = qraft.v1Service.getAlert.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getAlertResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getAlertCombinedData = qraft.v1Service.getAlert.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getAlertCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetAlertSchema, GetAlertParameters, GetAlertData, GetAlertError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetAlertData, GetAlertError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetAlertData, GetAlertError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getAlert.useSuspenseQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetAlertData>(
      parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options?: Omit<UseSuspenseQueryOptions<GetAlertData, GetAlertError, TData, ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>>, "queryKey">
    ): UseSuspenseQueryResult<TData, GetAlertError | Error>;
    schema: GetAlertSchema;
    types: {
      parameters: GetAlertParameters;
      data: GetAlertData;
      error: GetAlertError;
    };
  };
  patchAlert: {
    /**/
    getMutationKey(parameters: DeepReadonly<PatchAlertParameters> | void): ServiceOperationMutationKey<PatchAlertSchema, PatchAlertParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchAlert.useMutation({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchAlert.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends PatchAlertBody, TContext = unknown>(
      parameters: DeepReadonly<PatchAlertParameters>,
      options?: ServiceOperationUseMutationOptions<PatchAlertSchema, PatchAlertData, PatchAlertParameters, TVariables, PatchAlertError | Error, TContext>
    ): UseMutationResult<PatchAlertData, PatchAlertError | Error, TVariables, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchAlert.useMutation({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchAlert.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PatchAlertBody, PatchAlertParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<PatchAlertSchema, PatchAlertData, PatchAlertParameters, TVariables, PatchAlertError | Error, TContext>
    ): UseMutationResult<PatchAlertData, PatchAlertError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const patchAlertTotal = qraft.v1Service.patchAlert.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const patchAlertTotal = qraft.v1Service.patchAlert.useIsMutating({
     *     parameters: {
     *         path: {
     *             id: id
     *         },
     *         header: {
     *             Authorization: authorization
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<PatchAlertBody, PatchAlertData, PatchAlertParameters, PatchAlertError | Error, TContext>
        | MutationFiltersByMutationKey<PatchAlertSchema, PatchAlertBody, PatchAlertData, PatchAlertParameters, PatchAlertError | Error, TContext>
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<PatchAlertBody, PatchAlertData, PatchAlertParameters, PatchAlertError | Error, TContext>
        | MutationFiltersByMutationKey<PatchAlertSchema, PatchAlertBody, PatchAlertData, PatchAlertParameters, PatchAlertError | Error, TContext>
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<PatchAlertBody, PatchAlertParameters>,
      client?: (
        schema: PatchAlertSchema,
        options: ServiceOperationMutationFnOptions<PatchAlertBody, PatchAlertParameters>
      ) => Promise<RequestFnResponse<PatchAlertData, PatchAlertError>>
    ): Promise<RequestFnResponse<PatchAlertData, PatchAlertError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const patchAlertPendingMutationVariables = qraft.v1Service.patchAlert.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const patchAlertMutationData = qraft.v1Service.patchAlert.useMutationState({
     *     filters: {
     *         parameters: {
     *             path: {
     *                 id: id
     *             },
     *             header: {
     *                 Authorization: authorization
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<PatchAlertData, PatchAlertError | Error, MutationVariables<PatchAlertBody, PatchAlertParameters>, TContext>
    >(options?: {
      filters?:
        | MutationFiltersByParameters<PatchAlertBody, PatchAlertData, PatchAlertParameters, PatchAlertError | Error, TContext>
        | MutationFiltersByMutationKey<PatchAlertSchema, PatchAlertBody, PatchAlertData, PatchAlertParameters, PatchAlertError | Error, TContext>;
      select?: (mutation: Mutation<PatchAlertData, PatchAlertError | Error, MutationVariables<PatchAlertBody, PatchAlertParameters>, TContext>) => TResult;
    }): Array<TResult>;
    schema: PatchAlertSchema;
    types: {
      parameters: PatchAlertParameters;
      data: PatchAlertData;
      error: PatchAlertError;
      body: PatchAlertBody;
    };
  };
  deleteAlert: {
    /**/
    getMutationKey(parameters: DeepReadonly<DeleteAlertParameters> | void): ServiceOperationMutationKey<DeleteAlertSchema, DeleteAlertParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteAlert.useMutation({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteAlert.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends DeleteAlertBody, TContext = unknown>(
      parameters: DeepReadonly<DeleteAlertParameters>,
      options?: ServiceOperationUseMutationOptions<DeleteAlertSchema, DeleteAlertData, DeleteAlertParameters, TVariables, DeleteAlertError | Error, TContext>
    ): UseMutationResult<DeleteAlertData, DeleteAlertError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteAlert.useMutation({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteAlert.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<DeleteAlertBody, DeleteAlertParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<DeleteAlertSchema, DeleteAlertData, DeleteAlertParameters, TVariables, DeleteAlertError | Error, TContext>
    ): UseMutationResult<DeleteAlertData, DeleteAlertError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const deleteAlertTotal = qraft.v1Service.deleteAlert.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const deleteAlertTotal = qraft.v1Service.deleteAlert.useIsMutating({
     *     parameters: {
     *         path: {
     *             id: id
     *         },
     *         header: {
     *             Authorization: authorization
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<DeleteAlertBody, DeleteAlertData, DeleteAlertParameters, DeleteAlertError | Error, TContext>
        | MutationFiltersByMutationKey<DeleteAlertSchema, DeleteAlertBody, DeleteAlertData, DeleteAlertParameters, DeleteAlertError | Error, TContext>
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<DeleteAlertBody, DeleteAlertData, DeleteAlertParameters, DeleteAlertError | Error, TContext>
        | MutationFiltersByMutationKey<DeleteAlertSchema, DeleteAlertBody, DeleteAlertData, DeleteAlertParameters, DeleteAlertError | Error, TContext>
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<DeleteAlertBody, DeleteAlertParameters>,
      client?: (
        schema: DeleteAlertSchema,
        options: ServiceOperationMutationFnOptions<DeleteAlertBody, DeleteAlertParameters>
      ) => Promise<RequestFnResponse<DeleteAlertData, DeleteAlertError>>
    ): Promise<RequestFnResponse<DeleteAlertData, DeleteAlertError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const deleteAlertPendingMutationVariables = qraft.v1Service.deleteAlert.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const deleteAlertMutationData = qraft.v1Service.deleteAlert.useMutationState({
     *     filters: {
     *         parameters: {
     *             path: {
     *                 id: id
     *             },
     *             header: {
     *                 Authorization: authorization
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<DeleteAlertData, DeleteAlertError | Error, MutationVariables<DeleteAlertBody, DeleteAlertParameters>, TContext>
    >(options?: {
      filters?:
        | MutationFiltersByParameters<DeleteAlertBody, DeleteAlertData, DeleteAlertParameters, DeleteAlertError | Error, TContext>
        | MutationFiltersByMutationKey<DeleteAlertSchema, DeleteAlertBody, DeleteAlertData, DeleteAlertParameters, DeleteAlertError | Error, TContext>;
      select?: (mutation: Mutation<DeleteAlertData, DeleteAlertError | Error, MutationVariables<DeleteAlertBody, DeleteAlertParameters>, TContext>) => TResult;
    }): Array<TResult>;
    schema: DeleteAlertSchema;
    types: {
      parameters: DeleteAlertParameters;
      data: DeleteAlertData;
      error: DeleteAlertError;
      body: DeleteAlertBody;
    };
  };
  createNotificationChannel: {
    /**/
    getMutationKey(
      parameters: DeepReadonly<CreateNotificationChannelParameters> | void
    ): ServiceOperationMutationKey<CreateNotificationChannelSchema, CreateNotificationChannelParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createNotificationChannel.useMutation({
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createNotificationChannel.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends CreateNotificationChannelBody, TContext = unknown>(
      parameters: DeepReadonly<CreateNotificationChannelParameters>,
      options?: ServiceOperationUseMutationOptions<
        CreateNotificationChannelSchema,
        CreateNotificationChannelData,
        CreateNotificationChannelParameters,
        TVariables,
        CreateNotificationChannelError | Error,
        TContext
      >
    ): UseMutationResult<CreateNotificationChannelData, CreateNotificationChannelError | Error, TVariables, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createNotificationChannel.useMutation({
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createNotificationChannel.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<CreateNotificationChannelBody, CreateNotificationChannelParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        CreateNotificationChannelSchema,
        CreateNotificationChannelData,
        CreateNotificationChannelParameters,
        TVariables,
        CreateNotificationChannelError | Error,
        TContext
      >
    ): UseMutationResult<CreateNotificationChannelData, CreateNotificationChannelError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const createNotificationChannelTotal = qraft.v1Service.createNotificationChannel.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const createNotificationChannelTotal = qraft.v1Service.createNotificationChannel.useIsMutating({
     *     parameters: {
     *         header: {
     *             Authorization: authorization
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<
            CreateNotificationChannelBody,
            CreateNotificationChannelData,
            CreateNotificationChannelParameters,
            CreateNotificationChannelError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            CreateNotificationChannelSchema,
            CreateNotificationChannelBody,
            CreateNotificationChannelData,
            CreateNotificationChannelParameters,
            CreateNotificationChannelError | Error,
            TContext
          >
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<
            CreateNotificationChannelBody,
            CreateNotificationChannelData,
            CreateNotificationChannelParameters,
            CreateNotificationChannelError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            CreateNotificationChannelSchema,
            CreateNotificationChannelBody,
            CreateNotificationChannelData,
            CreateNotificationChannelParameters,
            CreateNotificationChannelError | Error,
            TContext
          >
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<CreateNotificationChannelBody, CreateNotificationChannelParameters>,
      client?: (
        schema: CreateNotificationChannelSchema,
        options: ServiceOperationMutationFnOptions<CreateNotificationChannelBody, CreateNotificationChannelParameters>
      ) => Promise<RequestFnResponse<CreateNotificationChannelData, CreateNotificationChannelError>>
    ): Promise<RequestFnResponse<CreateNotificationChannelData, CreateNotificationChannelError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const createNotificationChannelPendingMutationVariables = qraft.v1Service.createNotificationChannel.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const createNotificationChannelMutationData = qraft.v1Service.createNotificationChannel.useMutationState({
     *     filters: {
     *         parameters: {
     *             header: {
     *                 Authorization: authorization
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        CreateNotificationChannelData,
        CreateNotificationChannelError | Error,
        MutationVariables<CreateNotificationChannelBody, CreateNotificationChannelParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<
            CreateNotificationChannelBody,
            CreateNotificationChannelData,
            CreateNotificationChannelParameters,
            CreateNotificationChannelError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            CreateNotificationChannelSchema,
            CreateNotificationChannelBody,
            CreateNotificationChannelData,
            CreateNotificationChannelParameters,
            CreateNotificationChannelError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          CreateNotificationChannelData,
          CreateNotificationChannelError | Error,
          MutationVariables<CreateNotificationChannelBody, CreateNotificationChannelParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: CreateNotificationChannelSchema;
    types: {
      parameters: CreateNotificationChannelParameters;
      data: CreateNotificationChannelData;
      error: CreateNotificationChannelError;
      body: CreateNotificationChannelBody;
    };
  };
  getNotificationChannels: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(
      parameters: DeepReadonly<GetNotificationChannelsParameters> | void
    ): ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNotificationChannels.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNotificationChannels.useQuery({
     *     query: {
     *         limit: limit
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetNotificationChannelsData>(
      parameters:
        | ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        | (DeepReadonly<GetNotificationChannelsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetNotificationChannelsData,
          GetNotificationChannelsError,
          TData,
          ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetNotificationChannelsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNotificationChannels.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNotificationChannels.useQuery({
     *     query: {
     *         limit: limit
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetNotificationChannelsData>(
      parameters:
        | ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        | (DeepReadonly<GetNotificationChannelsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetNotificationChannelsData,
          GetNotificationChannelsError,
          TData,
          ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetNotificationChannelsError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetNotificationChannelsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetNotificationChannelsSchema,
        GetNotificationChannelsData,
        GetNotificationChannelsParameters,
        DeepReadonly<TPageParam>,
        GetNotificationChannelsError
      > | void
    ): Promise<OperationInfiniteData<GetNotificationChannelsData, GetNotificationChannelsParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetNotificationChannelsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetNotificationChannelsSchema,
        GetNotificationChannelsData,
        GetNotificationChannelsParameters,
        DeepReadonly<TPageParam>,
        GetNotificationChannelsError
      > | void
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetNotificationChannelsParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetNotificationChannelsSchema,
        GetNotificationChannelsData,
        GetNotificationChannelsParameters,
        DeepReadonly<TPageParam>,
        GetNotificationChannelsError
      > | void
    ): Promise<OperationInfiniteData<GetNotificationChannelsData, GetNotificationChannelsParameters>>;
    /**/
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetNotificationChannelsSchema,
        GetNotificationChannelsData,
        GetNotificationChannelsParameters,
        GetNotificationChannelsError
      > | void
    ): Promise<GetNotificationChannelsData>;
    /**/
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetNotificationChannelsSchema,
        GetNotificationChannelsData,
        GetNotificationChannelsParameters,
        GetNotificationChannelsError
      > | void
    ): Promise<void>;
    /**/
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetNotificationChannelsSchema,
        GetNotificationChannelsData,
        GetNotificationChannelsParameters,
        GetNotificationChannelsError
      > | void
    ): Promise<GetNotificationChannelsData>;
    /**/
    getInfiniteQueryData(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        | (DeepReadonly<GetNotificationChannelsParameters> | void)
    ): OperationInfiniteData<GetNotificationChannelsData, GetNotificationChannelsParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>,
            data: NoInfer<OperationInfiniteData<GetNotificationChannelsData, GetNotificationChannelsParameters>> | undefined
          ]
        >
      : Array<
          [queryKey: ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>, data: GetNotificationChannelsData | undefined]
        >;
    /**/
    getQueryData(
      parameters:
        | ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        | (DeepReadonly<GetNotificationChannelsParameters> | void)
    ): GetNotificationChannelsData | undefined;
    /**/
    getQueryState(
      parameters:
        | ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        | (DeepReadonly<GetNotificationChannelsParameters> | void)
    ): QueryState<GetNotificationChannelsData, GetNotificationChannelsError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters:
        | DeepReadonly<GetNotificationChannelsParameters>
        | ServiceOperationInfiniteQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        | void
    ): QueryState<OperationInfiniteData<GetNotificationChannelsData, GetNotificationChannelsParameters>, GetNotificationChannelsError> | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<
        GetNotificationChannelsSchema,
        GetNotificationChannelsData,
        TInfinite,
        GetNotificationChannelsParameters,
        GetNotificationChannelsError
      >,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetNotificationChannelsParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetNotificationChannelsSchema,
        options: {
          parameters: GetNotificationChannelsParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetNotificationChannelsData, GetNotificationChannelsError>>
    ): Promise<RequestFnResponse<GetNotificationChannelsData, GetNotificationChannelsError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters:
        | (DeepReadonly<GetNotificationChannelsParameters> | undefined)
        | ServiceOperationInfiniteQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetNotificationChannelsData, GetNotificationChannelsParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetNotificationChannelsData, GetNotificationChannelsParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetNotificationChannelsData, GetNotificationChannelsParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >,
      updater: Updater<NoInfer<GetNotificationChannelsData> | undefined, NoInfer<GetNotificationChannelsData> | undefined>,
      options?: SetDataOptions
    ): Array<GetNotificationChannelsData | undefined>;
    /**/
    setQueryData(
      parameters:
        | (DeepReadonly<GetNotificationChannelsParameters> | undefined)
        | ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>,
      updater: Updater<NoInfer<GetNotificationChannelsData> | undefined, NoInfer<DeepReadonly<GetNotificationChannelsData>> | undefined>,
      options?: SetDataOptions
    ): GetNotificationChannelsData | undefined;
    /**/
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetNotificationChannelsParameters> | void
    ): ServiceOperationInfiniteQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getNotificationChannels.useInfiniteQuery({
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             limit: initialLimit
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetNotificationChannelsParameters,
      TQueryFnData = GetNotificationChannelsData,
      TData = OperationInfiniteData<TQueryFnData, GetNotificationChannelsParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        | (DeepReadonly<GetNotificationChannelsParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetNotificationChannelsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetNotificationChannelsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getNotificationChannels.useInfiniteQuery({
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             limit: initialLimit
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetNotificationChannelsParameters,
      TQueryFnData = GetNotificationChannelsData,
      TData = OperationInfiniteData<TQueryFnData, GetNotificationChannelsParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        | (DeepReadonly<GetNotificationChannelsParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetNotificationChannelsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetNotificationChannelsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetNotificationChannelsError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getNotificationChannelsTotal = qraft.v1Service.getNotificationChannels.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getNotificationChannelsByParametersTotal = qraft.v1Service.getNotificationChannels.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         query: {
     *             limit: limit
     *         },
     *         header: {
     *             Authorization: authorization
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getNotificationChannelsResults = qraft.v1Service.getNotificationChannels.useQueries({
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getNotificationChannelsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getNotificationChannelsCombinedResults = qraft.v1Service.getNotificationChannels.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getNotificationChannelsCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<
          GetNotificationChannelsSchema,
          GetNotificationChannelsParameters,
          GetNotificationChannelsData,
          GetNotificationChannelsError
        >
      >,
      TCombinedResult = Array<UseQueryResult<GetNotificationChannelsData, GetNotificationChannelsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetNotificationChannelsData, GetNotificationChannelsError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(
      parameters: DeepReadonly<GetNotificationChannelsParameters> | void
    ): ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNotificationChannels.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNotificationChannels.useQuery({
     *     query: {
     *         limit: limit
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetNotificationChannelsData>(
      parameters:
        | ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        | (DeepReadonly<GetNotificationChannelsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetNotificationChannelsData,
          GetNotificationChannelsError,
          TData,
          ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetNotificationChannelsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNotificationChannels.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNotificationChannels.useQuery({
     *     query: {
     *         limit: limit
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetNotificationChannelsData>(
      parameters:
        | ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        | (DeepReadonly<GetNotificationChannelsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetNotificationChannelsData,
          GetNotificationChannelsError,
          TData,
          ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetNotificationChannelsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getNotificationChannels.useSuspenseInfiniteQuery({
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             limit: initialLimit
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetNotificationChannelsParameters, TData = GetNotificationChannelsData>(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        | (DeepReadonly<GetNotificationChannelsParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetNotificationChannelsData,
          GetNotificationChannelsError,
          OperationInfiniteData<TData, GetNotificationChannelsParameters>,
          GetNotificationChannelsData,
          ServiceOperationInfiniteQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetNotificationChannelsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetNotificationChannelsParameters>, GetNotificationChannelsError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getNotificationChannelsData = qraft.v1Service.getNotificationChannels.useSuspenseQueries({
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getNotificationChannelsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getNotificationChannelsCombinedData = qraft.v1Service.getNotificationChannels.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getNotificationChannelsCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<
          GetNotificationChannelsSchema,
          GetNotificationChannelsParameters,
          GetNotificationChannelsData,
          GetNotificationChannelsError
        >
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetNotificationChannelsData, GetNotificationChannelsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetNotificationChannelsData, GetNotificationChannelsError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getNotificationChannels.useSuspenseQuery()
     * ```
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getNotificationChannels.useSuspenseQuery({
     *     query: {
     *         limit: limit
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetNotificationChannelsData>(
      parameters:
        | ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        | (DeepReadonly<GetNotificationChannelsParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<
          GetNotificationChannelsData,
          GetNotificationChannelsError,
          TData,
          ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetNotificationChannelsError | Error>;
    schema: GetNotificationChannelsSchema;
    types: {
      parameters: GetNotificationChannelsParameters;
      data: GetNotificationChannelsData;
      error: GetNotificationChannelsError;
    };
  };
  createDefaultChannel: {
    /**/
    getMutationKey(
      parameters: DeepReadonly<CreateDefaultChannelParameters> | void
    ): ServiceOperationMutationKey<CreateDefaultChannelSchema, CreateDefaultChannelParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createDefaultChannel.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createDefaultChannel.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends CreateDefaultChannelBody, TContext = unknown>(
      parameters: DeepReadonly<CreateDefaultChannelParameters>,
      options?: ServiceOperationUseMutationOptions<
        CreateDefaultChannelSchema,
        CreateDefaultChannelData,
        CreateDefaultChannelParameters,
        TVariables,
        CreateDefaultChannelError | Error,
        TContext
      >
    ): UseMutationResult<CreateDefaultChannelData, CreateDefaultChannelError | Error, TVariables, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createDefaultChannel.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createDefaultChannel.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<CreateDefaultChannelBody, CreateDefaultChannelParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        CreateDefaultChannelSchema,
        CreateDefaultChannelData,
        CreateDefaultChannelParameters,
        TVariables,
        CreateDefaultChannelError | Error,
        TContext
      >
    ): UseMutationResult<CreateDefaultChannelData, CreateDefaultChannelError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const createDefaultChannelTotal = qraft.v1Service.createDefaultChannel.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const createDefaultChannelTotal = qraft.v1Service.createDefaultChannel.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<
            CreateDefaultChannelBody,
            CreateDefaultChannelData,
            CreateDefaultChannelParameters,
            CreateDefaultChannelError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            CreateDefaultChannelSchema,
            CreateDefaultChannelBody,
            CreateDefaultChannelData,
            CreateDefaultChannelParameters,
            CreateDefaultChannelError | Error,
            TContext
          >
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<
            CreateDefaultChannelBody,
            CreateDefaultChannelData,
            CreateDefaultChannelParameters,
            CreateDefaultChannelError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            CreateDefaultChannelSchema,
            CreateDefaultChannelBody,
            CreateDefaultChannelData,
            CreateDefaultChannelParameters,
            CreateDefaultChannelError | Error,
            TContext
          >
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<CreateDefaultChannelBody, CreateDefaultChannelParameters>,
      client?: (
        schema: CreateDefaultChannelSchema,
        options: ServiceOperationMutationFnOptions<CreateDefaultChannelBody, CreateDefaultChannelParameters>
      ) => Promise<RequestFnResponse<CreateDefaultChannelData, CreateDefaultChannelError>>
    ): Promise<RequestFnResponse<CreateDefaultChannelData, CreateDefaultChannelError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const createDefaultChannelPendingMutationVariables = qraft.v1Service.createDefaultChannel.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const createDefaultChannelMutationData = qraft.v1Service.createDefaultChannel.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        CreateDefaultChannelData,
        CreateDefaultChannelError | Error,
        MutationVariables<CreateDefaultChannelBody, CreateDefaultChannelParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<
            CreateDefaultChannelBody,
            CreateDefaultChannelData,
            CreateDefaultChannelParameters,
            CreateDefaultChannelError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            CreateDefaultChannelSchema,
            CreateDefaultChannelBody,
            CreateDefaultChannelData,
            CreateDefaultChannelParameters,
            CreateDefaultChannelError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          CreateDefaultChannelData,
          CreateDefaultChannelError | Error,
          MutationVariables<CreateDefaultChannelBody, CreateDefaultChannelParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: CreateDefaultChannelSchema;
    types: {
      parameters: CreateDefaultChannelParameters;
      data: CreateDefaultChannelData;
      error: CreateDefaultChannelError;
      body: CreateDefaultChannelBody;
    };
  };
  getNotificationChannel: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(
      parameters: DeepReadonly<GetNotificationChannelParameters>
    ): ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNotificationChannel.useQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetNotificationChannelData>(
      parameters: ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters> | DeepReadonly<GetNotificationChannelParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetNotificationChannelData,
          GetNotificationChannelError,
          TData,
          ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetNotificationChannelError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNotificationChannel.useQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetNotificationChannelData>(
      parameters: ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters> | DeepReadonly<GetNotificationChannelParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetNotificationChannelData,
          GetNotificationChannelError,
          TData,
          ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetNotificationChannelError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetNotificationChannelParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetNotificationChannelSchema,
        GetNotificationChannelData,
        GetNotificationChannelParameters,
        DeepReadonly<TPageParam>,
        GetNotificationChannelError
      >
    ): Promise<OperationInfiniteData<GetNotificationChannelData, GetNotificationChannelParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetNotificationChannelParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetNotificationChannelSchema,
        GetNotificationChannelData,
        GetNotificationChannelParameters,
        DeepReadonly<TPageParam>,
        GetNotificationChannelError
      >
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetNotificationChannelParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetNotificationChannelSchema,
        GetNotificationChannelData,
        GetNotificationChannelParameters,
        DeepReadonly<TPageParam>,
        GetNotificationChannelError
      >
    ): Promise<OperationInfiniteData<GetNotificationChannelData, GetNotificationChannelParameters>>;
    /**/
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetNotificationChannelSchema,
        GetNotificationChannelData,
        GetNotificationChannelParameters,
        GetNotificationChannelError
      >
    ): Promise<GetNotificationChannelData>;
    /**/
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetNotificationChannelSchema,
        GetNotificationChannelData,
        GetNotificationChannelParameters,
        GetNotificationChannelError
      >
    ): Promise<void>;
    /**/
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetNotificationChannelSchema,
        GetNotificationChannelData,
        GetNotificationChannelParameters,
        GetNotificationChannelError
      >
    ): Promise<GetNotificationChannelData>;
    /**/
    getInfiniteQueryData(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>
        | DeepReadonly<GetNotificationChannelParameters>
    ): OperationInfiniteData<GetNotificationChannelData, GetNotificationChannelParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>,
            data: NoInfer<OperationInfiniteData<GetNotificationChannelData, GetNotificationChannelParameters>> | undefined
          ]
        >
      : Array<
          [queryKey: ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>, data: GetNotificationChannelData | undefined]
        >;
    /**/
    getQueryData(
      parameters: ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters> | DeepReadonly<GetNotificationChannelParameters>
    ): GetNotificationChannelData | undefined;
    /**/
    getQueryState(
      parameters: ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters> | DeepReadonly<GetNotificationChannelParameters>
    ): QueryState<GetNotificationChannelData, GetNotificationChannelError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters:
        | DeepReadonly<GetNotificationChannelParameters>
        | ServiceOperationInfiniteQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>
    ): QueryState<OperationInfiniteData<GetNotificationChannelData, GetNotificationChannelParameters>, GetNotificationChannelError> | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<
        GetNotificationChannelSchema,
        GetNotificationChannelData,
        TInfinite,
        GetNotificationChannelParameters,
        GetNotificationChannelError
      >,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetNotificationChannelParameters, TMeta, TSignal>,
      client?: (
        schema: GetNotificationChannelSchema,
        options: {
          parameters: GetNotificationChannelParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetNotificationChannelData, GetNotificationChannelError>>
    ): Promise<RequestFnResponse<GetNotificationChannelData, GetNotificationChannelError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters:
        | DeepReadonly<GetNotificationChannelParameters>
        | ServiceOperationInfiniteQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetNotificationChannelData, GetNotificationChannelParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetNotificationChannelData, GetNotificationChannelParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetNotificationChannelData, GetNotificationChannelParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >,
      updater: Updater<NoInfer<GetNotificationChannelData> | undefined, NoInfer<GetNotificationChannelData> | undefined>,
      options?: SetDataOptions
    ): Array<GetNotificationChannelData | undefined>;
    /**/
    setQueryData(
      parameters: DeepReadonly<GetNotificationChannelParameters> | ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>,
      updater: Updater<NoInfer<GetNotificationChannelData> | undefined, NoInfer<DeepReadonly<GetNotificationChannelData>> | undefined>,
      options?: SetDataOptions
    ): GetNotificationChannelData | undefined;
    /**/
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetNotificationChannelParameters>
    ): ServiceOperationInfiniteQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getNotificationChannel.useInfiniteQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetNotificationChannelParameters,
      TQueryFnData = GetNotificationChannelData,
      TData = OperationInfiniteData<TQueryFnData, GetNotificationChannelParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>
        | DeepReadonly<GetNotificationChannelParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetNotificationChannelError,
          TData,
          ServiceOperationInfiniteQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetNotificationChannelError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getNotificationChannel.useInfiniteQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetNotificationChannelParameters,
      TQueryFnData = GetNotificationChannelData,
      TData = OperationInfiniteData<TQueryFnData, GetNotificationChannelParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>
        | DeepReadonly<GetNotificationChannelParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetNotificationChannelError,
          TData,
          ServiceOperationInfiniteQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetNotificationChannelData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetNotificationChannelError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getNotificationChannelTotal = qraft.v1Service.getNotificationChannel.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getNotificationChannelByParametersTotal = qraft.v1Service.getNotificationChannel.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             id: id
     *         },
     *         header: {
     *             Authorization: authorization
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getNotificationChannelResults = qraft.v1Service.getNotificationChannel.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getNotificationChannelResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getNotificationChannelCombinedResults = qraft.v1Service.getNotificationChannel.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getNotificationChannelCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<GetNotificationChannelSchema, GetNotificationChannelParameters, GetNotificationChannelData, GetNotificationChannelError>
      >,
      TCombinedResult = Array<UseQueryResult<GetNotificationChannelData, GetNotificationChannelError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetNotificationChannelData, GetNotificationChannelError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(
      parameters: DeepReadonly<GetNotificationChannelParameters>
    ): ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNotificationChannel.useQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetNotificationChannelData>(
      parameters: ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters> | DeepReadonly<GetNotificationChannelParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetNotificationChannelData,
          GetNotificationChannelError,
          TData,
          ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetNotificationChannelError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNotificationChannel.useQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetNotificationChannelData>(
      parameters: ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters> | DeepReadonly<GetNotificationChannelParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetNotificationChannelData,
          GetNotificationChannelError,
          TData,
          ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetNotificationChannelError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getNotificationChannel.useSuspenseInfiniteQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetNotificationChannelParameters, TData = GetNotificationChannelData>(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>
        | DeepReadonly<GetNotificationChannelParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetNotificationChannelData,
          GetNotificationChannelError,
          OperationInfiniteData<TData, GetNotificationChannelParameters>,
          GetNotificationChannelData,
          ServiceOperationInfiniteQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetNotificationChannelData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetNotificationChannelParameters>, GetNotificationChannelError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getNotificationChannelData = qraft.v1Service.getNotificationChannel.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getNotificationChannelResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getNotificationChannelCombinedData = qraft.v1Service.getNotificationChannel.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getNotificationChannelCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<
          GetNotificationChannelSchema,
          GetNotificationChannelParameters,
          GetNotificationChannelData,
          GetNotificationChannelError
        >
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetNotificationChannelData, GetNotificationChannelError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetNotificationChannelData, GetNotificationChannelError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getNotificationChannel.useSuspenseQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetNotificationChannelData>(
      parameters: ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters> | DeepReadonly<GetNotificationChannelParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<
          GetNotificationChannelData,
          GetNotificationChannelError,
          TData,
          ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetNotificationChannelError | Error>;
    schema: GetNotificationChannelSchema;
    types: {
      parameters: GetNotificationChannelParameters;
      data: GetNotificationChannelData;
      error: GetNotificationChannelError;
    };
  };
  patchNotificationChannel: {
    /**/
    getMutationKey(
      parameters: DeepReadonly<PatchNotificationChannelParameters> | void
    ): ServiceOperationMutationKey<PatchNotificationChannelSchema, PatchNotificationChannelParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchNotificationChannel.useMutation({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchNotificationChannel.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends PatchNotificationChannelBody, TContext = unknown>(
      parameters: DeepReadonly<PatchNotificationChannelParameters>,
      options?: ServiceOperationUseMutationOptions<
        PatchNotificationChannelSchema,
        PatchNotificationChannelData,
        PatchNotificationChannelParameters,
        TVariables,
        PatchNotificationChannelError | Error,
        TContext
      >
    ): UseMutationResult<PatchNotificationChannelData, PatchNotificationChannelError | Error, TVariables, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchNotificationChannel.useMutation({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchNotificationChannel.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PatchNotificationChannelBody, PatchNotificationChannelParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PatchNotificationChannelSchema,
        PatchNotificationChannelData,
        PatchNotificationChannelParameters,
        TVariables,
        PatchNotificationChannelError | Error,
        TContext
      >
    ): UseMutationResult<PatchNotificationChannelData, PatchNotificationChannelError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const patchNotificationChannelTotal = qraft.v1Service.patchNotificationChannel.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const patchNotificationChannelTotal = qraft.v1Service.patchNotificationChannel.useIsMutating({
     *     parameters: {
     *         path: {
     *             id: id
     *         },
     *         header: {
     *             Authorization: authorization
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<
            PatchNotificationChannelBody,
            PatchNotificationChannelData,
            PatchNotificationChannelParameters,
            PatchNotificationChannelError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PatchNotificationChannelSchema,
            PatchNotificationChannelBody,
            PatchNotificationChannelData,
            PatchNotificationChannelParameters,
            PatchNotificationChannelError | Error,
            TContext
          >
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<
            PatchNotificationChannelBody,
            PatchNotificationChannelData,
            PatchNotificationChannelParameters,
            PatchNotificationChannelError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PatchNotificationChannelSchema,
            PatchNotificationChannelBody,
            PatchNotificationChannelData,
            PatchNotificationChannelParameters,
            PatchNotificationChannelError | Error,
            TContext
          >
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<PatchNotificationChannelBody, PatchNotificationChannelParameters>,
      client?: (
        schema: PatchNotificationChannelSchema,
        options: ServiceOperationMutationFnOptions<PatchNotificationChannelBody, PatchNotificationChannelParameters>
      ) => Promise<RequestFnResponse<PatchNotificationChannelData, PatchNotificationChannelError>>
    ): Promise<RequestFnResponse<PatchNotificationChannelData, PatchNotificationChannelError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const patchNotificationChannelPendingMutationVariables = qraft.v1Service.patchNotificationChannel.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const patchNotificationChannelMutationData = qraft.v1Service.patchNotificationChannel.useMutationState({
     *     filters: {
     *         parameters: {
     *             path: {
     *                 id: id
     *             },
     *             header: {
     *                 Authorization: authorization
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        PatchNotificationChannelData,
        PatchNotificationChannelError | Error,
        MutationVariables<PatchNotificationChannelBody, PatchNotificationChannelParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<
            PatchNotificationChannelBody,
            PatchNotificationChannelData,
            PatchNotificationChannelParameters,
            PatchNotificationChannelError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PatchNotificationChannelSchema,
            PatchNotificationChannelBody,
            PatchNotificationChannelData,
            PatchNotificationChannelParameters,
            PatchNotificationChannelError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          PatchNotificationChannelData,
          PatchNotificationChannelError | Error,
          MutationVariables<PatchNotificationChannelBody, PatchNotificationChannelParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: PatchNotificationChannelSchema;
    types: {
      parameters: PatchNotificationChannelParameters;
      data: PatchNotificationChannelData;
      error: PatchNotificationChannelError;
      body: PatchNotificationChannelBody;
    };
  };
  deleteNotificationChannel: {
    /**/
    getMutationKey(
      parameters: DeepReadonly<DeleteNotificationChannelParameters> | void
    ): ServiceOperationMutationKey<DeleteNotificationChannelSchema, DeleteNotificationChannelParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteNotificationChannel.useMutation({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteNotificationChannel.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends DeleteNotificationChannelBody, TContext = unknown>(
      parameters: DeepReadonly<DeleteNotificationChannelParameters>,
      options?: ServiceOperationUseMutationOptions<
        DeleteNotificationChannelSchema,
        DeleteNotificationChannelData,
        DeleteNotificationChannelParameters,
        TVariables,
        DeleteNotificationChannelError | Error,
        TContext
      >
    ): UseMutationResult<DeleteNotificationChannelData, DeleteNotificationChannelError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteNotificationChannel.useMutation({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteNotificationChannel.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<DeleteNotificationChannelBody, DeleteNotificationChannelParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        DeleteNotificationChannelSchema,
        DeleteNotificationChannelData,
        DeleteNotificationChannelParameters,
        TVariables,
        DeleteNotificationChannelError | Error,
        TContext
      >
    ): UseMutationResult<DeleteNotificationChannelData, DeleteNotificationChannelError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const deleteNotificationChannelTotal = qraft.v1Service.deleteNotificationChannel.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const deleteNotificationChannelTotal = qraft.v1Service.deleteNotificationChannel.useIsMutating({
     *     parameters: {
     *         path: {
     *             id: id
     *         },
     *         header: {
     *             Authorization: authorization
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<
            DeleteNotificationChannelBody,
            DeleteNotificationChannelData,
            DeleteNotificationChannelParameters,
            DeleteNotificationChannelError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            DeleteNotificationChannelSchema,
            DeleteNotificationChannelBody,
            DeleteNotificationChannelData,
            DeleteNotificationChannelParameters,
            DeleteNotificationChannelError | Error,
            TContext
          >
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<
            DeleteNotificationChannelBody,
            DeleteNotificationChannelData,
            DeleteNotificationChannelParameters,
            DeleteNotificationChannelError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            DeleteNotificationChannelSchema,
            DeleteNotificationChannelBody,
            DeleteNotificationChannelData,
            DeleteNotificationChannelParameters,
            DeleteNotificationChannelError | Error,
            TContext
          >
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<DeleteNotificationChannelBody, DeleteNotificationChannelParameters>,
      client?: (
        schema: DeleteNotificationChannelSchema,
        options: ServiceOperationMutationFnOptions<DeleteNotificationChannelBody, DeleteNotificationChannelParameters>
      ) => Promise<RequestFnResponse<DeleteNotificationChannelData, DeleteNotificationChannelError>>
    ): Promise<RequestFnResponse<DeleteNotificationChannelData, DeleteNotificationChannelError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const deleteNotificationChannelPendingMutationVariables = qraft.v1Service.deleteNotificationChannel.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const deleteNotificationChannelMutationData = qraft.v1Service.deleteNotificationChannel.useMutationState({
     *     filters: {
     *         parameters: {
     *             path: {
     *                 id: id
     *             },
     *             header: {
     *                 Authorization: authorization
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        DeleteNotificationChannelData,
        DeleteNotificationChannelError | Error,
        MutationVariables<DeleteNotificationChannelBody, DeleteNotificationChannelParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<
            DeleteNotificationChannelBody,
            DeleteNotificationChannelData,
            DeleteNotificationChannelParameters,
            DeleteNotificationChannelError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            DeleteNotificationChannelSchema,
            DeleteNotificationChannelBody,
            DeleteNotificationChannelData,
            DeleteNotificationChannelParameters,
            DeleteNotificationChannelError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          DeleteNotificationChannelData,
          DeleteNotificationChannelError | Error,
          MutationVariables<DeleteNotificationChannelBody, DeleteNotificationChannelParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: DeleteNotificationChannelSchema;
    types: {
      parameters: DeleteNotificationChannelParameters;
      data: DeleteNotificationChannelData;
      error: DeleteNotificationChannelError;
      body: DeleteNotificationChannelBody;
    };
  };
  upsertDeploymentAlert: {
    /**/
    getMutationKey(
      parameters: DeepReadonly<UpsertDeploymentAlertParameters> | void
    ): ServiceOperationMutationKey<UpsertDeploymentAlertSchema, UpsertDeploymentAlertParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.upsertDeploymentAlert.useMutation({
     *     path: {
     *         dseq: dseq
     *     },
     *     header: {
     *         "x-owner-address": xOwnerAddress
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.upsertDeploymentAlert.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         dseq: dseq
     *     },
     *     header: {
     *         "x-owner-address": xOwnerAddress
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends UpsertDeploymentAlertBody, TContext = unknown>(
      parameters: DeepReadonly<UpsertDeploymentAlertParameters>,
      options?: ServiceOperationUseMutationOptions<
        UpsertDeploymentAlertSchema,
        UpsertDeploymentAlertData,
        UpsertDeploymentAlertParameters,
        TVariables,
        UpsertDeploymentAlertError | Error,
        TContext
      >
    ): UseMutationResult<UpsertDeploymentAlertData, UpsertDeploymentAlertError | Error, TVariables, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.upsertDeploymentAlert.useMutation({
     *     path: {
     *         dseq: dseq
     *     },
     *     header: {
     *         "x-owner-address": xOwnerAddress
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.upsertDeploymentAlert.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         dseq: dseq
     *     },
     *     header: {
     *         "x-owner-address": xOwnerAddress
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<UpsertDeploymentAlertBody, UpsertDeploymentAlertParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        UpsertDeploymentAlertSchema,
        UpsertDeploymentAlertData,
        UpsertDeploymentAlertParameters,
        TVariables,
        UpsertDeploymentAlertError | Error,
        TContext
      >
    ): UseMutationResult<UpsertDeploymentAlertData, UpsertDeploymentAlertError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const upsertDeploymentAlertTotal = qraft.v1Service.upsertDeploymentAlert.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const upsertDeploymentAlertTotal = qraft.v1Service.upsertDeploymentAlert.useIsMutating({
     *     parameters: {
     *         path: {
     *             dseq: dseq
     *         },
     *         header: {
     *             "x-owner-address": xOwnerAddress
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<
            UpsertDeploymentAlertBody,
            UpsertDeploymentAlertData,
            UpsertDeploymentAlertParameters,
            UpsertDeploymentAlertError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            UpsertDeploymentAlertSchema,
            UpsertDeploymentAlertBody,
            UpsertDeploymentAlertData,
            UpsertDeploymentAlertParameters,
            UpsertDeploymentAlertError | Error,
            TContext
          >
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<
            UpsertDeploymentAlertBody,
            UpsertDeploymentAlertData,
            UpsertDeploymentAlertParameters,
            UpsertDeploymentAlertError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            UpsertDeploymentAlertSchema,
            UpsertDeploymentAlertBody,
            UpsertDeploymentAlertData,
            UpsertDeploymentAlertParameters,
            UpsertDeploymentAlertError | Error,
            TContext
          >
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<UpsertDeploymentAlertBody, UpsertDeploymentAlertParameters>,
      client?: (
        schema: UpsertDeploymentAlertSchema,
        options: ServiceOperationMutationFnOptions<UpsertDeploymentAlertBody, UpsertDeploymentAlertParameters>
      ) => Promise<RequestFnResponse<UpsertDeploymentAlertData, UpsertDeploymentAlertError>>
    ): Promise<RequestFnResponse<UpsertDeploymentAlertData, UpsertDeploymentAlertError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const upsertDeploymentAlertPendingMutationVariables = qraft.v1Service.upsertDeploymentAlert.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const upsertDeploymentAlertMutationData = qraft.v1Service.upsertDeploymentAlert.useMutationState({
     *     filters: {
     *         parameters: {
     *             path: {
     *                 dseq: dseq
     *             },
     *             header: {
     *                 "x-owner-address": xOwnerAddress
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        UpsertDeploymentAlertData,
        UpsertDeploymentAlertError | Error,
        MutationVariables<UpsertDeploymentAlertBody, UpsertDeploymentAlertParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<
            UpsertDeploymentAlertBody,
            UpsertDeploymentAlertData,
            UpsertDeploymentAlertParameters,
            UpsertDeploymentAlertError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            UpsertDeploymentAlertSchema,
            UpsertDeploymentAlertBody,
            UpsertDeploymentAlertData,
            UpsertDeploymentAlertParameters,
            UpsertDeploymentAlertError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          UpsertDeploymentAlertData,
          UpsertDeploymentAlertError | Error,
          MutationVariables<UpsertDeploymentAlertBody, UpsertDeploymentAlertParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: UpsertDeploymentAlertSchema;
    types: {
      parameters: UpsertDeploymentAlertParameters;
      data: UpsertDeploymentAlertData;
      error: UpsertDeploymentAlertError;
      body: UpsertDeploymentAlertBody;
    };
  };
  getDeploymentAlerts: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
        | QueryFiltersByQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(parameters: DeepReadonly<GetDeploymentAlertsParameters>): ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeploymentAlerts.useQuery({
     *     path: {
     *         dseq: dseq
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetDeploymentAlertsData>(
      parameters: ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters> | DeepReadonly<GetDeploymentAlertsParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetDeploymentAlertsData,
          GetDeploymentAlertsError,
          TData,
          ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetDeploymentAlertsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeploymentAlerts.useQuery({
     *     path: {
     *         dseq: dseq
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetDeploymentAlertsData>(
      parameters: ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters> | DeepReadonly<GetDeploymentAlertsParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetDeploymentAlertsData,
          GetDeploymentAlertsError,
          TData,
          ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetDeploymentAlertsError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetDeploymentAlertsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetDeploymentAlertsSchema,
        GetDeploymentAlertsData,
        GetDeploymentAlertsParameters,
        DeepReadonly<TPageParam>,
        GetDeploymentAlertsError
      >
    ): Promise<OperationInfiniteData<GetDeploymentAlertsData, GetDeploymentAlertsParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetDeploymentAlertsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetDeploymentAlertsSchema,
        GetDeploymentAlertsData,
        GetDeploymentAlertsParameters,
        DeepReadonly<TPageParam>,
        GetDeploymentAlertsError
      >
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetDeploymentAlertsParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetDeploymentAlertsSchema,
        GetDeploymentAlertsData,
        GetDeploymentAlertsParameters,
        DeepReadonly<TPageParam>,
        GetDeploymentAlertsError
      >
    ): Promise<OperationInfiniteData<GetDeploymentAlertsData, GetDeploymentAlertsParameters>>;
    /**/
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetDeploymentAlertsSchema, GetDeploymentAlertsData, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
    ): Promise<GetDeploymentAlertsData>;
    /**/
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetDeploymentAlertsSchema, GetDeploymentAlertsData, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
    ): Promise<void>;
    /**/
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetDeploymentAlertsSchema,
        GetDeploymentAlertsData,
        GetDeploymentAlertsParameters,
        GetDeploymentAlertsError
      >
    ): Promise<GetDeploymentAlertsData>;
    /**/
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters> | DeepReadonly<GetDeploymentAlertsParameters>
    ): OperationInfiniteData<GetDeploymentAlertsData, GetDeploymentAlertsParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
        | QueryFiltersByQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>,
            data: NoInfer<OperationInfiniteData<GetDeploymentAlertsData, GetDeploymentAlertsParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>, data: GetDeploymentAlertsData | undefined]>;
    /**/
    getQueryData(
      parameters: ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters> | DeepReadonly<GetDeploymentAlertsParameters>
    ): GetDeploymentAlertsData | undefined;
    /**/
    getQueryState(
      parameters: ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters> | DeepReadonly<GetDeploymentAlertsParameters>
    ): QueryState<GetDeploymentAlertsData, GetDeploymentAlertsError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters: DeepReadonly<GetDeploymentAlertsParameters> | ServiceOperationInfiniteQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>
    ): QueryState<OperationInfiniteData<GetDeploymentAlertsData, GetDeploymentAlertsParameters>, GetDeploymentAlertsError> | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
        | QueryFiltersByQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetDeploymentAlertsParameters, TMeta, TSignal>,
      client?: (
        schema: GetDeploymentAlertsSchema,
        options: {
          parameters: GetDeploymentAlertsParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetDeploymentAlertsData, GetDeploymentAlertsError>>
    ): Promise<RequestFnResponse<GetDeploymentAlertsData, GetDeploymentAlertsError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
        | QueryFiltersByQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
        | QueryFiltersByQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
        | QueryFiltersByQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters: DeepReadonly<GetDeploymentAlertsParameters> | ServiceOperationInfiniteQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetDeploymentAlertsData, GetDeploymentAlertsParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetDeploymentAlertsData, GetDeploymentAlertsParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetDeploymentAlertsData, GetDeploymentAlertsParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
        | QueryFiltersByQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>,
      updater: Updater<NoInfer<GetDeploymentAlertsData> | undefined, NoInfer<GetDeploymentAlertsData> | undefined>,
      options?: SetDataOptions
    ): Array<GetDeploymentAlertsData | undefined>;
    /**/
    setQueryData(
      parameters: DeepReadonly<GetDeploymentAlertsParameters> | ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>,
      updater: Updater<NoInfer<GetDeploymentAlertsData> | undefined, NoInfer<DeepReadonly<GetDeploymentAlertsData>> | undefined>,
      options?: SetDataOptions
    ): GetDeploymentAlertsData | undefined;
    /**/
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetDeploymentAlertsParameters>
    ): ServiceOperationInfiniteQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getDeploymentAlerts.useInfiniteQuery({
     *     path: {
     *         dseq: dseq
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetDeploymentAlertsParameters,
      TQueryFnData = GetDeploymentAlertsData,
      TData = OperationInfiniteData<TQueryFnData, GetDeploymentAlertsParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters> | DeepReadonly<GetDeploymentAlertsParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetDeploymentAlertsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetDeploymentAlertsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getDeploymentAlerts.useInfiniteQuery({
     *     path: {
     *         dseq: dseq
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetDeploymentAlertsParameters,
      TQueryFnData = GetDeploymentAlertsData,
      TData = OperationInfiniteData<TQueryFnData, GetDeploymentAlertsParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters> | DeepReadonly<GetDeploymentAlertsParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetDeploymentAlertsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetDeploymentAlertsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetDeploymentAlertsError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getDeploymentAlertsTotal = qraft.v1Service.getDeploymentAlerts.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getDeploymentAlertsByParametersTotal = qraft.v1Service.getDeploymentAlerts.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             dseq: dseq
     *         },
     *         header: {
     *             Authorization: authorization
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
        | QueryFiltersByQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getDeploymentAlertsResults = qraft.v1Service.getDeploymentAlerts.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 dseq: dseq1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             path: {
     *                 dseq: dseq2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getDeploymentAlertsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getDeploymentAlertsCombinedResults = qraft.v1Service.getDeploymentAlerts.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 dseq: dseq1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             path: {
     *                 dseq: dseq2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getDeploymentAlertsCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters, GetDeploymentAlertsData, GetDeploymentAlertsError>
      >,
      TCombinedResult = Array<UseQueryResult<GetDeploymentAlertsData, GetDeploymentAlertsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetDeploymentAlertsData, GetDeploymentAlertsError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(parameters: DeepReadonly<GetDeploymentAlertsParameters>): ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeploymentAlerts.useQuery({
     *     path: {
     *         dseq: dseq
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetDeploymentAlertsData>(
      parameters: ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters> | DeepReadonly<GetDeploymentAlertsParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetDeploymentAlertsData,
          GetDeploymentAlertsError,
          TData,
          ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetDeploymentAlertsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeploymentAlerts.useQuery({
     *     path: {
     *         dseq: dseq
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetDeploymentAlertsData>(
      parameters: ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters> | DeepReadonly<GetDeploymentAlertsParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetDeploymentAlertsData,
          GetDeploymentAlertsError,
          TData,
          ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetDeploymentAlertsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getDeploymentAlerts.useSuspenseInfiniteQuery({
     *     path: {
     *         dseq: dseq
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetDeploymentAlertsParameters, TData = GetDeploymentAlertsData>(
      parameters: ServiceOperationInfiniteQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters> | DeepReadonly<GetDeploymentAlertsParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetDeploymentAlertsData,
          GetDeploymentAlertsError,
          OperationInfiniteData<TData, GetDeploymentAlertsParameters>,
          GetDeploymentAlertsData,
          ServiceOperationInfiniteQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetDeploymentAlertsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetDeploymentAlertsParameters>, GetDeploymentAlertsError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getDeploymentAlertsData = qraft.v1Service.getDeploymentAlerts.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 dseq: dseq1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             path: {
     *                 dseq: dseq2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getDeploymentAlertsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getDeploymentAlertsCombinedData = qraft.v1Service.getDeploymentAlerts.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 dseq: dseq1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             path: {
     *                 dseq: dseq2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getDeploymentAlertsCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters, GetDeploymentAlertsData, GetDeploymentAlertsError>
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetDeploymentAlertsData, GetDeploymentAlertsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetDeploymentAlertsData, GetDeploymentAlertsError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getDeploymentAlerts.useSuspenseQuery({
     *     path: {
     *         dseq: dseq
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetDeploymentAlertsData>(
      parameters: ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters> | DeepReadonly<GetDeploymentAlertsParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<
          GetDeploymentAlertsData,
          GetDeploymentAlertsError,
          TData,
          ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetDeploymentAlertsError | Error>;
    schema: GetDeploymentAlertsSchema;
    types: {
      parameters: GetDeploymentAlertsParameters;
      data: GetDeploymentAlertsData;
      error: GetDeploymentAlertsError;
    };
  };
}
/**
 * @summary Start a trial period for a user
 * @description Creates a managed wallet for a user and initiates a trial period. This endpoint handles payment method validation and may require 3D Secure authentication for certain payment methods. Returns wallet information and trial status.
 */
export const postStartTrial = {
  schema: {
    method: "post",
    url: "/v1/start-trial",
    mediaType: ["application/json"],
    security: []
  }
} as {
  schema: PostStartTrialSchema;
  [QraftServiceOperationsToken]: V1Service["postStartTrial"];
};
/** @summary Get a list of wallets */
export const getWallets = {
  schema: {
    method: "get",
    url: "/v1/wallets",
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: GetWalletsSchema;
  [QraftServiceOperationsToken]: V1Service["getWallets"];
};
/**
 * @summary Get wallet settings
 * @description Retrieves the wallet settings for the current user's wallet
 */
export const getWalletSettings = {
  schema: {
    method: "get",
    url: "/v1/wallet-settings",
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: GetWalletSettingsSchema;
  [QraftServiceOperationsToken]: V1Service["getWalletSettings"];
};
/**
 * @summary Create wallet settings
 * @description Creates wallet settings for a user wallet
 */
export const postWalletSettings = {
  schema: {
    method: "post",
    url: "/v1/wallet-settings",
    mediaType: ["application/json"],
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: PostWalletSettingsSchema;
  [QraftServiceOperationsToken]: V1Service["postWalletSettings"];
};
/**
 * @summary Update wallet settings
 * @description Updates wallet settings for a user wallet
 */
export const putWalletSettings = {
  schema: {
    method: "put",
    url: "/v1/wallet-settings",
    mediaType: ["application/json"],
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: PutWalletSettingsSchema;
  [QraftServiceOperationsToken]: V1Service["putWalletSettings"];
};
/**
 * @summary Delete wallet settings
 * @description Deletes wallet settings for a user wallet
 */
export const deleteWalletSettings = {
  schema: {
    method: "delete",
    url: "/v1/wallet-settings",
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: DeleteWalletSettingsSchema;
  [QraftServiceOperationsToken]: V1Service["deleteWalletSettings"];
};
/** @summary Signs a transaction via a user managed wallet */
export const postTx = {
  schema: {
    method: "post",
    url: "/v1/tx",
    mediaType: ["application/json"],
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: PostTxSchema;
  [QraftServiceOperationsToken]: V1Service["postTx"];
};
/** @summary Creates a stripe checkout session and redirects to checkout */
export const getCheckout = {
  schema: {
    method: "get",
    url: "/v1/checkout",
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: GetCheckoutSchema;
  [QraftServiceOperationsToken]: V1Service["getCheckout"];
};
/** @summary Stripe Webhook Handler */
export const postStripeWebhook = {
  schema: {
    method: "post",
    url: "/v1/stripe-webhook",
    mediaType: ["text/plain"],
    security: []
  }
} as {
  schema: PostStripeWebhookSchema;
  [QraftServiceOperationsToken]: V1Service["postStripeWebhook"];
};
/**
 * @summary Get available Stripe pricing options
 * @description Retrieves the list of available pricing options for wallet top-ups, including custom amounts and standard pricing tiers
 */
export const getStripePrices = {
  schema: {
    method: "get",
    url: "/v1/stripe/prices",
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: GetStripePricesSchema;
  [QraftServiceOperationsToken]: V1Service["getStripePrices"];
};
/** @summary Apply a coupon to the current user */
export const postStripeCouponsApply = {
  schema: {
    method: "post",
    url: "/v1/stripe/coupons/apply",
    mediaType: ["application/json"],
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: PostStripeCouponsApplySchema;
  [QraftServiceOperationsToken]: V1Service["postStripeCouponsApply"];
};
/**
 * @summary Update customer organization
 * @description Updates the organization/business name for the current user's Stripe customer account
 */
export const putStripeCustomersOrganization = {
  schema: {
    method: "put",
    url: "/v1/stripe/customers/organization",
    mediaType: ["application/json"],
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: PutStripeCustomersOrganizationSchema;
  [QraftServiceOperationsToken]: V1Service["putStripeCustomersOrganization"];
};
/**
 * @summary Create a Stripe SetupIntent for adding a payment method
 * @description Creates a Stripe SetupIntent that allows users to securely add payment methods to their account. The SetupIntent provides a client secret that can be used with Stripe's frontend SDKs to collect payment method details.
 */
export const postStripePaymentMethodsSetup = {
  schema: {
    method: "post",
    url: "/v1/stripe/payment-methods/setup",
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: PostStripePaymentMethodsSetupSchema;
  [QraftServiceOperationsToken]: V1Service["postStripePaymentMethodsSetup"];
};
/** @summary Marks a payment method as the default. */
export const postStripePaymentMethodsDefault = {
  schema: {
    method: "post",
    url: "/v1/stripe/payment-methods/default",
    mediaType: ["application/json"],
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: PostStripePaymentMethodsDefaultSchema;
  [QraftServiceOperationsToken]: V1Service["postStripePaymentMethodsDefault"];
};
/**
 * @summary Get the default payment method for the current user
 * @description Retrieves the default payment method associated with the current user's account, including card details, validation status, and billing information.
 */
export const getStripePaymentMethodsDefault = {
  schema: {
    method: "get",
    url: "/v1/stripe/payment-methods/default",
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: GetStripePaymentMethodsDefaultSchema;
  [QraftServiceOperationsToken]: V1Service["getStripePaymentMethodsDefault"];
};
/**
 * @summary Get all payment methods for the current user
 * @description Retrieves all saved payment methods associated with the current user's account, including card details, validation status, and billing information.
 */
export const getStripePaymentMethods = {
  schema: {
    method: "get",
    url: "/v1/stripe/payment-methods",
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: GetStripePaymentMethodsSchema;
  [QraftServiceOperationsToken]: V1Service["getStripePaymentMethods"];
};
/**
 * @summary Remove a payment method
 * @description Permanently removes a saved payment method from the user's account. This action cannot be undone.
 */
export const deleteStripePaymentMethodsPaymentMethodId = {
  schema: {
    method: "delete",
    url: "/v1/stripe/payment-methods/{paymentMethodId}",
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: DeleteStripePaymentMethodsPaymentMethodIdSchema;
  [QraftServiceOperationsToken]: V1Service["deleteStripePaymentMethodsPaymentMethodId"];
};
/**
 * @summary Validates a payment method after 3D Secure authentication
 * @description Completes the validation process for a payment method that required 3D Secure authentication. This endpoint should be called after the user completes the 3D Secure challenge.
 */
export const postStripePaymentMethodsValidate = {
  schema: {
    method: "post",
    url: "/v1/stripe/payment-methods/validate",
    mediaType: ["application/json"],
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: PostStripePaymentMethodsValidateSchema;
  [QraftServiceOperationsToken]: V1Service["postStripePaymentMethodsValidate"];
};
/**
 * @summary Confirm a payment using a saved payment method
 * @description Processes a payment using a previously saved payment method. This endpoint handles wallet top-ups and may require 3D Secure authentication for certain payment methods or amounts.
 */
export const postStripeTransactionsConfirm = {
  schema: {
    method: "post",
    url: "/v1/stripe/transactions/confirm",
    mediaType: ["application/json"],
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: PostStripeTransactionsConfirmSchema;
  [QraftServiceOperationsToken]: V1Service["postStripeTransactionsConfirm"];
};
/** @summary Get transaction history for the current customer */
export const getStripeTransactions = {
  schema: {
    method: "get",
    url: "/v1/stripe/transactions",
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: GetStripeTransactionsSchema;
  [QraftServiceOperationsToken]: V1Service["getStripeTransactions"];
};
/** @summary Export transaction history as CSV for the current customer */
export const getStripeTransactionsExport = {
  schema: {
    method: "get",
    url: "/v1/stripe/transactions/export",
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: GetStripeTransactionsExportSchema;
  [QraftServiceOperationsToken]: V1Service["getStripeTransactionsExport"];
};
/** @summary Get historical data of billing and usage for a wallet address. */
export const getUsageHistory = {
  schema: {
    method: "get",
    url: "/v1/usage/history",
    security: []
  }
} as {
  schema: GetUsageHistorySchema;
  [QraftServiceOperationsToken]: V1Service["getUsageHistory"];
};
/** @summary Get historical usage stats for a wallet address. */
export const getUsageHistoryStats = {
  schema: {
    method: "get",
    url: "/v1/usage/history/stats",
    security: []
  }
} as {
  schema: GetUsageHistoryStatsSchema;
  [QraftServiceOperationsToken]: V1Service["getUsageHistoryStats"];
};
/** @summary Creates an anonymous user */
export const postAnonymousUsers = {
  schema: {
    method: "post",
    url: "/v1/anonymous-users",
    security: []
  }
} as {
  schema: PostAnonymousUsersSchema;
  [QraftServiceOperationsToken]: V1Service["postAnonymousUsers"];
};
/** @summary Retrieves an anonymous user by id */
export const getAnonymousUsersId = {
  schema: {
    method: "get",
    url: "/v1/anonymous-users/{id}",
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: GetAnonymousUsersIdSchema;
  [QraftServiceOperationsToken]: V1Service["getAnonymousUsersId"];
};
/** @summary Registers a new user */
export const postRegisterUser = {
  schema: {
    method: "post",
    url: "/v1/register-user",
    mediaType: ["application/json"],
    security: []
  }
} as {
  schema: PostRegisterUserSchema;
  [QraftServiceOperationsToken]: V1Service["postRegisterUser"];
};
/** @summary Retrieves the logged in user */
export const getUserMe = {
  schema: {
    method: "get",
    url: "/v1/user/me",
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: GetUserMeSchema;
  [QraftServiceOperationsToken]: V1Service["getUserMe"];
};
/** @summary Resends a verification email */
export const postSendVerificationEmail = {
  schema: {
    method: "post",
    url: "/v1/send-verification-email",
    mediaType: ["application/json"],
    security: []
  }
} as {
  schema: PostSendVerificationEmailSchema;
  [QraftServiceOperationsToken]: V1Service["postSendVerificationEmail"];
};
/** @summary Checks if the email is verified */
export const postVerifyEmail = {
  schema: {
    method: "post",
    url: "/v1/verify-email",
    mediaType: ["application/json"],
    security: []
  }
} as {
  schema: PostVerifyEmailSchema;
  [QraftServiceOperationsToken]: V1Service["postVerifyEmail"];
};
/** @summary Get deployment settings by user ID and dseq */
export const getDeploymentSettingsUserIdDseq = {
  schema: {
    method: "get",
    url: "/v1/deployment-settings/{userId}/{dseq}",
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: GetDeploymentSettingsUserIdDseqSchema;
  [QraftServiceOperationsToken]: V1Service["getDeploymentSettingsUserIdDseq"];
};
/** @summary Update deployment settings */
export const patchDeploymentSettingsUserIdDseq = {
  schema: {
    method: "patch",
    url: "/v1/deployment-settings/{userId}/{dseq}",
    mediaType: ["application/json"],
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: PatchDeploymentSettingsUserIdDseqSchema;
  [QraftServiceOperationsToken]: V1Service["patchDeploymentSettingsUserIdDseq"];
};
/** @summary Create deployment settings */
export const postDeploymentSettings = {
  schema: {
    method: "post",
    url: "/v1/deployment-settings",
    mediaType: ["application/json"],
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: PostDeploymentSettingsSchema;
  [QraftServiceOperationsToken]: V1Service["postDeploymentSettings"];
};
/** @summary Get a deployment */
export const getDeploymentsDseq = {
  schema: {
    method: "get",
    url: "/v1/deployments/{dseq}",
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: GetDeploymentsDseqSchema;
  [QraftServiceOperationsToken]: V1Service["getDeploymentsDseq"];
};
/** @summary Close a deployment */
export const deleteDeploymentsDseq = {
  schema: {
    method: "delete",
    url: "/v1/deployments/{dseq}",
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: DeleteDeploymentsDseqSchema;
  [QraftServiceOperationsToken]: V1Service["deleteDeploymentsDseq"];
};
/** @summary Update a deployment */
export const putDeploymentsDseq = {
  schema: {
    method: "put",
    url: "/v1/deployments/{dseq}",
    mediaType: ["application/json"],
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: PutDeploymentsDseqSchema;
  [QraftServiceOperationsToken]: V1Service["putDeploymentsDseq"];
};
/** @summary Create new deployment */
export const postDeployments = {
  schema: {
    method: "post",
    url: "/v1/deployments",
    mediaType: ["application/json"],
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: PostDeploymentsSchema;
  [QraftServiceOperationsToken]: V1Service["postDeployments"];
};
/** @summary List deployments with pagination and filtering */
export const getDeployments = {
  schema: {
    method: "get",
    url: "/v1/deployments",
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: GetDeploymentsSchema;
  [QraftServiceOperationsToken]: V1Service["getDeployments"];
};
/** @summary Deposit into a deployment */
export const postDepositDeployment = {
  schema: {
    method: "post",
    url: "/v1/deposit-deployment",
    mediaType: ["application/json"],
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: PostDepositDeploymentSchema;
  [QraftServiceOperationsToken]: V1Service["postDepositDeployment"];
};
/** @summary Get a list of deployments by owner address. */
export const getAddressesAddressDeploymentsSkipLimit = {
  schema: {
    method: "get",
    url: "/v1/addresses/{address}/deployments/{skip}/{limit}",
    security: []
  }
} as {
  schema: GetAddressesAddressDeploymentsSkipLimitSchema;
  [QraftServiceOperationsToken]: V1Service["getAddressesAddressDeploymentsSkipLimit"];
};
/** @summary Get deployment details */
export const getDeploymentOwnerDseq = {
  schema: {
    method: "get",
    url: "/v1/deployment/{owner}/{dseq}",
    security: []
  }
} as {
  schema: GetDeploymentOwnerDseqSchema;
  [QraftServiceOperationsToken]: V1Service["getDeploymentOwnerDseq"];
};
/** @summary Get weekly deployment cost */
export const getWeeklyCost = {
  schema: {
    method: "get",
    url: "/v1/weekly-cost",
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: GetWeeklyCostSchema;
  [QraftServiceOperationsToken]: V1Service["getWeeklyCost"];
};
/** @summary Create leases and send manifest */
export const postLeases = {
  schema: {
    method: "post",
    url: "/v1/leases",
    mediaType: ["application/json"],
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: PostLeasesSchema;
  [QraftServiceOperationsToken]: V1Service["postLeases"];
};
/** @summary List all API keys */
export const getApiKeys = {
  schema: {
    method: "get",
    url: "/v1/api-keys",
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: GetApiKeysSchema;
  [QraftServiceOperationsToken]: V1Service["getApiKeys"];
};
/** @summary Create new API key */
export const postApiKeys = {
  schema: {
    method: "post",
    url: "/v1/api-keys",
    mediaType: ["application/json"],
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: PostApiKeysSchema;
  [QraftServiceOperationsToken]: V1Service["postApiKeys"];
};
/** @summary Get API key by ID */
export const getApiKeysId = {
  schema: {
    method: "get",
    url: "/v1/api-keys/{id}",
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: GetApiKeysIdSchema;
  [QraftServiceOperationsToken]: V1Service["getApiKeysId"];
};
/** @summary Update API key */
export const patchApiKeysId = {
  schema: {
    method: "patch",
    url: "/v1/api-keys/{id}",
    mediaType: ["application/json"],
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: PatchApiKeysIdSchema;
  [QraftServiceOperationsToken]: V1Service["patchApiKeysId"];
};
/** @summary Delete API key */
export const deleteApiKeysId = {
  schema: {
    method: "delete",
    url: "/v1/api-keys/{id}",
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: DeleteApiKeysIdSchema;
  [QraftServiceOperationsToken]: V1Service["deleteApiKeysId"];
};
/** @summary List bids */
export const getBids = {
  schema: {
    method: "get",
    url: "/v1/bids",
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: GetBidsSchema;
  [QraftServiceOperationsToken]: V1Service["getBids"];
};
/** @summary List bids by dseq */
export const getBidsDseq = {
  schema: {
    method: "get",
    url: "/v1/bids/{dseq}",
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: GetBidsDseqSchema;
  [QraftServiceOperationsToken]: V1Service["getBidsDseq"];
};
/** @summary Create certificate */
export const postCertificates = {
  schema: {
    method: "post",
    url: "/v1/certificates",
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: PostCertificatesSchema;
  [QraftServiceOperationsToken]: V1Service["postCertificates"];
};
/** @summary Get user balances */
export const getBalances = {
  schema: {
    method: "get",
    url: "/v1/balances",
    security: []
  }
} as {
  schema: GetBalancesSchema;
  [QraftServiceOperationsToken]: V1Service["getBalances"];
};
/** @summary Get a list of providers. */
export const getProviders = {
  schema: {
    method: "get",
    url: "/v1/providers",
    security: []
  }
} as {
  schema: GetProvidersSchema;
  [QraftServiceOperationsToken]: V1Service["getProviders"];
};
/** @summary Get a provider details. */
export const getProvidersAddress = {
  schema: {
    method: "get",
    url: "/v1/providers/{address}",
    security: []
  }
} as {
  schema: GetProvidersAddressSchema;
  [QraftServiceOperationsToken]: V1Service["getProvidersAddress"];
};
export const getProvidersProviderAddressActiveLeasesGraphData = {
  schema: {
    method: "get",
    url: "/v1/providers/{providerAddress}/active-leases-graph-data",
    security: []
  }
} as {
  schema: GetProvidersProviderAddressActiveLeasesGraphDataSchema;
  [QraftServiceOperationsToken]: V1Service["getProvidersProviderAddressActiveLeasesGraphData"];
};
/** @summary Get a list of auditors. */
export const getAuditors = {
  schema: {
    method: "get",
    url: "/v1/auditors",
    security: []
  }
} as {
  schema: GetAuditorsSchema;
  [QraftServiceOperationsToken]: V1Service["getAuditors"];
};
/** @summary Get the provider attributes schema */
export const getProviderAttributesSchema = {
  schema: {
    method: "get",
    url: "/v1/provider-attributes-schema",
    security: []
  }
} as {
  schema: GetProviderAttributesSchemaSchema;
  [QraftServiceOperationsToken]: V1Service["getProviderAttributesSchema"];
};
/** @summary Get a list of provider regions */
export const getProviderRegions = {
  schema: {
    method: "get",
    url: "/v1/provider-regions",
    security: []
  }
} as {
  schema: GetProviderRegionsSchema;
  [QraftServiceOperationsToken]: V1Service["getProviderRegions"];
};
/** @summary Get dashboard data for provider console. */
export const getProviderDashboardOwner = {
  schema: {
    method: "get",
    url: "/v1/provider-dashboard/{owner}",
    security: []
  }
} as {
  schema: GetProviderDashboardOwnerSchema;
  [QraftServiceOperationsToken]: V1Service["getProviderDashboardOwner"];
};
/** @summary Get earnings data for provider console. */
export const getProviderEarningsOwner = {
  schema: {
    method: "get",
    url: "/v1/provider-earnings/{owner}",
    security: []
  }
} as {
  schema: GetProviderEarningsOwnerSchema;
  [QraftServiceOperationsToken]: V1Service["getProviderEarningsOwner"];
};
/** @summary Get providers grouped by version. */
export const getProviderVersions = {
  schema: {
    method: "get",
    url: "/v1/provider-versions",
    security: []
  }
} as {
  schema: GetProviderVersionsSchema;
  [QraftServiceOperationsToken]: V1Service["getProviderVersions"];
};
export const getProviderGraphDataDataName = {
  schema: {
    method: "get",
    url: "/v1/provider-graph-data/{dataName}",
    security: []
  }
} as {
  schema: GetProviderGraphDataDataNameSchema;
  [QraftServiceOperationsToken]: V1Service["getProviderGraphDataDataName"];
};
/** @summary Get a list of deployments for a provider. */
export const getProvidersProviderDeploymentsSkipLimit = {
  schema: {
    method: "get",
    url: "/v1/providers/{provider}/deployments/{skip}/{limit}",
    security: []
  }
} as {
  schema: GetProvidersProviderDeploymentsSkipLimitSchema;
  [QraftServiceOperationsToken]: V1Service["getProvidersProviderDeploymentsSkipLimit"];
};
/** @summary Create new JWT token for managed wallet */
export const postCreateJwtToken = {
  schema: {
    method: "post",
    url: "/v1/create-jwt-token",
    mediaType: ["application/json"],
    security: ["BearerAuth", "ApiKeyAuth"]
  }
} as {
  schema: PostCreateJwtTokenSchema;
  [QraftServiceOperationsToken]: V1Service["postCreateJwtToken"];
};
export const getGraphDataDataName = {
  schema: {
    method: "get",
    url: "/v1/graph-data/{dataName}",
    security: []
  }
} as {
  schema: GetGraphDataDataNameSchema;
  [QraftServiceOperationsToken]: V1Service["getGraphDataDataName"];
};
export const getDashboardData = {
  schema: {
    method: "get",
    url: "/v1/dashboard-data",
    security: []
  }
} as {
  schema: GetDashboardDataSchema;
  [QraftServiceOperationsToken]: V1Service["getDashboardData"];
};
export const getNetworkCapacity = {
  schema: {
    method: "get",
    url: "/v1/network-capacity",
    security: []
  }
} as {
  schema: GetNetworkCapacitySchema;
  [QraftServiceOperationsToken]: V1Service["getNetworkCapacity"];
};
/** @summary Get a list of recent blocks. */
export const getBlocks = {
  schema: {
    method: "get",
    url: "/v1/blocks",
    security: []
  }
} as {
  schema: GetBlocksSchema;
  [QraftServiceOperationsToken]: V1Service["getBlocks"];
};
/** @summary Get a block by height. */
export const getBlocksHeight = {
  schema: {
    method: "get",
    url: "/v1/blocks/{height}",
    security: []
  }
} as {
  schema: GetBlocksHeightSchema;
  [QraftServiceOperationsToken]: V1Service["getBlocksHeight"];
};
/** @summary Get the estimated date of a future block. */
export const getPredictedBlockDateHeight = {
  schema: {
    method: "get",
    url: "/v1/predicted-block-date/{height}",
    security: []
  }
} as {
  schema: GetPredictedBlockDateHeightSchema;
  [QraftServiceOperationsToken]: V1Service["getPredictedBlockDateHeight"];
};
/** @summary Get the estimated height of a future date and time. */
export const getPredictedDateHeightTimestamp = {
  schema: {
    method: "get",
    url: "/v1/predicted-date-height/{timestamp}",
    security: []
  }
} as {
  schema: GetPredictedDateHeightTimestampSchema;
  [QraftServiceOperationsToken]: V1Service["getPredictedDateHeightTimestamp"];
};
/** @summary Get a list of transactions. */
export const getTransactions = {
  schema: {
    method: "get",
    url: "/v1/transactions",
    security: []
  }
} as {
  schema: GetTransactionsSchema;
  [QraftServiceOperationsToken]: V1Service["getTransactions"];
};
/** @summary Get a transaction by hash. */
export const getTransactionsHash = {
  schema: {
    method: "get",
    url: "/v1/transactions/{hash}",
    security: []
  }
} as {
  schema: GetTransactionsHashSchema;
  [QraftServiceOperationsToken]: V1Service["getTransactionsHash"];
};
export const getMarketDataCoin = {
  schema: {
    method: "get",
    url: "/v1/market-data/{coin}",
    security: []
  }
} as {
  schema: GetMarketDataCoinSchema;
  [QraftServiceOperationsToken]: V1Service["getMarketDataCoin"];
};
export const getValidators = {
  schema: {
    method: "get",
    url: "/v1/validators",
    security: []
  }
} as {
  schema: GetValidatorsSchema;
  [QraftServiceOperationsToken]: V1Service["getValidators"];
};
export const getValidatorsAddress = {
  schema: {
    method: "get",
    url: "/v1/validators/{address}",
    security: []
  }
} as {
  schema: GetValidatorsAddressSchema;
  [QraftServiceOperationsToken]: V1Service["getValidatorsAddress"];
};
/** @summary Estimate the price of a deployment on akash and other cloud providers. */
export const postPricing = {
  schema: {
    method: "post",
    url: "/v1/pricing",
    mediaType: ["application/json"],
    security: []
  }
} as {
  schema: PostPricingSchema;
  [QraftServiceOperationsToken]: V1Service["postPricing"];
};
/** @summary Get a list of gpu models and their availability. */
export const getGpu = {
  schema: {
    method: "get",
    url: "/v1/gpu",
    security: []
  }
} as {
  schema: GetGpuSchema;
  [QraftServiceOperationsToken]: V1Service["getGpu"];
};
/** @summary Get a list of gpu models per vendor. Based on the content from https://raw.githubusercontent.com/akash-network/provider-configs/main/devices/pcie/gpus.json. */
export const getGpuModels = {
  schema: {
    method: "get",
    url: "/v1/gpu-models",
    security: []
  }
} as {
  schema: GetGpuModelsSchema;
  [QraftServiceOperationsToken]: V1Service["getGpuModels"];
};
/** @summary Gets gpu analytics breakdown by vendor and model. If no vendor or model is provided, all GPUs are returned. */
export const getGpuBreakdown = {
  schema: {
    method: "get",
    url: "/v1/gpu-breakdown",
    security: []
  }
} as {
  schema: GetGpuBreakdownSchema;
  [QraftServiceOperationsToken]: V1Service["getGpuBreakdown"];
};
/** @summary Get a list of gpu models with their availability and pricing. */
export const getGpuPrices = {
  schema: {
    method: "get",
    url: "/v1/gpu-prices",
    security: []
  }
} as {
  schema: GetGpuPricesSchema;
  [QraftServiceOperationsToken]: V1Service["getGpuPrices"];
};
export const getProposals = {
  schema: {
    method: "get",
    url: "/v1/proposals",
    security: []
  }
} as {
  schema: GetProposalsSchema;
  [QraftServiceOperationsToken]: V1Service["getProposals"];
};
export const getProposalsId = {
  schema: {
    method: "get",
    url: "/v1/proposals/{id}",
    security: []
  }
} as {
  schema: GetProposalsIdSchema;
  [QraftServiceOperationsToken]: V1Service["getProposalsId"];
};
export const getTemplates = {
  schema: {
    method: "get",
    url: "/v1/templates",
    security: []
  }
} as {
  schema: GetTemplatesSchema;
  [QraftServiceOperationsToken]: V1Service["getTemplates"];
};
export const getTemplatesList = {
  schema: {
    method: "get",
    url: "/v1/templates-list",
    security: []
  }
} as {
  schema: GetTemplatesListSchema;
  [QraftServiceOperationsToken]: V1Service["getTemplatesList"];
};
export const getTemplatesId = {
  schema: {
    method: "get",
    url: "/v1/templates/{id}",
    security: []
  }
} as {
  schema: GetTemplatesIdSchema;
  [QraftServiceOperationsToken]: V1Service["getTemplatesId"];
};
/** @summary Get leases durations. */
export const getLeasesDurationOwner = {
  schema: {
    method: "get",
    url: "/v1/leases-duration/{owner}",
    security: []
  }
} as {
  schema: GetLeasesDurationOwnerSchema;
  [QraftServiceOperationsToken]: V1Service["getLeasesDurationOwner"];
};
/** @summary Get address details */
export const getAddressesAddress = {
  schema: {
    method: "get",
    url: "/v1/addresses/{address}",
    security: []
  }
} as {
  schema: GetAddressesAddressSchema;
  [QraftServiceOperationsToken]: V1Service["getAddressesAddress"];
};
/** @summary Get a list of transactions for a given address. */
export const getAddressesAddressTransactionsSkipLimit = {
  schema: {
    method: "get",
    url: "/v1/addresses/{address}/transactions/{skip}/{limit}",
    security: []
  }
} as {
  schema: GetAddressesAddressTransactionsSkipLimitSchema;
  [QraftServiceOperationsToken]: V1Service["getAddressesAddressTransactionsSkipLimit"];
};
/** @summary Get a list of nodes (api/rpc) for a specific network. */
export const getNodesNetwork = {
  schema: {
    method: "get",
    url: "/v1/nodes/{network}",
    security: []
  }
} as {
  schema: GetNodesNetworkSchema;
  [QraftServiceOperationsToken]: V1Service["getNodesNetwork"];
};
export const createAlert = {
  schema: {
    method: "post",
    url: "/v1/alerts",
    mediaType: ["application/json"]
  }
} as {
  schema: CreateAlertSchema;
  [QraftServiceOperationsToken]: V1Service["createAlert"];
};
export const getAlerts = {
  schema: {
    method: "get",
    url: "/v1/alerts"
  }
} as {
  schema: GetAlertsSchema;
  [QraftServiceOperationsToken]: V1Service["getAlerts"];
};
export const getAlert = {
  schema: {
    method: "get",
    url: "/v1/alerts/{id}"
  }
} as {
  schema: GetAlertSchema;
  [QraftServiceOperationsToken]: V1Service["getAlert"];
};
export const patchAlert = {
  schema: {
    method: "patch",
    url: "/v1/alerts/{id}",
    mediaType: ["application/json"]
  }
} as {
  schema: PatchAlertSchema;
  [QraftServiceOperationsToken]: V1Service["patchAlert"];
};
export const deleteAlert = {
  schema: {
    method: "delete",
    url: "/v1/alerts/{id}"
  }
} as {
  schema: DeleteAlertSchema;
  [QraftServiceOperationsToken]: V1Service["deleteAlert"];
};
export const createNotificationChannel = {
  schema: {
    method: "post",
    url: "/v1/notification-channels",
    mediaType: ["application/json"]
  }
} as {
  schema: CreateNotificationChannelSchema;
  [QraftServiceOperationsToken]: V1Service["createNotificationChannel"];
};
export const getNotificationChannels = {
  schema: {
    method: "get",
    url: "/v1/notification-channels"
  }
} as {
  schema: GetNotificationChannelsSchema;
  [QraftServiceOperationsToken]: V1Service["getNotificationChannels"];
};
export const createDefaultChannel = {
  schema: {
    method: "post",
    url: "/v1/notification-channels/default",
    mediaType: ["application/json"]
  }
} as {
  schema: CreateDefaultChannelSchema;
  [QraftServiceOperationsToken]: V1Service["createDefaultChannel"];
};
export const getNotificationChannel = {
  schema: {
    method: "get",
    url: "/v1/notification-channels/{id}"
  }
} as {
  schema: GetNotificationChannelSchema;
  [QraftServiceOperationsToken]: V1Service["getNotificationChannel"];
};
export const patchNotificationChannel = {
  schema: {
    method: "patch",
    url: "/v1/notification-channels/{id}",
    mediaType: ["application/json"]
  }
} as {
  schema: PatchNotificationChannelSchema;
  [QraftServiceOperationsToken]: V1Service["patchNotificationChannel"];
};
export const deleteNotificationChannel = {
  schema: {
    method: "delete",
    url: "/v1/notification-channels/{id}"
  }
} as {
  schema: DeleteNotificationChannelSchema;
  [QraftServiceOperationsToken]: V1Service["deleteNotificationChannel"];
};
export const upsertDeploymentAlert = {
  schema: {
    method: "post",
    url: "/v1/deployment-alerts/{dseq}",
    mediaType: ["application/json"]
  }
} as {
  schema: UpsertDeploymentAlertSchema;
  [QraftServiceOperationsToken]: V1Service["upsertDeploymentAlert"];
};
export const getDeploymentAlerts = {
  schema: {
    method: "get",
    url: "/v1/deployment-alerts/{dseq}"
  }
} as {
  schema: GetDeploymentAlertsSchema;
  [QraftServiceOperationsToken]: V1Service["getDeploymentAlerts"];
};
export const v1Service = {
  postStartTrial,
  getWallets,
  getWalletSettings,
  postWalletSettings,
  putWalletSettings,
  deleteWalletSettings,
  postTx,
  getCheckout,
  postStripeWebhook,
  getStripePrices,
  postStripeCouponsApply,
  putStripeCustomersOrganization,
  postStripePaymentMethodsSetup,
  postStripePaymentMethodsDefault,
  getStripePaymentMethodsDefault,
  getStripePaymentMethods,
  deleteStripePaymentMethodsPaymentMethodId,
  postStripePaymentMethodsValidate,
  postStripeTransactionsConfirm,
  getStripeTransactions,
  getStripeTransactionsExport,
  getUsageHistory,
  getUsageHistoryStats,
  postAnonymousUsers,
  getAnonymousUsersId,
  postRegisterUser,
  getUserMe,
  postSendVerificationEmail,
  postVerifyEmail,
  getDeploymentSettingsUserIdDseq,
  patchDeploymentSettingsUserIdDseq,
  postDeploymentSettings,
  getDeploymentsDseq,
  deleteDeploymentsDseq,
  putDeploymentsDseq,
  postDeployments,
  getDeployments,
  postDepositDeployment,
  getAddressesAddressDeploymentsSkipLimit,
  getDeploymentOwnerDseq,
  getWeeklyCost,
  postLeases,
  getApiKeys,
  postApiKeys,
  getApiKeysId,
  patchApiKeysId,
  deleteApiKeysId,
  getBids,
  getBidsDseq,
  postCertificates,
  getBalances,
  getProviders,
  getProvidersAddress,
  getProvidersProviderAddressActiveLeasesGraphData,
  getAuditors,
  getProviderAttributesSchema,
  getProviderRegions,
  getProviderDashboardOwner,
  getProviderEarningsOwner,
  getProviderVersions,
  getProviderGraphDataDataName,
  getProvidersProviderDeploymentsSkipLimit,
  postCreateJwtToken,
  getGraphDataDataName,
  getDashboardData,
  getNetworkCapacity,
  getBlocks,
  getBlocksHeight,
  getPredictedBlockDateHeight,
  getPredictedDateHeightTimestamp,
  getTransactions,
  getTransactionsHash,
  getMarketDataCoin,
  getValidators,
  getValidatorsAddress,
  postPricing,
  getGpu,
  getGpuModels,
  getGpuBreakdown,
  getGpuPrices,
  getProposals,
  getProposalsId,
  getTemplates,
  getTemplatesList,
  getTemplatesId,
  getLeasesDurationOwner,
  getAddressesAddress,
  getAddressesAddressTransactionsSkipLimit,
  getNodesNetwork,
  createAlert,
  getAlerts,
  getAlert,
  patchAlert,
  deleteAlert,
  createNotificationChannel,
  getNotificationChannels,
  createDefaultChannel,
  getNotificationChannel,
  patchNotificationChannel,
  deleteNotificationChannel,
  upsertDeploymentAlert,
  getDeploymentAlerts
} as const;
type PostStartTrialSchema = {
  method: "post";
  url: "/v1/start-trial";
  mediaType: ["application/json"];
  security: [];
};
type PostStartTrialParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type PostStartTrialData =
  | paths["/v1/start-trial"]["post"]["responses"]["200"]["content"]["application/json"]
  | paths["/v1/start-trial"]["post"]["responses"]["202"]["content"]["application/json"];
type PostStartTrialError = unknown;
type PostStartTrialBody = NonNullable<paths["/v1/start-trial"]["post"]["requestBody"]>["content"]["application/json"];
type GetWalletsSchema = {
  method: "get";
  url: "/v1/wallets";
  security: ["BearerAuth", "ApiKeyAuth"];
};
type GetWalletsParameters = paths["/v1/wallets"]["get"]["parameters"];
type GetWalletsData = paths["/v1/wallets"]["get"]["responses"]["200"]["content"]["application/json"];
type GetWalletsError = unknown;
type GetWalletSettingsSchema = {
  method: "get";
  url: "/v1/wallet-settings";
  security: ["BearerAuth", "ApiKeyAuth"];
};
type GetWalletSettingsParameters = undefined;
type GetWalletSettingsData = paths["/v1/wallet-settings"]["get"]["responses"]["200"]["content"]["application/json"];
type GetWalletSettingsError = null;
type PostWalletSettingsSchema = {
  method: "post";
  url: "/v1/wallet-settings";
  mediaType: ["application/json"];
  security: ["BearerAuth", "ApiKeyAuth"];
};
type PostWalletSettingsParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type PostWalletSettingsData = paths["/v1/wallet-settings"]["post"]["responses"]["200"]["content"]["application/json"];
type PostWalletSettingsError = null;
type PostWalletSettingsBody = NonNullable<paths["/v1/wallet-settings"]["post"]["requestBody"]>["content"]["application/json"];
type PutWalletSettingsSchema = {
  method: "put";
  url: "/v1/wallet-settings";
  mediaType: ["application/json"];
  security: ["BearerAuth", "ApiKeyAuth"];
};
type PutWalletSettingsParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type PutWalletSettingsData = paths["/v1/wallet-settings"]["put"]["responses"]["200"]["content"]["application/json"];
type PutWalletSettingsError = null;
type PutWalletSettingsBody = NonNullable<paths["/v1/wallet-settings"]["put"]["requestBody"]>["content"]["application/json"];
type DeleteWalletSettingsSchema = {
  method: "delete";
  url: "/v1/wallet-settings";
  security: ["BearerAuth", "ApiKeyAuth"];
};
type DeleteWalletSettingsParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type DeleteWalletSettingsData = null;
type DeleteWalletSettingsError = null;
type DeleteWalletSettingsBody = undefined;
type PostTxSchema = {
  method: "post";
  url: "/v1/tx";
  mediaType: ["application/json"];
  security: ["BearerAuth", "ApiKeyAuth"];
};
type PostTxParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type PostTxData = paths["/v1/tx"]["post"]["responses"]["200"]["content"]["application/json"];
type PostTxError = unknown;
type PostTxBody = NonNullable<paths["/v1/tx"]["post"]["requestBody"]>["content"]["application/json"];
type GetCheckoutSchema = {
  method: "get";
  url: "/v1/checkout";
  security: ["BearerAuth", "ApiKeyAuth"];
};
type GetCheckoutParameters = paths["/v1/checkout"]["get"]["parameters"];
type GetCheckoutData = null;
type GetCheckoutError = unknown;
type PostStripeWebhookSchema = {
  method: "post";
  url: "/v1/stripe-webhook";
  mediaType: ["text/plain"];
  security: [];
};
type PostStripeWebhookParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type PostStripeWebhookData = null;
type PostStripeWebhookError = paths["/v1/stripe-webhook"]["post"]["responses"]["400"]["content"]["application/json"];
type PostStripeWebhookBody = NonNullable<paths["/v1/stripe-webhook"]["post"]["requestBody"]>["content"]["text/plain"];
type GetStripePricesSchema = {
  method: "get";
  url: "/v1/stripe/prices";
  security: ["BearerAuth", "ApiKeyAuth"];
};
type GetStripePricesParameters = undefined;
type GetStripePricesData = paths["/v1/stripe/prices"]["get"]["responses"]["200"]["content"]["application/json"];
type GetStripePricesError = unknown;
type PostStripeCouponsApplySchema = {
  method: "post";
  url: "/v1/stripe/coupons/apply";
  mediaType: ["application/json"];
  security: ["BearerAuth", "ApiKeyAuth"];
};
type PostStripeCouponsApplyParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type PostStripeCouponsApplyData = paths["/v1/stripe/coupons/apply"]["post"]["responses"]["200"]["content"]["application/json"];
type PostStripeCouponsApplyError = unknown;
type PostStripeCouponsApplyBody = NonNullable<paths["/v1/stripe/coupons/apply"]["post"]["requestBody"]>["content"]["application/json"];
type PutStripeCustomersOrganizationSchema = {
  method: "put";
  url: "/v1/stripe/customers/organization";
  mediaType: ["application/json"];
  security: ["BearerAuth", "ApiKeyAuth"];
};
type PutStripeCustomersOrganizationParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type PutStripeCustomersOrganizationData = null;
type PutStripeCustomersOrganizationError = unknown;
type PutStripeCustomersOrganizationBody = NonNullable<paths["/v1/stripe/customers/organization"]["put"]["requestBody"]>["content"]["application/json"];
type PostStripePaymentMethodsSetupSchema = {
  method: "post";
  url: "/v1/stripe/payment-methods/setup";
  security: ["BearerAuth", "ApiKeyAuth"];
};
type PostStripePaymentMethodsSetupParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type PostStripePaymentMethodsSetupData = paths["/v1/stripe/payment-methods/setup"]["post"]["responses"]["200"]["content"]["application/json"];
type PostStripePaymentMethodsSetupError = unknown;
type PostStripePaymentMethodsSetupBody = undefined;
type PostStripePaymentMethodsDefaultSchema = {
  method: "post";
  url: "/v1/stripe/payment-methods/default";
  mediaType: ["application/json"];
  security: ["BearerAuth", "ApiKeyAuth"];
};
type PostStripePaymentMethodsDefaultParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type PostStripePaymentMethodsDefaultData = null;
type PostStripePaymentMethodsDefaultError = unknown;
type PostStripePaymentMethodsDefaultBody = NonNullable<paths["/v1/stripe/payment-methods/default"]["post"]["requestBody"]>["content"]["application/json"];
type GetStripePaymentMethodsDefaultSchema = {
  method: "get";
  url: "/v1/stripe/payment-methods/default";
  security: ["BearerAuth", "ApiKeyAuth"];
};
type GetStripePaymentMethodsDefaultParameters = undefined;
type GetStripePaymentMethodsDefaultData = paths["/v1/stripe/payment-methods/default"]["get"]["responses"]["200"]["content"]["application/json"];
type GetStripePaymentMethodsDefaultError = null;
type GetStripePaymentMethodsSchema = {
  method: "get";
  url: "/v1/stripe/payment-methods";
  security: ["BearerAuth", "ApiKeyAuth"];
};
type GetStripePaymentMethodsParameters = undefined;
type GetStripePaymentMethodsData = paths["/v1/stripe/payment-methods"]["get"]["responses"]["200"]["content"]["application/json"];
type GetStripePaymentMethodsError = unknown;
type DeleteStripePaymentMethodsPaymentMethodIdSchema = {
  method: "delete";
  url: "/v1/stripe/payment-methods/{paymentMethodId}";
  security: ["BearerAuth", "ApiKeyAuth"];
};
type DeleteStripePaymentMethodsPaymentMethodIdParameters = paths["/v1/stripe/payment-methods/{paymentMethodId}"]["delete"]["parameters"];
type DeleteStripePaymentMethodsPaymentMethodIdData = null;
type DeleteStripePaymentMethodsPaymentMethodIdError = unknown;
type DeleteStripePaymentMethodsPaymentMethodIdBody = undefined;
type PostStripePaymentMethodsValidateSchema = {
  method: "post";
  url: "/v1/stripe/payment-methods/validate";
  mediaType: ["application/json"];
  security: ["BearerAuth", "ApiKeyAuth"];
};
type PostStripePaymentMethodsValidateParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type PostStripePaymentMethodsValidateData = paths["/v1/stripe/payment-methods/validate"]["post"]["responses"]["200"]["content"]["application/json"];
type PostStripePaymentMethodsValidateError = unknown;
type PostStripePaymentMethodsValidateBody = NonNullable<paths["/v1/stripe/payment-methods/validate"]["post"]["requestBody"]>["content"]["application/json"];
type PostStripeTransactionsConfirmSchema = {
  method: "post";
  url: "/v1/stripe/transactions/confirm";
  mediaType: ["application/json"];
  security: ["BearerAuth", "ApiKeyAuth"];
};
type PostStripeTransactionsConfirmParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type PostStripeTransactionsConfirmData =
  | paths["/v1/stripe/transactions/confirm"]["post"]["responses"]["200"]["content"]["application/json"]
  | paths["/v1/stripe/transactions/confirm"]["post"]["responses"]["202"]["content"]["application/json"];
type PostStripeTransactionsConfirmError = unknown;
type PostStripeTransactionsConfirmBody = NonNullable<paths["/v1/stripe/transactions/confirm"]["post"]["requestBody"]>["content"]["application/json"];
type GetStripeTransactionsSchema = {
  method: "get";
  url: "/v1/stripe/transactions";
  security: ["BearerAuth", "ApiKeyAuth"];
};
type GetStripeTransactionsParameters = paths["/v1/stripe/transactions"]["get"]["parameters"];
type GetStripeTransactionsData = paths["/v1/stripe/transactions"]["get"]["responses"]["200"]["content"]["application/json"];
type GetStripeTransactionsError = unknown;
type GetStripeTransactionsExportSchema = {
  method: "get";
  url: "/v1/stripe/transactions/export";
  security: ["BearerAuth", "ApiKeyAuth"];
};
type GetStripeTransactionsExportParameters = paths["/v1/stripe/transactions/export"]["get"]["parameters"];
type GetStripeTransactionsExportData = paths["/v1/stripe/transactions/export"]["get"]["responses"]["200"]["content"]["text/csv"];
type GetStripeTransactionsExportError = unknown;
type GetUsageHistorySchema = {
  method: "get";
  url: "/v1/usage/history";
  security: [];
};
type GetUsageHistoryParameters = paths["/v1/usage/history"]["get"]["parameters"];
type GetUsageHistoryData = paths["/v1/usage/history"]["get"]["responses"]["200"]["content"]["application/json"];
type GetUsageHistoryError = null;
type GetUsageHistoryStatsSchema = {
  method: "get";
  url: "/v1/usage/history/stats";
  security: [];
};
type GetUsageHistoryStatsParameters = paths["/v1/usage/history/stats"]["get"]["parameters"];
type GetUsageHistoryStatsData = paths["/v1/usage/history/stats"]["get"]["responses"]["200"]["content"]["application/json"];
type GetUsageHistoryStatsError = null;
type PostAnonymousUsersSchema = {
  method: "post";
  url: "/v1/anonymous-users";
  security: [];
};
type PostAnonymousUsersParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type PostAnonymousUsersData = paths["/v1/anonymous-users"]["post"]["responses"]["200"]["content"]["application/json"];
type PostAnonymousUsersError = unknown;
type PostAnonymousUsersBody = undefined;
type GetAnonymousUsersIdSchema = {
  method: "get";
  url: "/v1/anonymous-users/{id}";
  security: ["BearerAuth", "ApiKeyAuth"];
};
type GetAnonymousUsersIdParameters = paths["/v1/anonymous-users/{id}"]["get"]["parameters"];
type GetAnonymousUsersIdData = paths["/v1/anonymous-users/{id}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetAnonymousUsersIdError = unknown;
type PostRegisterUserSchema = {
  method: "post";
  url: "/v1/register-user";
  mediaType: ["application/json"];
  security: [];
};
type PostRegisterUserParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type PostRegisterUserData = paths["/v1/register-user"]["post"]["responses"]["200"]["content"]["application/json"];
type PostRegisterUserError = unknown;
type PostRegisterUserBody = NonNullable<paths["/v1/register-user"]["post"]["requestBody"]>["content"]["application/json"];
type GetUserMeSchema = {
  method: "get";
  url: "/v1/user/me";
  security: ["BearerAuth", "ApiKeyAuth"];
};
type GetUserMeParameters = undefined;
type GetUserMeData = paths["/v1/user/me"]["get"]["responses"]["200"]["content"]["application/json"];
type GetUserMeError = unknown;
type PostSendVerificationEmailSchema = {
  method: "post";
  url: "/v1/send-verification-email";
  mediaType: ["application/json"];
  security: [];
};
type PostSendVerificationEmailParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type PostSendVerificationEmailData = null;
type PostSendVerificationEmailError = unknown;
type PostSendVerificationEmailBody = paths["/v1/send-verification-email"]["post"]["requestBody"]["content"]["application/json"];
type PostVerifyEmailSchema = {
  method: "post";
  url: "/v1/verify-email";
  mediaType: ["application/json"];
  security: [];
};
type PostVerifyEmailParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type PostVerifyEmailData = paths["/v1/verify-email"]["post"]["responses"]["200"]["content"]["application/json"];
type PostVerifyEmailError = null | null;
type PostVerifyEmailBody = paths["/v1/verify-email"]["post"]["requestBody"]["content"]["application/json"];
type GetDeploymentSettingsUserIdDseqSchema = {
  method: "get";
  url: "/v1/deployment-settings/{userId}/{dseq}";
  security: ["BearerAuth", "ApiKeyAuth"];
};
type GetDeploymentSettingsUserIdDseqParameters = paths["/v1/deployment-settings/{userId}/{dseq}"]["get"]["parameters"];
type GetDeploymentSettingsUserIdDseqData = paths["/v1/deployment-settings/{userId}/{dseq}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetDeploymentSettingsUserIdDseqError = paths["/v1/deployment-settings/{userId}/{dseq}"]["get"]["responses"]["404"]["content"]["application/json"];
type PatchDeploymentSettingsUserIdDseqSchema = {
  method: "patch";
  url: "/v1/deployment-settings/{userId}/{dseq}";
  mediaType: ["application/json"];
  security: ["BearerAuth", "ApiKeyAuth"];
};
type PatchDeploymentSettingsUserIdDseqParameters = paths["/v1/deployment-settings/{userId}/{dseq}"]["patch"]["parameters"];
type PatchDeploymentSettingsUserIdDseqData = paths["/v1/deployment-settings/{userId}/{dseq}"]["patch"]["responses"]["200"]["content"]["application/json"];
type PatchDeploymentSettingsUserIdDseqError = paths["/v1/deployment-settings/{userId}/{dseq}"]["patch"]["responses"]["404"]["content"]["application/json"];
type PatchDeploymentSettingsUserIdDseqBody = NonNullable<
  paths["/v1/deployment-settings/{userId}/{dseq}"]["patch"]["requestBody"]
>["content"]["application/json"];
type PostDeploymentSettingsSchema = {
  method: "post";
  url: "/v1/deployment-settings";
  mediaType: ["application/json"];
  security: ["BearerAuth", "ApiKeyAuth"];
};
type PostDeploymentSettingsParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type PostDeploymentSettingsData = paths["/v1/deployment-settings"]["post"]["responses"]["201"]["content"]["application/json"];
type PostDeploymentSettingsError = unknown;
type PostDeploymentSettingsBody = NonNullable<paths["/v1/deployment-settings"]["post"]["requestBody"]>["content"]["application/json"];
type GetDeploymentsDseqSchema = {
  method: "get";
  url: "/v1/deployments/{dseq}";
  security: ["BearerAuth", "ApiKeyAuth"];
};
type GetDeploymentsDseqParameters = paths["/v1/deployments/{dseq}"]["get"]["parameters"];
type GetDeploymentsDseqData = paths["/v1/deployments/{dseq}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetDeploymentsDseqError = unknown;
type DeleteDeploymentsDseqSchema = {
  method: "delete";
  url: "/v1/deployments/{dseq}";
  security: ["BearerAuth", "ApiKeyAuth"];
};
type DeleteDeploymentsDseqParameters = paths["/v1/deployments/{dseq}"]["delete"]["parameters"];
type DeleteDeploymentsDseqData = paths["/v1/deployments/{dseq}"]["delete"]["responses"]["200"]["content"]["application/json"];
type DeleteDeploymentsDseqError = unknown;
type DeleteDeploymentsDseqBody = undefined;
type PutDeploymentsDseqSchema = {
  method: "put";
  url: "/v1/deployments/{dseq}";
  mediaType: ["application/json"];
  security: ["BearerAuth", "ApiKeyAuth"];
};
type PutDeploymentsDseqParameters = paths["/v1/deployments/{dseq}"]["put"]["parameters"];
type PutDeploymentsDseqData = paths["/v1/deployments/{dseq}"]["put"]["responses"]["200"]["content"]["application/json"];
type PutDeploymentsDseqError = unknown;
type PutDeploymentsDseqBody = NonNullable<paths["/v1/deployments/{dseq}"]["put"]["requestBody"]>["content"]["application/json"];
type PostDeploymentsSchema = {
  method: "post";
  url: "/v1/deployments";
  mediaType: ["application/json"];
  security: ["BearerAuth", "ApiKeyAuth"];
};
type PostDeploymentsParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type PostDeploymentsData = paths["/v1/deployments"]["post"]["responses"]["201"]["content"]["application/json"];
type PostDeploymentsError = unknown;
type PostDeploymentsBody = NonNullable<paths["/v1/deployments"]["post"]["requestBody"]>["content"]["application/json"];
type GetDeploymentsSchema = {
  method: "get";
  url: "/v1/deployments";
  security: ["BearerAuth", "ApiKeyAuth"];
};
type GetDeploymentsParameters = paths["/v1/deployments"]["get"]["parameters"];
type GetDeploymentsData = paths["/v1/deployments"]["get"]["responses"]["200"]["content"]["application/json"];
type GetDeploymentsError = unknown;
type PostDepositDeploymentSchema = {
  method: "post";
  url: "/v1/deposit-deployment";
  mediaType: ["application/json"];
  security: ["BearerAuth", "ApiKeyAuth"];
};
type PostDepositDeploymentParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type PostDepositDeploymentData = paths["/v1/deposit-deployment"]["post"]["responses"]["200"]["content"]["application/json"];
type PostDepositDeploymentError = unknown;
type PostDepositDeploymentBody = NonNullable<paths["/v1/deposit-deployment"]["post"]["requestBody"]>["content"]["application/json"];
type GetAddressesAddressDeploymentsSkipLimitSchema = {
  method: "get";
  url: "/v1/addresses/{address}/deployments/{skip}/{limit}";
  security: [];
};
type GetAddressesAddressDeploymentsSkipLimitParameters = paths["/v1/addresses/{address}/deployments/{skip}/{limit}"]["get"]["parameters"];
type GetAddressesAddressDeploymentsSkipLimitData =
  paths["/v1/addresses/{address}/deployments/{skip}/{limit}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetAddressesAddressDeploymentsSkipLimitError = null;
type GetDeploymentOwnerDseqSchema = {
  method: "get";
  url: "/v1/deployment/{owner}/{dseq}";
  security: [];
};
type GetDeploymentOwnerDseqParameters = paths["/v1/deployment/{owner}/{dseq}"]["get"]["parameters"];
type GetDeploymentOwnerDseqData = paths["/v1/deployment/{owner}/{dseq}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetDeploymentOwnerDseqError = null | null;
type GetWeeklyCostSchema = {
  method: "get";
  url: "/v1/weekly-cost";
  security: ["BearerAuth", "ApiKeyAuth"];
};
type GetWeeklyCostParameters = undefined;
type GetWeeklyCostData = paths["/v1/weekly-cost"]["get"]["responses"]["200"]["content"]["application/json"];
type GetWeeklyCostError = unknown;
type PostLeasesSchema = {
  method: "post";
  url: "/v1/leases";
  mediaType: ["application/json"];
  security: ["BearerAuth", "ApiKeyAuth"];
};
type PostLeasesParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type PostLeasesData = paths["/v1/leases"]["post"]["responses"]["200"]["content"]["application/json"];
type PostLeasesError = unknown;
type PostLeasesBody = NonNullable<paths["/v1/leases"]["post"]["requestBody"]>["content"]["application/json"];
type GetApiKeysSchema = {
  method: "get";
  url: "/v1/api-keys";
  security: ["BearerAuth", "ApiKeyAuth"];
};
type GetApiKeysParameters = undefined;
type GetApiKeysData = paths["/v1/api-keys"]["get"]["responses"]["200"]["content"]["application/json"];
type GetApiKeysError = unknown;
type PostApiKeysSchema = {
  method: "post";
  url: "/v1/api-keys";
  mediaType: ["application/json"];
  security: ["BearerAuth", "ApiKeyAuth"];
};
type PostApiKeysParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type PostApiKeysData = paths["/v1/api-keys"]["post"]["responses"]["201"]["content"]["application/json"];
type PostApiKeysError = unknown;
type PostApiKeysBody = NonNullable<paths["/v1/api-keys"]["post"]["requestBody"]>["content"]["application/json"];
type GetApiKeysIdSchema = {
  method: "get";
  url: "/v1/api-keys/{id}";
  security: ["BearerAuth", "ApiKeyAuth"];
};
type GetApiKeysIdParameters = paths["/v1/api-keys/{id}"]["get"]["parameters"];
type GetApiKeysIdData = paths["/v1/api-keys/{id}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetApiKeysIdError = paths["/v1/api-keys/{id}"]["get"]["responses"]["404"]["content"]["application/json"];
type PatchApiKeysIdSchema = {
  method: "patch";
  url: "/v1/api-keys/{id}";
  mediaType: ["application/json"];
  security: ["BearerAuth", "ApiKeyAuth"];
};
type PatchApiKeysIdParameters = paths["/v1/api-keys/{id}"]["patch"]["parameters"];
type PatchApiKeysIdData = paths["/v1/api-keys/{id}"]["patch"]["responses"]["200"]["content"]["application/json"];
type PatchApiKeysIdError = paths["/v1/api-keys/{id}"]["patch"]["responses"]["404"]["content"]["application/json"];
type PatchApiKeysIdBody = NonNullable<paths["/v1/api-keys/{id}"]["patch"]["requestBody"]>["content"]["application/json"];
type DeleteApiKeysIdSchema = {
  method: "delete";
  url: "/v1/api-keys/{id}";
  security: ["BearerAuth", "ApiKeyAuth"];
};
type DeleteApiKeysIdParameters = paths["/v1/api-keys/{id}"]["delete"]["parameters"];
type DeleteApiKeysIdData = null;
type DeleteApiKeysIdError = paths["/v1/api-keys/{id}"]["delete"]["responses"]["404"]["content"]["application/json"];
type DeleteApiKeysIdBody = undefined;
type GetBidsSchema = {
  method: "get";
  url: "/v1/bids";
  security: ["BearerAuth", "ApiKeyAuth"];
};
type GetBidsParameters = paths["/v1/bids"]["get"]["parameters"];
type GetBidsData = paths["/v1/bids"]["get"]["responses"]["200"]["content"]["application/json"];
type GetBidsError = unknown;
type GetBidsDseqSchema = {
  method: "get";
  url: "/v1/bids/{dseq}";
  security: ["BearerAuth", "ApiKeyAuth"];
};
type GetBidsDseqParameters = paths["/v1/bids/{dseq}"]["get"]["parameters"];
type GetBidsDseqData = paths["/v1/bids/{dseq}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetBidsDseqError = unknown;
type PostCertificatesSchema = {
  method: "post";
  url: "/v1/certificates";
  security: ["BearerAuth", "ApiKeyAuth"];
};
type PostCertificatesParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type PostCertificatesData = paths["/v1/certificates"]["post"]["responses"]["200"]["content"]["application/json"];
type PostCertificatesError = unknown;
type PostCertificatesBody = undefined;
type GetBalancesSchema = {
  method: "get";
  url: "/v1/balances";
  security: [];
};
type GetBalancesParameters = paths["/v1/balances"]["get"]["parameters"];
type GetBalancesData = paths["/v1/balances"]["get"]["responses"]["200"]["content"]["application/json"];
type GetBalancesError = unknown;
type GetProvidersSchema = {
  method: "get";
  url: "/v1/providers";
  security: [];
};
type GetProvidersParameters = paths["/v1/providers"]["get"]["parameters"];
type GetProvidersData = paths["/v1/providers"]["get"]["responses"]["200"]["content"]["application/json"];
type GetProvidersError = unknown;
type GetProvidersAddressSchema = {
  method: "get";
  url: "/v1/providers/{address}";
  security: [];
};
type GetProvidersAddressParameters = paths["/v1/providers/{address}"]["get"]["parameters"];
type GetProvidersAddressData = paths["/v1/providers/{address}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetProvidersAddressError = null | null;
type GetProvidersProviderAddressActiveLeasesGraphDataSchema = {
  method: "get";
  url: "/v1/providers/{providerAddress}/active-leases-graph-data";
  security: [];
};
type GetProvidersProviderAddressActiveLeasesGraphDataParameters = paths["/v1/providers/{providerAddress}/active-leases-graph-data"]["get"]["parameters"];
type GetProvidersProviderAddressActiveLeasesGraphDataData =
  paths["/v1/providers/{providerAddress}/active-leases-graph-data"]["get"]["responses"]["200"]["content"]["application/json"];
type GetProvidersProviderAddressActiveLeasesGraphDataError = null;
type GetAuditorsSchema = {
  method: "get";
  url: "/v1/auditors";
  security: [];
};
type GetAuditorsParameters = undefined;
type GetAuditorsData = paths["/v1/auditors"]["get"]["responses"]["200"]["content"]["application/json"];
type GetAuditorsError = unknown;
type GetProviderAttributesSchemaSchema = {
  method: "get";
  url: "/v1/provider-attributes-schema";
  security: [];
};
type GetProviderAttributesSchemaParameters = undefined;
type GetProviderAttributesSchemaData = paths["/v1/provider-attributes-schema"]["get"]["responses"]["200"]["content"]["application/json"];
type GetProviderAttributesSchemaError = unknown;
type GetProviderRegionsSchema = {
  method: "get";
  url: "/v1/provider-regions";
  security: [];
};
type GetProviderRegionsParameters = undefined;
type GetProviderRegionsData = paths["/v1/provider-regions"]["get"]["responses"]["200"]["content"]["application/json"];
type GetProviderRegionsError = unknown;
type GetProviderDashboardOwnerSchema = {
  method: "get";
  url: "/v1/provider-dashboard/{owner}";
  security: [];
};
type GetProviderDashboardOwnerParameters = paths["/v1/provider-dashboard/{owner}"]["get"]["parameters"];
type GetProviderDashboardOwnerData = paths["/v1/provider-dashboard/{owner}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetProviderDashboardOwnerError = null;
type GetProviderEarningsOwnerSchema = {
  method: "get";
  url: "/v1/provider-earnings/{owner}";
  security: [];
};
type GetProviderEarningsOwnerParameters = paths["/v1/provider-earnings/{owner}"]["get"]["parameters"];
type GetProviderEarningsOwnerData = paths["/v1/provider-earnings/{owner}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetProviderEarningsOwnerError = null;
type GetProviderVersionsSchema = {
  method: "get";
  url: "/v1/provider-versions";
  security: [];
};
type GetProviderVersionsParameters = undefined;
type GetProviderVersionsData = paths["/v1/provider-versions"]["get"]["responses"]["200"]["content"]["application/json"];
type GetProviderVersionsError = unknown;
type GetProviderGraphDataDataNameSchema = {
  method: "get";
  url: "/v1/provider-graph-data/{dataName}";
  security: [];
};
type GetProviderGraphDataDataNameParameters = paths["/v1/provider-graph-data/{dataName}"]["get"]["parameters"];
type GetProviderGraphDataDataNameData = paths["/v1/provider-graph-data/{dataName}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetProviderGraphDataDataNameError = null;
type GetProvidersProviderDeploymentsSkipLimitSchema = {
  method: "get";
  url: "/v1/providers/{provider}/deployments/{skip}/{limit}";
  security: [];
};
type GetProvidersProviderDeploymentsSkipLimitParameters = paths["/v1/providers/{provider}/deployments/{skip}/{limit}"]["get"]["parameters"];
type GetProvidersProviderDeploymentsSkipLimitData =
  paths["/v1/providers/{provider}/deployments/{skip}/{limit}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetProvidersProviderDeploymentsSkipLimitError = null;
type PostCreateJwtTokenSchema = {
  method: "post";
  url: "/v1/create-jwt-token";
  mediaType: ["application/json"];
  security: ["BearerAuth", "ApiKeyAuth"];
};
type PostCreateJwtTokenParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type PostCreateJwtTokenData = paths["/v1/create-jwt-token"]["post"]["responses"]["201"]["content"]["application/json"];
type PostCreateJwtTokenError = unknown;
type PostCreateJwtTokenBody = NonNullable<paths["/v1/create-jwt-token"]["post"]["requestBody"]>["content"]["application/json"];
type GetGraphDataDataNameSchema = {
  method: "get";
  url: "/v1/graph-data/{dataName}";
  security: [];
};
type GetGraphDataDataNameParameters = paths["/v1/graph-data/{dataName}"]["get"]["parameters"];
type GetGraphDataDataNameData = paths["/v1/graph-data/{dataName}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetGraphDataDataNameError = null;
type GetDashboardDataSchema = {
  method: "get";
  url: "/v1/dashboard-data";
  security: [];
};
type GetDashboardDataParameters = undefined;
type GetDashboardDataData = paths["/v1/dashboard-data"]["get"]["responses"]["200"]["content"]["application/json"];
type GetDashboardDataError = unknown;
type GetNetworkCapacitySchema = {
  method: "get";
  url: "/v1/network-capacity";
  security: [];
};
type GetNetworkCapacityParameters = undefined;
type GetNetworkCapacityData = paths["/v1/network-capacity"]["get"]["responses"]["200"]["content"]["application/json"];
type GetNetworkCapacityError = unknown;
type GetBlocksSchema = {
  method: "get";
  url: "/v1/blocks";
  security: [];
};
type GetBlocksParameters = paths["/v1/blocks"]["get"]["parameters"];
type GetBlocksData = paths["/v1/blocks"]["get"]["responses"]["200"]["content"]["application/json"];
type GetBlocksError = unknown;
type GetBlocksHeightSchema = {
  method: "get";
  url: "/v1/blocks/{height}";
  security: [];
};
type GetBlocksHeightParameters = paths["/v1/blocks/{height}"]["get"]["parameters"];
type GetBlocksHeightData = paths["/v1/blocks/{height}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetBlocksHeightError = null | null;
type GetPredictedBlockDateHeightSchema = {
  method: "get";
  url: "/v1/predicted-block-date/{height}";
  security: [];
};
type GetPredictedBlockDateHeightParameters = paths["/v1/predicted-block-date/{height}"]["get"]["parameters"];
type GetPredictedBlockDateHeightData = paths["/v1/predicted-block-date/{height}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetPredictedBlockDateHeightError = null;
type GetPredictedDateHeightTimestampSchema = {
  method: "get";
  url: "/v1/predicted-date-height/{timestamp}";
  security: [];
};
type GetPredictedDateHeightTimestampParameters = paths["/v1/predicted-date-height/{timestamp}"]["get"]["parameters"];
type GetPredictedDateHeightTimestampData = paths["/v1/predicted-date-height/{timestamp}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetPredictedDateHeightTimestampError = null;
type GetTransactionsSchema = {
  method: "get";
  url: "/v1/transactions";
  security: [];
};
type GetTransactionsParameters = paths["/v1/transactions"]["get"]["parameters"];
type GetTransactionsData = paths["/v1/transactions"]["get"]["responses"]["200"]["content"]["application/json"];
type GetTransactionsError = unknown;
type GetTransactionsHashSchema = {
  method: "get";
  url: "/v1/transactions/{hash}";
  security: [];
};
type GetTransactionsHashParameters = paths["/v1/transactions/{hash}"]["get"]["parameters"];
type GetTransactionsHashData = paths["/v1/transactions/{hash}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetTransactionsHashError = null;
type GetMarketDataCoinSchema = {
  method: "get";
  url: "/v1/market-data/{coin}";
  security: [];
};
type GetMarketDataCoinParameters = paths["/v1/market-data/{coin}"]["get"]["parameters"];
type GetMarketDataCoinData = paths["/v1/market-data/{coin}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetMarketDataCoinError = unknown;
type GetValidatorsSchema = {
  method: "get";
  url: "/v1/validators";
  security: [];
};
type GetValidatorsParameters = undefined;
type GetValidatorsData = paths["/v1/validators"]["get"]["responses"]["200"]["content"]["application/json"];
type GetValidatorsError = unknown;
type GetValidatorsAddressSchema = {
  method: "get";
  url: "/v1/validators/{address}";
  security: [];
};
type GetValidatorsAddressParameters = paths["/v1/validators/{address}"]["get"]["parameters"];
type GetValidatorsAddressData = paths["/v1/validators/{address}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetValidatorsAddressError = null | null;
type PostPricingSchema = {
  method: "post";
  url: "/v1/pricing";
  mediaType: ["application/json"];
  security: [];
};
type PostPricingParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type PostPricingData = paths["/v1/pricing"]["post"]["responses"]["200"]["content"]["application/json"];
type PostPricingError = null;
type PostPricingBody = NonNullable<paths["/v1/pricing"]["post"]["requestBody"]>["content"]["application/json"];
type GetGpuSchema = {
  method: "get";
  url: "/v1/gpu";
  security: [];
};
type GetGpuParameters = paths["/v1/gpu"]["get"]["parameters"];
type GetGpuData = paths["/v1/gpu"]["get"]["responses"]["200"]["content"]["application/json"];
type GetGpuError = null;
type GetGpuModelsSchema = {
  method: "get";
  url: "/v1/gpu-models";
  security: [];
};
type GetGpuModelsParameters = undefined;
type GetGpuModelsData = paths["/v1/gpu-models"]["get"]["responses"]["200"]["content"]["application/json"];
type GetGpuModelsError = unknown;
type GetGpuBreakdownSchema = {
  method: "get";
  url: "/v1/gpu-breakdown";
  security: [];
};
type GetGpuBreakdownParameters = paths["/v1/gpu-breakdown"]["get"]["parameters"];
type GetGpuBreakdownData = paths["/v1/gpu-breakdown"]["get"]["responses"]["200"]["content"]["application/json"];
type GetGpuBreakdownError = unknown;
type GetGpuPricesSchema = {
  method: "get";
  url: "/v1/gpu-prices";
  security: [];
};
type GetGpuPricesParameters = undefined;
type GetGpuPricesData = paths["/v1/gpu-prices"]["get"]["responses"]["200"]["content"]["application/json"];
type GetGpuPricesError = unknown;
type GetProposalsSchema = {
  method: "get";
  url: "/v1/proposals";
  security: [];
};
type GetProposalsParameters = undefined;
type GetProposalsData = paths["/v1/proposals"]["get"]["responses"]["200"]["content"]["application/json"];
type GetProposalsError = unknown;
type GetProposalsIdSchema = {
  method: "get";
  url: "/v1/proposals/{id}";
  security: [];
};
type GetProposalsIdParameters = paths["/v1/proposals/{id}"]["get"]["parameters"];
type GetProposalsIdData = paths["/v1/proposals/{id}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetProposalsIdError = null | null;
type GetTemplatesSchema = {
  method: "get";
  url: "/v1/templates";
  security: [];
};
type GetTemplatesParameters = undefined;
type GetTemplatesData = paths["/v1/templates"]["get"]["responses"]["200"]["content"]["application/json"];
type GetTemplatesError = unknown;
type GetTemplatesListSchema = {
  method: "get";
  url: "/v1/templates-list";
  security: [];
};
type GetTemplatesListParameters = undefined;
type GetTemplatesListData = paths["/v1/templates-list"]["get"]["responses"]["200"]["content"]["application/json"];
type GetTemplatesListError = unknown;
type GetTemplatesIdSchema = {
  method: "get";
  url: "/v1/templates/{id}";
  security: [];
};
type GetTemplatesIdParameters = paths["/v1/templates/{id}"]["get"]["parameters"];
type GetTemplatesIdData = paths["/v1/templates/{id}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetTemplatesIdError = null;
type GetLeasesDurationOwnerSchema = {
  method: "get";
  url: "/v1/leases-duration/{owner}";
  security: [];
};
type GetLeasesDurationOwnerParameters = paths["/v1/leases-duration/{owner}"]["get"]["parameters"];
type GetLeasesDurationOwnerData = paths["/v1/leases-duration/{owner}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetLeasesDurationOwnerError = null;
type GetAddressesAddressSchema = {
  method: "get";
  url: "/v1/addresses/{address}";
  security: [];
};
type GetAddressesAddressParameters = paths["/v1/addresses/{address}"]["get"]["parameters"];
type GetAddressesAddressData = paths["/v1/addresses/{address}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetAddressesAddressError = null;
type GetAddressesAddressTransactionsSkipLimitSchema = {
  method: "get";
  url: "/v1/addresses/{address}/transactions/{skip}/{limit}";
  security: [];
};
type GetAddressesAddressTransactionsSkipLimitParameters = paths["/v1/addresses/{address}/transactions/{skip}/{limit}"]["get"]["parameters"];
type GetAddressesAddressTransactionsSkipLimitData =
  paths["/v1/addresses/{address}/transactions/{skip}/{limit}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetAddressesAddressTransactionsSkipLimitError = null;
type GetNodesNetworkSchema = {
  method: "get";
  url: "/v1/nodes/{network}";
  security: [];
};
type GetNodesNetworkParameters = paths["/v1/nodes/{network}"]["get"]["parameters"];
type GetNodesNetworkData = paths["/v1/nodes/{network}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetNodesNetworkError = unknown;
type CreateAlertSchema = {
  method: "post";
  url: "/v1/alerts";
  mediaType: ["application/json"];
};
type CreateAlertParameters = paths["/v1/alerts"]["post"]["parameters"];
type CreateAlertData = paths["/v1/alerts"]["post"]["responses"]["201"]["content"]["application/json"];
type CreateAlertError =
  | paths["/v1/alerts"]["post"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/alerts"]["post"]["responses"]["401"]["content"]["application/json"]
  | paths["/v1/alerts"]["post"]["responses"]["403"]["content"]["application/json"]
  | paths["/v1/alerts"]["post"]["responses"]["500"]["content"]["application/json"];
type CreateAlertBody = paths["/v1/alerts"]["post"]["requestBody"]["content"]["application/json"];
type GetAlertsSchema = {
  method: "get";
  url: "/v1/alerts";
};
type GetAlertsParameters = paths["/v1/alerts"]["get"]["parameters"];
type GetAlertsData = paths["/v1/alerts"]["get"]["responses"]["200"]["content"]["application/json"];
type GetAlertsError =
  | paths["/v1/alerts"]["get"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/alerts"]["get"]["responses"]["401"]["content"]["application/json"]
  | paths["/v1/alerts"]["get"]["responses"]["403"]["content"]["application/json"]
  | paths["/v1/alerts"]["get"]["responses"]["500"]["content"]["application/json"];
type GetAlertSchema = {
  method: "get";
  url: "/v1/alerts/{id}";
};
type GetAlertParameters = paths["/v1/alerts/{id}"]["get"]["parameters"];
type GetAlertData = paths["/v1/alerts/{id}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetAlertError =
  | paths["/v1/alerts/{id}"]["get"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/alerts/{id}"]["get"]["responses"]["401"]["content"]["application/json"]
  | paths["/v1/alerts/{id}"]["get"]["responses"]["403"]["content"]["application/json"]
  | paths["/v1/alerts/{id}"]["get"]["responses"]["500"]["content"]["application/json"];
type PatchAlertSchema = {
  method: "patch";
  url: "/v1/alerts/{id}";
  mediaType: ["application/json"];
};
type PatchAlertParameters = paths["/v1/alerts/{id}"]["patch"]["parameters"];
type PatchAlertData = paths["/v1/alerts/{id}"]["patch"]["responses"]["200"]["content"]["application/json"];
type PatchAlertError =
  | paths["/v1/alerts/{id}"]["patch"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/alerts/{id}"]["patch"]["responses"]["401"]["content"]["application/json"]
  | paths["/v1/alerts/{id}"]["patch"]["responses"]["403"]["content"]["application/json"]
  | paths["/v1/alerts/{id}"]["patch"]["responses"]["500"]["content"]["application/json"];
type PatchAlertBody = paths["/v1/alerts/{id}"]["patch"]["requestBody"]["content"]["application/json"];
type DeleteAlertSchema = {
  method: "delete";
  url: "/v1/alerts/{id}";
};
type DeleteAlertParameters = paths["/v1/alerts/{id}"]["delete"]["parameters"];
type DeleteAlertData = paths["/v1/alerts/{id}"]["delete"]["responses"]["200"]["content"]["application/json"];
type DeleteAlertError =
  | paths["/v1/alerts/{id}"]["delete"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/alerts/{id}"]["delete"]["responses"]["401"]["content"]["application/json"]
  | paths["/v1/alerts/{id}"]["delete"]["responses"]["403"]["content"]["application/json"]
  | paths["/v1/alerts/{id}"]["delete"]["responses"]["500"]["content"]["application/json"];
type DeleteAlertBody = undefined;
type CreateNotificationChannelSchema = {
  method: "post";
  url: "/v1/notification-channels";
  mediaType: ["application/json"];
};
type CreateNotificationChannelParameters = paths["/v1/notification-channels"]["post"]["parameters"];
type CreateNotificationChannelData = paths["/v1/notification-channels"]["post"]["responses"]["201"]["content"]["application/json"];
type CreateNotificationChannelError =
  | paths["/v1/notification-channels"]["post"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/notification-channels"]["post"]["responses"]["401"]["content"]["application/json"]
  | paths["/v1/notification-channels"]["post"]["responses"]["403"]["content"]["application/json"]
  | paths["/v1/notification-channels"]["post"]["responses"]["500"]["content"]["application/json"];
type CreateNotificationChannelBody = paths["/v1/notification-channels"]["post"]["requestBody"]["content"]["application/json"];
type GetNotificationChannelsSchema = {
  method: "get";
  url: "/v1/notification-channels";
};
type GetNotificationChannelsParameters = paths["/v1/notification-channels"]["get"]["parameters"];
type GetNotificationChannelsData = paths["/v1/notification-channels"]["get"]["responses"]["200"]["content"]["application/json"];
type GetNotificationChannelsError =
  | paths["/v1/notification-channels"]["get"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/notification-channels"]["get"]["responses"]["401"]["content"]["application/json"]
  | paths["/v1/notification-channels"]["get"]["responses"]["403"]["content"]["application/json"]
  | paths["/v1/notification-channels"]["get"]["responses"]["500"]["content"]["application/json"];
type CreateDefaultChannelSchema = {
  method: "post";
  url: "/v1/notification-channels/default";
  mediaType: ["application/json"];
};
type CreateDefaultChannelParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type CreateDefaultChannelData = null;
type CreateDefaultChannelError = unknown;
type CreateDefaultChannelBody = paths["/v1/notification-channels/default"]["post"]["requestBody"]["content"]["application/json"];
type GetNotificationChannelSchema = {
  method: "get";
  url: "/v1/notification-channels/{id}";
};
type GetNotificationChannelParameters = paths["/v1/notification-channels/{id}"]["get"]["parameters"];
type GetNotificationChannelData = paths["/v1/notification-channels/{id}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetNotificationChannelError =
  | paths["/v1/notification-channels/{id}"]["get"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/notification-channels/{id}"]["get"]["responses"]["401"]["content"]["application/json"]
  | paths["/v1/notification-channels/{id}"]["get"]["responses"]["403"]["content"]["application/json"]
  | paths["/v1/notification-channels/{id}"]["get"]["responses"]["404"]["content"]["application/json"]
  | paths["/v1/notification-channels/{id}"]["get"]["responses"]["500"]["content"]["application/json"];
type PatchNotificationChannelSchema = {
  method: "patch";
  url: "/v1/notification-channels/{id}";
  mediaType: ["application/json"];
};
type PatchNotificationChannelParameters = paths["/v1/notification-channels/{id}"]["patch"]["parameters"];
type PatchNotificationChannelData = paths["/v1/notification-channels/{id}"]["patch"]["responses"]["200"]["content"]["application/json"];
type PatchNotificationChannelError =
  | paths["/v1/notification-channels/{id}"]["patch"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/notification-channels/{id}"]["patch"]["responses"]["401"]["content"]["application/json"]
  | paths["/v1/notification-channels/{id}"]["patch"]["responses"]["403"]["content"]["application/json"]
  | paths["/v1/notification-channels/{id}"]["patch"]["responses"]["404"]["content"]["application/json"]
  | paths["/v1/notification-channels/{id}"]["patch"]["responses"]["500"]["content"]["application/json"];
type PatchNotificationChannelBody = paths["/v1/notification-channels/{id}"]["patch"]["requestBody"]["content"]["application/json"];
type DeleteNotificationChannelSchema = {
  method: "delete";
  url: "/v1/notification-channels/{id}";
};
type DeleteNotificationChannelParameters = paths["/v1/notification-channels/{id}"]["delete"]["parameters"];
type DeleteNotificationChannelData = paths["/v1/notification-channels/{id}"]["delete"]["responses"]["200"]["content"]["application/json"];
type DeleteNotificationChannelError =
  | paths["/v1/notification-channels/{id}"]["delete"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/notification-channels/{id}"]["delete"]["responses"]["401"]["content"]["application/json"]
  | paths["/v1/notification-channels/{id}"]["delete"]["responses"]["403"]["content"]["application/json"]
  | paths["/v1/notification-channels/{id}"]["delete"]["responses"]["404"]["content"]["application/json"]
  | paths["/v1/notification-channels/{id}"]["delete"]["responses"]["500"]["content"]["application/json"];
type DeleteNotificationChannelBody = undefined;
type UpsertDeploymentAlertSchema = {
  method: "post";
  url: "/v1/deployment-alerts/{dseq}";
  mediaType: ["application/json"];
};
type UpsertDeploymentAlertParameters = paths["/v1/deployment-alerts/{dseq}"]["post"]["parameters"];
type UpsertDeploymentAlertData = paths["/v1/deployment-alerts/{dseq}"]["post"]["responses"]["201"]["content"]["application/json"];
type UpsertDeploymentAlertError =
  | paths["/v1/deployment-alerts/{dseq}"]["post"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/deployment-alerts/{dseq}"]["post"]["responses"]["401"]["content"]["application/json"]
  | paths["/v1/deployment-alerts/{dseq}"]["post"]["responses"]["403"]["content"]["application/json"]
  | paths["/v1/deployment-alerts/{dseq}"]["post"]["responses"]["500"]["content"]["application/json"];
type UpsertDeploymentAlertBody = paths["/v1/deployment-alerts/{dseq}"]["post"]["requestBody"]["content"]["application/json"];
type GetDeploymentAlertsSchema = {
  method: "get";
  url: "/v1/deployment-alerts/{dseq}";
};
type GetDeploymentAlertsParameters = paths["/v1/deployment-alerts/{dseq}"]["get"]["parameters"];
type GetDeploymentAlertsData = paths["/v1/deployment-alerts/{dseq}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetDeploymentAlertsError =
  | paths["/v1/deployment-alerts/{dseq}"]["get"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/deployment-alerts/{dseq}"]["get"]["responses"]["401"]["content"]["application/json"]
  | paths["/v1/deployment-alerts/{dseq}"]["get"]["responses"]["403"]["content"]["application/json"]
  | paths["/v1/deployment-alerts/{dseq}"]["get"]["responses"]["500"]["content"]["application/json"];
