/**
 * This file was auto-generated by @openapi-qraft/cli.
 * Do not make direct changes to the file.
 */

import type {
  DeepReadonly,
  InvalidateQueryFilters,
  MutationFiltersByMutationKey,
  MutationFiltersByParameters,
  MutationVariables,
  OperationInfiniteData,
  PartialParameters,
  QueryFiltersByParameters,
  QueryFiltersByQueryKey,
  QueryFnOptionsByParameters,
  QueryFnOptionsByQueryKey,
  RequestFnResponse,
  ServiceOperationEnsureInfiniteQueryDataOptions,
  ServiceOperationEnsureQueryDataOptions,
  ServiceOperationFetchInfiniteQueryOptions,
  ServiceOperationFetchQueryOptions,
  ServiceOperationInfiniteQueryKey,
  ServiceOperationMutationFnOptions,
  ServiceOperationMutationKey,
  ServiceOperationQueryKey,
  ServiceOperationUseMutationOptions,
  UseQueryOptionsForUseQueries,
  UseQueryOptionsForUseSuspenseQuery,
  WithOptional
} from "@openapi-qraft/tanstack-query-react-types";
import type {
  CancelOptions,
  InfiniteQueryPageParamsOptions,
  InvalidateOptions,
  Mutation,
  MutationState,
  NoInfer,
  QueryState,
  RefetchOptions,
  ResetOptions,
  SetDataOptions,
  Updater
} from "@tanstack/query-core";
import type {
  DefinedInitialDataInfiniteOptions,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  UndefinedInitialDataInfiniteOptions,
  UndefinedInitialDataOptions,
  UseInfiniteQueryResult,
  UseMutationResult,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from "@tanstack/react-query";

import type { paths } from "../schema";
export interface ContactPointsService {
  createContactPoint: {
    /**/
    getMutationKey(
      parameters: DeepReadonly<CreateContactPointParameters> | void
    ): ServiceOperationMutationKey<CreateContactPointSchema, CreateContactPointParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.contactPointsService.createContactPoint.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.contactPointsService.createContactPoint.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends CreateContactPointBody, TContext = unknown>(
      parameters: DeepReadonly<CreateContactPointParameters>,
      options?: ServiceOperationUseMutationOptions<
        CreateContactPointSchema,
        CreateContactPointData,
        CreateContactPointParameters,
        TVariables,
        CreateContactPointError | Error,
        TContext
      >
    ): UseMutationResult<CreateContactPointData, CreateContactPointError | Error, TVariables, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.contactPointsService.createContactPoint.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.contactPointsService.createContactPoint.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<CreateContactPointBody, CreateContactPointParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        CreateContactPointSchema,
        CreateContactPointData,
        CreateContactPointParameters,
        TVariables,
        CreateContactPointError | Error,
        TContext
      >
    ): UseMutationResult<CreateContactPointData, CreateContactPointError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const createContactPointTotal = qraft.contactPointsService.createContactPoint.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const createContactPointTotal = qraft.contactPointsService.createContactPoint.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<CreateContactPointBody, CreateContactPointData, CreateContactPointParameters, CreateContactPointError | Error, TContext>
        | MutationFiltersByMutationKey<
            CreateContactPointSchema,
            CreateContactPointBody,
            CreateContactPointData,
            CreateContactPointParameters,
            CreateContactPointError | Error,
            TContext
          >
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<CreateContactPointBody, CreateContactPointData, CreateContactPointParameters, CreateContactPointError | Error, TContext>
        | MutationFiltersByMutationKey<
            CreateContactPointSchema,
            CreateContactPointBody,
            CreateContactPointData,
            CreateContactPointParameters,
            CreateContactPointError | Error,
            TContext
          >
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<CreateContactPointBody, CreateContactPointParameters>,
      client?: (
        schema: CreateContactPointSchema,
        options: ServiceOperationMutationFnOptions<CreateContactPointBody, CreateContactPointParameters>
      ) => Promise<RequestFnResponse<CreateContactPointData, CreateContactPointError>>
    ): Promise<RequestFnResponse<CreateContactPointData, CreateContactPointError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const createContactPointPendingMutationVariables = qraft.contactPointsService.createContactPoint.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const createContactPointMutationData = qraft.contactPointsService.createContactPoint.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        CreateContactPointData,
        CreateContactPointError | Error,
        MutationVariables<CreateContactPointBody, CreateContactPointParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<CreateContactPointBody, CreateContactPointData, CreateContactPointParameters, CreateContactPointError | Error, TContext>
        | MutationFiltersByMutationKey<
            CreateContactPointSchema,
            CreateContactPointBody,
            CreateContactPointData,
            CreateContactPointParameters,
            CreateContactPointError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          CreateContactPointData,
          CreateContactPointError | Error,
          MutationVariables<CreateContactPointBody, CreateContactPointParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: CreateContactPointSchema;
    types: {
      parameters: CreateContactPointParameters;
      data: CreateContactPointData;
      error: CreateContactPointError;
      body: CreateContactPointBody;
    };
  };
  getContactPoint: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>
        | QueryFiltersByQueryKey<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(parameters: DeepReadonly<GetContactPointParameters>): ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.contactPointsService.getContactPoint.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetContactPointData>(
      parameters: ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters> | DeepReadonly<GetContactPointParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetContactPointData,
          GetContactPointError,
          TData,
          ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetContactPointError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.contactPointsService.getContactPoint.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetContactPointData>(
      parameters: ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters> | DeepReadonly<GetContactPointParameters>,
      options: Omit<
        DefinedInitialDataOptions<GetContactPointData, GetContactPointError, TData, ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetContactPointError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetContactPointParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetContactPointSchema,
        GetContactPointData,
        GetContactPointParameters,
        DeepReadonly<TPageParam>,
        GetContactPointError
      >
    ): Promise<OperationInfiniteData<GetContactPointData, GetContactPointParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetContactPointParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetContactPointSchema,
        GetContactPointData,
        GetContactPointParameters,
        DeepReadonly<TPageParam>,
        GetContactPointError
      >
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetContactPointParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetContactPointSchema,
        GetContactPointData,
        GetContactPointParameters,
        DeepReadonly<TPageParam>,
        GetContactPointError
      >
    ): Promise<OperationInfiniteData<GetContactPointData, GetContactPointParameters>>;
    /**/
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetContactPointSchema, GetContactPointData, GetContactPointParameters, GetContactPointError>
    ): Promise<GetContactPointData>;
    /**/
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetContactPointSchema, GetContactPointData, GetContactPointParameters, GetContactPointError>
    ): Promise<void>;
    /**/
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetContactPointSchema, GetContactPointData, GetContactPointParameters, GetContactPointError>
    ): Promise<GetContactPointData>;
    /**/
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetContactPointSchema, GetContactPointParameters> | DeepReadonly<GetContactPointParameters>
    ): OperationInfiniteData<GetContactPointData, GetContactPointParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>
        | QueryFiltersByQueryKey<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetContactPointSchema, GetContactPointParameters>,
            data: NoInfer<OperationInfiniteData<GetContactPointData, GetContactPointParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters>, data: GetContactPointData | undefined]>;
    /**/
    getQueryData(
      parameters: ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters> | DeepReadonly<GetContactPointParameters>
    ): GetContactPointData | undefined;
    /**/
    getQueryState(
      parameters: ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters> | DeepReadonly<GetContactPointParameters>
    ): QueryState<GetContactPointData, GetContactPointError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters: DeepReadonly<GetContactPointParameters> | ServiceOperationInfiniteQueryKey<GetContactPointSchema, GetContactPointParameters>
    ): QueryState<OperationInfiniteData<GetContactPointData, GetContactPointParameters>, GetContactPointError> | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>
        | QueryFiltersByQueryKey<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetContactPointSchema, GetContactPointParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetContactPointParameters, TMeta, TSignal>,
      client?: (
        schema: GetContactPointSchema,
        options: {
          parameters: GetContactPointParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetContactPointData, GetContactPointError>>
    ): Promise<RequestFnResponse<GetContactPointData, GetContactPointError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>
        | QueryFiltersByQueryKey<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>
        | QueryFiltersByQueryKey<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>
        | QueryFiltersByQueryKey<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters: DeepReadonly<GetContactPointParameters> | ServiceOperationInfiniteQueryKey<GetContactPointSchema, GetContactPointParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetContactPointData, GetContactPointParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetContactPointData, GetContactPointParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetContactPointData, GetContactPointParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>
        | QueryFiltersByQueryKey<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>,
      updater: Updater<NoInfer<GetContactPointData> | undefined, NoInfer<GetContactPointData> | undefined>,
      options?: SetDataOptions
    ): Array<GetContactPointData | undefined>;
    /**/
    setQueryData(
      parameters: DeepReadonly<GetContactPointParameters> | ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters>,
      updater: Updater<NoInfer<GetContactPointData> | undefined, NoInfer<DeepReadonly<GetContactPointData>> | undefined>,
      options?: SetDataOptions
    ): GetContactPointData | undefined;
    /**/
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetContactPointParameters>
    ): ServiceOperationInfiniteQueryKey<GetContactPointSchema, GetContactPointParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.contactPointsService.getContactPoint.useInfiniteQuery({
     *     path: {
     *         id: id
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetContactPointParameters,
      TQueryFnData = GetContactPointData,
      TData = OperationInfiniteData<TQueryFnData, GetContactPointParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetContactPointSchema, GetContactPointParameters> | DeepReadonly<GetContactPointParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetContactPointError,
          TData,
          ServiceOperationInfiniteQueryKey<GetContactPointSchema, GetContactPointParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetContactPointError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.contactPointsService.getContactPoint.useInfiniteQuery({
     *     path: {
     *         id: id
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetContactPointParameters,
      TQueryFnData = GetContactPointData,
      TData = OperationInfiniteData<TQueryFnData, GetContactPointParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetContactPointSchema, GetContactPointParameters> | DeepReadonly<GetContactPointParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetContactPointError,
          TData,
          ServiceOperationInfiniteQueryKey<GetContactPointSchema, GetContactPointParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetContactPointData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetContactPointError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getContactPointTotal = qraft.contactPointsService.getContactPoint.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getContactPointByParametersTotal = qraft.contactPointsService.getContactPoint.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             id: id
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>
        | QueryFiltersByQueryKey<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getContactPointResults = qraft.contactPointsService.getContactPoint.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getContactPointResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getContactPointCombinedResults = qraft.contactPointsService.getContactPoint.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getContactPointCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetContactPointSchema, GetContactPointParameters, GetContactPointData, GetContactPointError>>,
      TCombinedResult = Array<UseQueryResult<GetContactPointData, GetContactPointError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetContactPointData, GetContactPointError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(parameters: DeepReadonly<GetContactPointParameters>): ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.contactPointsService.getContactPoint.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetContactPointData>(
      parameters: ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters> | DeepReadonly<GetContactPointParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetContactPointData,
          GetContactPointError,
          TData,
          ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetContactPointError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.contactPointsService.getContactPoint.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetContactPointData>(
      parameters: ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters> | DeepReadonly<GetContactPointParameters>,
      options: Omit<
        DefinedInitialDataOptions<GetContactPointData, GetContactPointError, TData, ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetContactPointError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.contactPointsService.getContactPoint.useSuspenseInfiniteQuery({
     *     path: {
     *         id: id
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetContactPointParameters, TData = GetContactPointData>(
      parameters: ServiceOperationInfiniteQueryKey<GetContactPointSchema, GetContactPointParameters> | DeepReadonly<GetContactPointParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetContactPointData,
          GetContactPointError,
          OperationInfiniteData<TData, GetContactPointParameters>,
          GetContactPointData,
          ServiceOperationInfiniteQueryKey<GetContactPointSchema, GetContactPointParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetContactPointData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetContactPointParameters>, GetContactPointError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getContactPointData = qraft.contactPointsService.getContactPoint.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getContactPointResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getContactPointCombinedData = qraft.contactPointsService.getContactPoint.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getContactPointCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetContactPointSchema, GetContactPointParameters, GetContactPointData, GetContactPointError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetContactPointData, GetContactPointError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetContactPointData, GetContactPointError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.contactPointsService.getContactPoint.useSuspenseQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetContactPointData>(
      parameters: ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters> | DeepReadonly<GetContactPointParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<GetContactPointData, GetContactPointError, TData, ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters>>,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetContactPointError | Error>;
    schema: GetContactPointSchema;
    types: {
      parameters: GetContactPointParameters;
      data: GetContactPointData;
      error: GetContactPointError;
    };
  };
  patchContactPoint: {
    /**/
    getMutationKey(
      parameters: DeepReadonly<PatchContactPointParameters> | void
    ): ServiceOperationMutationKey<PatchContactPointSchema, PatchContactPointParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.contactPointsService.patchContactPoint.useMutation({
     *     path: {
     *         id: id
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.contactPointsService.patchContactPoint.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends PatchContactPointBody, TContext = unknown>(
      parameters: DeepReadonly<PatchContactPointParameters>,
      options?: ServiceOperationUseMutationOptions<
        PatchContactPointSchema,
        PatchContactPointData,
        PatchContactPointParameters,
        TVariables,
        PatchContactPointError | Error,
        TContext
      >
    ): UseMutationResult<PatchContactPointData, PatchContactPointError | Error, TVariables, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.contactPointsService.patchContactPoint.useMutation({
     *     path: {
     *         id: id
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.contactPointsService.patchContactPoint.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PatchContactPointBody, PatchContactPointParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PatchContactPointSchema,
        PatchContactPointData,
        PatchContactPointParameters,
        TVariables,
        PatchContactPointError | Error,
        TContext
      >
    ): UseMutationResult<PatchContactPointData, PatchContactPointError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const patchContactPointTotal = qraft.contactPointsService.patchContactPoint.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const patchContactPointTotal = qraft.contactPointsService.patchContactPoint.useIsMutating({
     *     parameters: {
     *         path: {
     *             id: id
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<PatchContactPointBody, PatchContactPointData, PatchContactPointParameters, PatchContactPointError | Error, TContext>
        | MutationFiltersByMutationKey<
            PatchContactPointSchema,
            PatchContactPointBody,
            PatchContactPointData,
            PatchContactPointParameters,
            PatchContactPointError | Error,
            TContext
          >
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<PatchContactPointBody, PatchContactPointData, PatchContactPointParameters, PatchContactPointError | Error, TContext>
        | MutationFiltersByMutationKey<
            PatchContactPointSchema,
            PatchContactPointBody,
            PatchContactPointData,
            PatchContactPointParameters,
            PatchContactPointError | Error,
            TContext
          >
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<PatchContactPointBody, PatchContactPointParameters>,
      client?: (
        schema: PatchContactPointSchema,
        options: ServiceOperationMutationFnOptions<PatchContactPointBody, PatchContactPointParameters>
      ) => Promise<RequestFnResponse<PatchContactPointData, PatchContactPointError>>
    ): Promise<RequestFnResponse<PatchContactPointData, PatchContactPointError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const patchContactPointPendingMutationVariables = qraft.contactPointsService.patchContactPoint.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const patchContactPointMutationData = qraft.contactPointsService.patchContactPoint.useMutationState({
     *     filters: {
     *         parameters: {
     *             path: {
     *                 id: id
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        PatchContactPointData,
        PatchContactPointError | Error,
        MutationVariables<PatchContactPointBody, PatchContactPointParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<PatchContactPointBody, PatchContactPointData, PatchContactPointParameters, PatchContactPointError | Error, TContext>
        | MutationFiltersByMutationKey<
            PatchContactPointSchema,
            PatchContactPointBody,
            PatchContactPointData,
            PatchContactPointParameters,
            PatchContactPointError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          PatchContactPointData,
          PatchContactPointError | Error,
          MutationVariables<PatchContactPointBody, PatchContactPointParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: PatchContactPointSchema;
    types: {
      parameters: PatchContactPointParameters;
      data: PatchContactPointData;
      error: PatchContactPointError;
      body: PatchContactPointBody;
    };
  };
  deleteContactPoint: {
    /**/
    getMutationKey(
      parameters: DeepReadonly<DeleteContactPointParameters> | void
    ): ServiceOperationMutationKey<DeleteContactPointSchema, DeleteContactPointParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.contactPointsService.deleteContactPoint.useMutation({
     *     path: {
     *         id: id
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.contactPointsService.deleteContactPoint.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends DeleteContactPointBody, TContext = unknown>(
      parameters: DeepReadonly<DeleteContactPointParameters>,
      options?: ServiceOperationUseMutationOptions<
        DeleteContactPointSchema,
        DeleteContactPointData,
        DeleteContactPointParameters,
        TVariables,
        DeleteContactPointError | Error,
        TContext
      >
    ): UseMutationResult<DeleteContactPointData, DeleteContactPointError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.contactPointsService.deleteContactPoint.useMutation({
     *     path: {
     *         id: id
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.contactPointsService.deleteContactPoint.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<DeleteContactPointBody, DeleteContactPointParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        DeleteContactPointSchema,
        DeleteContactPointData,
        DeleteContactPointParameters,
        TVariables,
        DeleteContactPointError | Error,
        TContext
      >
    ): UseMutationResult<DeleteContactPointData, DeleteContactPointError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const deleteContactPointTotal = qraft.contactPointsService.deleteContactPoint.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const deleteContactPointTotal = qraft.contactPointsService.deleteContactPoint.useIsMutating({
     *     parameters: {
     *         path: {
     *             id: id
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<DeleteContactPointBody, DeleteContactPointData, DeleteContactPointParameters, DeleteContactPointError | Error, TContext>
        | MutationFiltersByMutationKey<
            DeleteContactPointSchema,
            DeleteContactPointBody,
            DeleteContactPointData,
            DeleteContactPointParameters,
            DeleteContactPointError | Error,
            TContext
          >
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<DeleteContactPointBody, DeleteContactPointData, DeleteContactPointParameters, DeleteContactPointError | Error, TContext>
        | MutationFiltersByMutationKey<
            DeleteContactPointSchema,
            DeleteContactPointBody,
            DeleteContactPointData,
            DeleteContactPointParameters,
            DeleteContactPointError | Error,
            TContext
          >
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<DeleteContactPointBody, DeleteContactPointParameters>,
      client?: (
        schema: DeleteContactPointSchema,
        options: ServiceOperationMutationFnOptions<DeleteContactPointBody, DeleteContactPointParameters>
      ) => Promise<RequestFnResponse<DeleteContactPointData, DeleteContactPointError>>
    ): Promise<RequestFnResponse<DeleteContactPointData, DeleteContactPointError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const deleteContactPointPendingMutationVariables = qraft.contactPointsService.deleteContactPoint.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const deleteContactPointMutationData = qraft.contactPointsService.deleteContactPoint.useMutationState({
     *     filters: {
     *         parameters: {
     *             path: {
     *                 id: id
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        DeleteContactPointData,
        DeleteContactPointError | Error,
        MutationVariables<DeleteContactPointBody, DeleteContactPointParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<DeleteContactPointBody, DeleteContactPointData, DeleteContactPointParameters, DeleteContactPointError | Error, TContext>
        | MutationFiltersByMutationKey<
            DeleteContactPointSchema,
            DeleteContactPointBody,
            DeleteContactPointData,
            DeleteContactPointParameters,
            DeleteContactPointError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          DeleteContactPointData,
          DeleteContactPointError | Error,
          MutationVariables<DeleteContactPointBody, DeleteContactPointParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: DeleteContactPointSchema;
    types: {
      parameters: DeleteContactPointParameters;
      data: DeleteContactPointData;
      error: DeleteContactPointError;
      body: DeleteContactPointBody;
    };
  };
}
export const contactPointsService: {
  createContactPoint: {
    schema: CreateContactPointSchema;
  };
  getContactPoint: {
    schema: GetContactPointSchema;
  };
  patchContactPoint: {
    schema: PatchContactPointSchema;
  };
  deleteContactPoint: {
    schema: DeleteContactPointSchema;
  };
} = {
  createContactPoint: {
    schema: {
      method: "post",
      url: "/contact-points",
      mediaType: ["application/json"]
    }
  },
  getContactPoint: {
    schema: {
      method: "get",
      url: "/contact-points/{id}"
    }
  },
  patchContactPoint: {
    schema: {
      method: "patch",
      url: "/contact-points/{id}",
      mediaType: ["application/json"]
    }
  },
  deleteContactPoint: {
    schema: {
      method: "delete",
      url: "/contact-points/{id}"
    }
  }
};
type CreateContactPointSchema = {
  method: "post";
  url: "/contact-points";
  mediaType: ["application/json"];
};
type CreateContactPointParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type CreateContactPointData = paths["/contact-points"]["post"]["responses"]["201"]["content"]["application/json"];
type CreateContactPointError = unknown;
type CreateContactPointBody = paths["/contact-points"]["post"]["requestBody"]["content"]["application/json"];
type GetContactPointSchema = {
  method: "get";
  url: "/contact-points/{id}";
};
type GetContactPointParameters = paths["/contact-points/{id}"]["get"]["parameters"];
type GetContactPointData = paths["/contact-points/{id}"]["get"]["responses"]["201"]["content"]["application/json"];
type GetContactPointError = unknown;
type PatchContactPointSchema = {
  method: "patch";
  url: "/contact-points/{id}";
  mediaType: ["application/json"];
};
type PatchContactPointParameters = paths["/contact-points/{id}"]["patch"]["parameters"];
type PatchContactPointData = paths["/contact-points/{id}"]["patch"]["responses"]["201"]["content"]["application/json"];
type PatchContactPointError = unknown;
type PatchContactPointBody = paths["/contact-points/{id}"]["patch"]["requestBody"]["content"]["application/json"];
type DeleteContactPointSchema = {
  method: "delete";
  url: "/contact-points/{id}";
};
type DeleteContactPointParameters = paths["/contact-points/{id}"]["delete"]["parameters"];
type DeleteContactPointData = paths["/contact-points/{id}"]["delete"]["responses"]["201"]["content"]["application/json"];
type DeleteContactPointError = unknown;
type DeleteContactPointBody = undefined;
