/**
 * This file was auto-generated by @openapi-qraft/cli.
 * Do not make direct changes to the file.
 */

import type {
  DeepReadonly,
  InvalidateQueryFilters,
  MutationFiltersByMutationKey,
  MutationFiltersByParameters,
  MutationVariables,
  OperationInfiniteData,
  PartialParameters,
  QraftServiceOperationsToken,
  QueryFiltersByParameters,
  QueryFiltersByQueryKey,
  QueryFnOptionsByParameters,
  QueryFnOptionsByQueryKey,
  RequestFnResponse,
  ServiceOperationEnsureInfiniteQueryDataOptions,
  ServiceOperationEnsureQueryDataOptions,
  ServiceOperationFetchInfiniteQueryOptions,
  ServiceOperationFetchQueryOptions,
  ServiceOperationInfiniteQueryKey,
  ServiceOperationMutationFnOptions,
  ServiceOperationMutationKey,
  ServiceOperationQueryKey,
  ServiceOperationUseMutationOptions,
  UseQueryOptionsForUseQueries,
  UseQueryOptionsForUseSuspenseQuery,
  WithOptional
} from "@openapi-qraft/tanstack-query-react-types";
import type {
  CancelOptions,
  InfiniteQueryPageParamsOptions,
  InvalidateOptions,
  Mutation,
  MutationState,
  NoInfer,
  QueryState,
  RefetchOptions,
  ResetOptions,
  SetDataOptions,
  Updater
} from "@tanstack/query-core";
import type {
  DefinedInitialDataInfiniteOptions,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  UndefinedInitialDataInfiniteOptions,
  UndefinedInitialDataOptions,
  UseInfiniteQueryResult,
  UseMutationResult,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from "@tanstack/react-query";

import type { paths } from "../schema";
export interface V1Service {
  createAlert: {
    /**/
    getMutationKey(parameters: DeepReadonly<CreateAlertParameters> | void): ServiceOperationMutationKey<CreateAlertSchema, CreateAlertParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createAlert.useMutation({
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createAlert.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends CreateAlertBody, TContext = unknown>(
      parameters: DeepReadonly<CreateAlertParameters>,
      options?: ServiceOperationUseMutationOptions<CreateAlertSchema, CreateAlertData, CreateAlertParameters, TVariables, CreateAlertError | Error, TContext>
    ): UseMutationResult<CreateAlertData, CreateAlertError | Error, TVariables, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createAlert.useMutation({
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createAlert.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<CreateAlertBody, CreateAlertParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<CreateAlertSchema, CreateAlertData, CreateAlertParameters, TVariables, CreateAlertError | Error, TContext>
    ): UseMutationResult<CreateAlertData, CreateAlertError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const createAlertTotal = qraft.v1Service.createAlert.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const createAlertTotal = qraft.v1Service.createAlert.useIsMutating({
     *     parameters: {
     *         header: {
     *             Authorization: authorization
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<CreateAlertBody, CreateAlertData, CreateAlertParameters, CreateAlertError | Error, TContext>
        | MutationFiltersByMutationKey<CreateAlertSchema, CreateAlertBody, CreateAlertData, CreateAlertParameters, CreateAlertError | Error, TContext>
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<CreateAlertBody, CreateAlertData, CreateAlertParameters, CreateAlertError | Error, TContext>
        | MutationFiltersByMutationKey<CreateAlertSchema, CreateAlertBody, CreateAlertData, CreateAlertParameters, CreateAlertError | Error, TContext>
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<CreateAlertBody, CreateAlertParameters>,
      client?: (
        schema: CreateAlertSchema,
        options: ServiceOperationMutationFnOptions<CreateAlertBody, CreateAlertParameters>
      ) => Promise<RequestFnResponse<CreateAlertData, CreateAlertError>>
    ): Promise<RequestFnResponse<CreateAlertData, CreateAlertError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const createAlertPendingMutationVariables = qraft.v1Service.createAlert.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const createAlertMutationData = qraft.v1Service.createAlert.useMutationState({
     *     filters: {
     *         parameters: {
     *             header: {
     *                 Authorization: authorization
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<CreateAlertData, CreateAlertError | Error, MutationVariables<CreateAlertBody, CreateAlertParameters>, TContext>
    >(options?: {
      filters?:
        | MutationFiltersByParameters<CreateAlertBody, CreateAlertData, CreateAlertParameters, CreateAlertError | Error, TContext>
        | MutationFiltersByMutationKey<CreateAlertSchema, CreateAlertBody, CreateAlertData, CreateAlertParameters, CreateAlertError | Error, TContext>;
      select?: (mutation: Mutation<CreateAlertData, CreateAlertError | Error, MutationVariables<CreateAlertBody, CreateAlertParameters>, TContext>) => TResult;
    }): Array<TResult>;
    schema: CreateAlertSchema;
    types: {
      parameters: CreateAlertParameters;
      data: CreateAlertData;
      error: CreateAlertError;
      body: CreateAlertBody;
    };
  };
  getAlerts: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>
        | QueryFiltersByQueryKey<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(parameters: DeepReadonly<GetAlertsParameters> | void): ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlerts.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlerts.useQuery({
     *     query: {
     *         limit: limit
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAlertsData>(
      parameters: ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters> | (DeepReadonly<GetAlertsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetAlertsData, GetAlertsError, TData, ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetAlertsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlerts.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlerts.useQuery({
     *     query: {
     *         limit: limit
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAlertsData>(
      parameters: ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters> | (DeepReadonly<GetAlertsParameters> | void),
      options: Omit<DefinedInitialDataOptions<GetAlertsData, GetAlertsError, TData, ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters>>, "queryKey">
    ): DefinedUseQueryResult<TData, GetAlertsError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetAlertsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<GetAlertsSchema, GetAlertsData, GetAlertsParameters, DeepReadonly<TPageParam>, GetAlertsError> | void
    ): Promise<OperationInfiniteData<GetAlertsData, GetAlertsParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetAlertsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<GetAlertsSchema, GetAlertsData, GetAlertsParameters, DeepReadonly<TPageParam>, GetAlertsError> | void
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetAlertsParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetAlertsSchema,
        GetAlertsData,
        GetAlertsParameters,
        DeepReadonly<TPageParam>,
        GetAlertsError
      > | void
    ): Promise<OperationInfiniteData<GetAlertsData, GetAlertsParameters>>;
    /**/
    fetchQuery(options: ServiceOperationFetchQueryOptions<GetAlertsSchema, GetAlertsData, GetAlertsParameters, GetAlertsError> | void): Promise<GetAlertsData>;
    /**/
    prefetchQuery(options: ServiceOperationFetchQueryOptions<GetAlertsSchema, GetAlertsData, GetAlertsParameters, GetAlertsError> | void): Promise<void>;
    /**/
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetAlertsSchema, GetAlertsData, GetAlertsParameters, GetAlertsError> | void
    ): Promise<GetAlertsData>;
    /**/
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetAlertsSchema, GetAlertsParameters> | (DeepReadonly<GetAlertsParameters> | void)
    ): OperationInfiniteData<GetAlertsData, GetAlertsParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>
        | QueryFiltersByQueryKey<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetAlertsSchema, GetAlertsParameters>,
            data: NoInfer<OperationInfiniteData<GetAlertsData, GetAlertsParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters>, data: GetAlertsData | undefined]>;
    /**/
    getQueryData(
      parameters: ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters> | (DeepReadonly<GetAlertsParameters> | void)
    ): GetAlertsData | undefined;
    /**/
    getQueryState(
      parameters: ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters> | (DeepReadonly<GetAlertsParameters> | void)
    ): QueryState<GetAlertsData, GetAlertsError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters: DeepReadonly<GetAlertsParameters> | ServiceOperationInfiniteQueryKey<GetAlertsSchema, GetAlertsParameters> | void
    ): QueryState<OperationInfiniteData<GetAlertsData, GetAlertsParameters>, GetAlertsError> | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>
        | QueryFiltersByQueryKey<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetAlertsSchema, GetAlertsParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetAlertsParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetAlertsSchema,
        options: {
          parameters: GetAlertsParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetAlertsData, GetAlertsError>>
    ): Promise<RequestFnResponse<GetAlertsData, GetAlertsError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>
        | QueryFiltersByQueryKey<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>
        | QueryFiltersByQueryKey<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>
        | QueryFiltersByQueryKey<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters: (DeepReadonly<GetAlertsParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetAlertsSchema, GetAlertsParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetAlertsData, GetAlertsParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetAlertsData, GetAlertsParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetAlertsData, GetAlertsParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>
        | QueryFiltersByQueryKey<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>,
      updater: Updater<NoInfer<GetAlertsData> | undefined, NoInfer<GetAlertsData> | undefined>,
      options?: SetDataOptions
    ): Array<GetAlertsData | undefined>;
    /**/
    setQueryData(
      parameters: (DeepReadonly<GetAlertsParameters> | undefined) | ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters>,
      updater: Updater<NoInfer<GetAlertsData> | undefined, NoInfer<DeepReadonly<GetAlertsData>> | undefined>,
      options?: SetDataOptions
    ): GetAlertsData | undefined;
    /**/
    getInfiniteQueryKey(parameters: DeepReadonly<GetAlertsParameters> | void): ServiceOperationInfiniteQueryKey<GetAlertsSchema, GetAlertsParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAlerts.useInfiniteQuery({
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             limit: initialLimit
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<TPageParam extends GetAlertsParameters, TQueryFnData = GetAlertsData, TData = OperationInfiniteData<TQueryFnData, GetAlertsParameters>>(
      parameters: ServiceOperationInfiniteQueryKey<GetAlertsSchema, GetAlertsParameters> | (DeepReadonly<GetAlertsParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetAlertsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetAlertsSchema, GetAlertsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetAlertsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAlerts.useInfiniteQuery({
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             limit: initialLimit
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<TPageParam extends GetAlertsParameters, TQueryFnData = GetAlertsData, TData = OperationInfiniteData<TQueryFnData, GetAlertsParameters>>(
      parameters: ServiceOperationInfiniteQueryKey<GetAlertsSchema, GetAlertsParameters> | (DeepReadonly<GetAlertsParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetAlertsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetAlertsSchema, GetAlertsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetAlertsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetAlertsError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getAlertsTotal = qraft.v1Service.getAlerts.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getAlertsByParametersTotal = qraft.v1Service.getAlerts.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         query: {
     *             limit: limit
     *         },
     *         header: {
     *             Authorization: authorization
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>
        | QueryFiltersByQueryKey<GetAlertsSchema, GetAlertsData, TInfinite, GetAlertsParameters, GetAlertsError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getAlertsResults = qraft.v1Service.getAlerts.useQueries({
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getAlertsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getAlertsCombinedResults = qraft.v1Service.getAlerts.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getAlertsCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetAlertsSchema, GetAlertsParameters, GetAlertsData, GetAlertsError>>,
      TCombinedResult = Array<UseQueryResult<GetAlertsData, GetAlertsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetAlertsData, GetAlertsError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(parameters: DeepReadonly<GetAlertsParameters> | void): ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlerts.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlerts.useQuery({
     *     query: {
     *         limit: limit
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAlertsData>(
      parameters: ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters> | (DeepReadonly<GetAlertsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<GetAlertsData, GetAlertsError, TData, ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters>>,
        "queryKey"
      >
    ): UseQueryResult<TData, GetAlertsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlerts.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlerts.useQuery({
     *     query: {
     *         limit: limit
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAlertsData>(
      parameters: ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters> | (DeepReadonly<GetAlertsParameters> | void),
      options: Omit<DefinedInitialDataOptions<GetAlertsData, GetAlertsError, TData, ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters>>, "queryKey">
    ): DefinedUseQueryResult<TData, GetAlertsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAlerts.useSuspenseInfiniteQuery({
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             limit: initialLimit
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetAlertsParameters, TData = GetAlertsData>(
      parameters: ServiceOperationInfiniteQueryKey<GetAlertsSchema, GetAlertsParameters> | (DeepReadonly<GetAlertsParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetAlertsData,
          GetAlertsError,
          OperationInfiniteData<TData, GetAlertsParameters>,
          GetAlertsData,
          ServiceOperationInfiniteQueryKey<GetAlertsSchema, GetAlertsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetAlertsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetAlertsParameters>, GetAlertsError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getAlertsData = qraft.v1Service.getAlerts.useSuspenseQueries({
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getAlertsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getAlertsCombinedData = qraft.v1Service.getAlerts.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getAlertsCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetAlertsSchema, GetAlertsParameters, GetAlertsData, GetAlertsError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetAlertsData, GetAlertsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetAlertsData, GetAlertsError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getAlerts.useSuspenseQuery()
     * ```
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getAlerts.useSuspenseQuery({
     *     query: {
     *         limit: limit
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetAlertsData>(
      parameters: ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters> | (DeepReadonly<GetAlertsParameters> | void),
      options?: Omit<UseSuspenseQueryOptions<GetAlertsData, GetAlertsError, TData, ServiceOperationQueryKey<GetAlertsSchema, GetAlertsParameters>>, "queryKey">
    ): UseSuspenseQueryResult<TData, GetAlertsError | Error>;
    schema: GetAlertsSchema;
    types: {
      parameters: GetAlertsParameters;
      data: GetAlertsData;
      error: GetAlertsError;
    };
  };
  getAlert: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(parameters: DeepReadonly<GetAlertParameters>): ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlert.useQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAlertData>(
      parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options?: Omit<UndefinedInitialDataOptions<GetAlertData, GetAlertError, TData, ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>>, "queryKey">
    ): UseQueryResult<TData, GetAlertError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlert.useQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAlertData>(
      parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options: Omit<DefinedInitialDataOptions<GetAlertData, GetAlertError, TData, ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>>, "queryKey">
    ): DefinedUseQueryResult<TData, GetAlertError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetAlertParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<GetAlertSchema, GetAlertData, GetAlertParameters, DeepReadonly<TPageParam>, GetAlertError>
    ): Promise<OperationInfiniteData<GetAlertData, GetAlertParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetAlertParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<GetAlertSchema, GetAlertData, GetAlertParameters, DeepReadonly<TPageParam>, GetAlertError>
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetAlertParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<GetAlertSchema, GetAlertData, GetAlertParameters, DeepReadonly<TPageParam>, GetAlertError>
    ): Promise<OperationInfiniteData<GetAlertData, GetAlertParameters>>;
    /**/
    fetchQuery(options: ServiceOperationFetchQueryOptions<GetAlertSchema, GetAlertData, GetAlertParameters, GetAlertError>): Promise<GetAlertData>;
    /**/
    prefetchQuery(options: ServiceOperationFetchQueryOptions<GetAlertSchema, GetAlertData, GetAlertParameters, GetAlertError>): Promise<void>;
    /**/
    ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetAlertSchema, GetAlertData, GetAlertParameters, GetAlertError>): Promise<GetAlertData>;
    /**/
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>
    ): OperationInfiniteData<GetAlertData, GetAlertParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>,
            data: NoInfer<OperationInfiniteData<GetAlertData, GetAlertParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>, data: GetAlertData | undefined]>;
    /**/
    getQueryData(parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>): GetAlertData | undefined;
    /**/
    getQueryState(
      parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>
    ): QueryState<GetAlertData, GetAlertError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters: DeepReadonly<GetAlertParameters> | ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>
    ): QueryState<OperationInfiniteData<GetAlertData, GetAlertParameters>, GetAlertError> | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options: QueryFnOptionsByQueryKey<GetAlertSchema, GetAlertParameters, TMeta, TSignal> | QueryFnOptionsByParameters<GetAlertParameters, TMeta, TSignal>,
      client?: (
        schema: GetAlertSchema,
        options: {
          parameters: GetAlertParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetAlertData, GetAlertError>>
    ): Promise<RequestFnResponse<GetAlertData, GetAlertError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters: DeepReadonly<GetAlertParameters> | ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetAlertData, GetAlertParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetAlertData, GetAlertParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetAlertData, GetAlertParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>,
      updater: Updater<NoInfer<GetAlertData> | undefined, NoInfer<GetAlertData> | undefined>,
      options?: SetDataOptions
    ): Array<GetAlertData | undefined>;
    /**/
    setQueryData(
      parameters: DeepReadonly<GetAlertParameters> | ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>,
      updater: Updater<NoInfer<GetAlertData> | undefined, NoInfer<DeepReadonly<GetAlertData>> | undefined>,
      options?: SetDataOptions
    ): GetAlertData | undefined;
    /**/
    getInfiniteQueryKey(parameters: DeepReadonly<GetAlertParameters>): ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAlert.useInfiniteQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<TPageParam extends GetAlertParameters, TQueryFnData = GetAlertData, TData = OperationInfiniteData<TQueryFnData, GetAlertParameters>>(
      parameters: ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetAlertError,
          TData,
          ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetAlertError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAlert.useInfiniteQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<TPageParam extends GetAlertParameters, TQueryFnData = GetAlertData, TData = OperationInfiniteData<TQueryFnData, GetAlertParameters>>(
      parameters: ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetAlertError,
          TData,
          ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetAlertData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetAlertError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getAlertTotal = qraft.v1Service.getAlert.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getAlertByParametersTotal = qraft.v1Service.getAlert.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             id: id
     *         },
     *         header: {
     *             Authorization: authorization
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getAlertResults = qraft.v1Service.getAlert.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getAlertResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getAlertCombinedResults = qraft.v1Service.getAlert.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getAlertCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetAlertSchema, GetAlertParameters, GetAlertData, GetAlertError>>,
      TCombinedResult = Array<UseQueryResult<GetAlertData, GetAlertError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetAlertData, GetAlertError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(parameters: DeepReadonly<GetAlertParameters>): ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlert.useQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAlertData>(
      parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options?: Omit<UndefinedInitialDataOptions<GetAlertData, GetAlertError, TData, ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>>, "queryKey">
    ): UseQueryResult<TData, GetAlertError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlert.useQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAlertData>(
      parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options: Omit<DefinedInitialDataOptions<GetAlertData, GetAlertError, TData, ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>>, "queryKey">
    ): DefinedUseQueryResult<TData, GetAlertError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAlert.useSuspenseInfiniteQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetAlertParameters, TData = GetAlertData>(
      parameters: ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetAlertData,
          GetAlertError,
          OperationInfiniteData<TData, GetAlertParameters>,
          GetAlertData,
          ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetAlertData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetAlertParameters>, GetAlertError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getAlertData = qraft.v1Service.getAlert.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getAlertResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getAlertCombinedData = qraft.v1Service.getAlert.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getAlertCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetAlertSchema, GetAlertParameters, GetAlertData, GetAlertError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetAlertData, GetAlertError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetAlertData, GetAlertError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getAlert.useSuspenseQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetAlertData>(
      parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options?: Omit<UseSuspenseQueryOptions<GetAlertData, GetAlertError, TData, ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>>, "queryKey">
    ): UseSuspenseQueryResult<TData, GetAlertError | Error>;
    schema: GetAlertSchema;
    types: {
      parameters: GetAlertParameters;
      data: GetAlertData;
      error: GetAlertError;
    };
  };
  patchAlert: {
    /**/
    getMutationKey(parameters: DeepReadonly<PatchAlertParameters> | void): ServiceOperationMutationKey<PatchAlertSchema, PatchAlertParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchAlert.useMutation({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchAlert.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends PatchAlertBody, TContext = unknown>(
      parameters: DeepReadonly<PatchAlertParameters>,
      options?: ServiceOperationUseMutationOptions<PatchAlertSchema, PatchAlertData, PatchAlertParameters, TVariables, PatchAlertError | Error, TContext>
    ): UseMutationResult<PatchAlertData, PatchAlertError | Error, TVariables, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchAlert.useMutation({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchAlert.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PatchAlertBody, PatchAlertParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<PatchAlertSchema, PatchAlertData, PatchAlertParameters, TVariables, PatchAlertError | Error, TContext>
    ): UseMutationResult<PatchAlertData, PatchAlertError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const patchAlertTotal = qraft.v1Service.patchAlert.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const patchAlertTotal = qraft.v1Service.patchAlert.useIsMutating({
     *     parameters: {
     *         path: {
     *             id: id
     *         },
     *         header: {
     *             Authorization: authorization
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<PatchAlertBody, PatchAlertData, PatchAlertParameters, PatchAlertError | Error, TContext>
        | MutationFiltersByMutationKey<PatchAlertSchema, PatchAlertBody, PatchAlertData, PatchAlertParameters, PatchAlertError | Error, TContext>
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<PatchAlertBody, PatchAlertData, PatchAlertParameters, PatchAlertError | Error, TContext>
        | MutationFiltersByMutationKey<PatchAlertSchema, PatchAlertBody, PatchAlertData, PatchAlertParameters, PatchAlertError | Error, TContext>
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<PatchAlertBody, PatchAlertParameters>,
      client?: (
        schema: PatchAlertSchema,
        options: ServiceOperationMutationFnOptions<PatchAlertBody, PatchAlertParameters>
      ) => Promise<RequestFnResponse<PatchAlertData, PatchAlertError>>
    ): Promise<RequestFnResponse<PatchAlertData, PatchAlertError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const patchAlertPendingMutationVariables = qraft.v1Service.patchAlert.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const patchAlertMutationData = qraft.v1Service.patchAlert.useMutationState({
     *     filters: {
     *         parameters: {
     *             path: {
     *                 id: id
     *             },
     *             header: {
     *                 Authorization: authorization
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<PatchAlertData, PatchAlertError | Error, MutationVariables<PatchAlertBody, PatchAlertParameters>, TContext>
    >(options?: {
      filters?:
        | MutationFiltersByParameters<PatchAlertBody, PatchAlertData, PatchAlertParameters, PatchAlertError | Error, TContext>
        | MutationFiltersByMutationKey<PatchAlertSchema, PatchAlertBody, PatchAlertData, PatchAlertParameters, PatchAlertError | Error, TContext>;
      select?: (mutation: Mutation<PatchAlertData, PatchAlertError | Error, MutationVariables<PatchAlertBody, PatchAlertParameters>, TContext>) => TResult;
    }): Array<TResult>;
    schema: PatchAlertSchema;
    types: {
      parameters: PatchAlertParameters;
      data: PatchAlertData;
      error: PatchAlertError;
      body: PatchAlertBody;
    };
  };
  deleteAlert: {
    /**/
    getMutationKey(parameters: DeepReadonly<DeleteAlertParameters> | void): ServiceOperationMutationKey<DeleteAlertSchema, DeleteAlertParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteAlert.useMutation({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteAlert.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends DeleteAlertBody, TContext = unknown>(
      parameters: DeepReadonly<DeleteAlertParameters>,
      options?: ServiceOperationUseMutationOptions<DeleteAlertSchema, DeleteAlertData, DeleteAlertParameters, TVariables, DeleteAlertError | Error, TContext>
    ): UseMutationResult<DeleteAlertData, DeleteAlertError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteAlert.useMutation({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteAlert.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<DeleteAlertBody, DeleteAlertParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<DeleteAlertSchema, DeleteAlertData, DeleteAlertParameters, TVariables, DeleteAlertError | Error, TContext>
    ): UseMutationResult<DeleteAlertData, DeleteAlertError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const deleteAlertTotal = qraft.v1Service.deleteAlert.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const deleteAlertTotal = qraft.v1Service.deleteAlert.useIsMutating({
     *     parameters: {
     *         path: {
     *             id: id
     *         },
     *         header: {
     *             Authorization: authorization
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<DeleteAlertBody, DeleteAlertData, DeleteAlertParameters, DeleteAlertError | Error, TContext>
        | MutationFiltersByMutationKey<DeleteAlertSchema, DeleteAlertBody, DeleteAlertData, DeleteAlertParameters, DeleteAlertError | Error, TContext>
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<DeleteAlertBody, DeleteAlertData, DeleteAlertParameters, DeleteAlertError | Error, TContext>
        | MutationFiltersByMutationKey<DeleteAlertSchema, DeleteAlertBody, DeleteAlertData, DeleteAlertParameters, DeleteAlertError | Error, TContext>
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<DeleteAlertBody, DeleteAlertParameters>,
      client?: (
        schema: DeleteAlertSchema,
        options: ServiceOperationMutationFnOptions<DeleteAlertBody, DeleteAlertParameters>
      ) => Promise<RequestFnResponse<DeleteAlertData, DeleteAlertError>>
    ): Promise<RequestFnResponse<DeleteAlertData, DeleteAlertError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const deleteAlertPendingMutationVariables = qraft.v1Service.deleteAlert.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const deleteAlertMutationData = qraft.v1Service.deleteAlert.useMutationState({
     *     filters: {
     *         parameters: {
     *             path: {
     *                 id: id
     *             },
     *             header: {
     *                 Authorization: authorization
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<DeleteAlertData, DeleteAlertError | Error, MutationVariables<DeleteAlertBody, DeleteAlertParameters>, TContext>
    >(options?: {
      filters?:
        | MutationFiltersByParameters<DeleteAlertBody, DeleteAlertData, DeleteAlertParameters, DeleteAlertError | Error, TContext>
        | MutationFiltersByMutationKey<DeleteAlertSchema, DeleteAlertBody, DeleteAlertData, DeleteAlertParameters, DeleteAlertError | Error, TContext>;
      select?: (mutation: Mutation<DeleteAlertData, DeleteAlertError | Error, MutationVariables<DeleteAlertBody, DeleteAlertParameters>, TContext>) => TResult;
    }): Array<TResult>;
    schema: DeleteAlertSchema;
    types: {
      parameters: DeleteAlertParameters;
      data: DeleteAlertData;
      error: DeleteAlertError;
      body: DeleteAlertBody;
    };
  };
  createNotificationChannel: {
    /**/
    getMutationKey(
      parameters: DeepReadonly<CreateNotificationChannelParameters> | void
    ): ServiceOperationMutationKey<CreateNotificationChannelSchema, CreateNotificationChannelParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createNotificationChannel.useMutation({
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createNotificationChannel.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends CreateNotificationChannelBody, TContext = unknown>(
      parameters: DeepReadonly<CreateNotificationChannelParameters>,
      options?: ServiceOperationUseMutationOptions<
        CreateNotificationChannelSchema,
        CreateNotificationChannelData,
        CreateNotificationChannelParameters,
        TVariables,
        CreateNotificationChannelError | Error,
        TContext
      >
    ): UseMutationResult<CreateNotificationChannelData, CreateNotificationChannelError | Error, TVariables, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createNotificationChannel.useMutation({
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createNotificationChannel.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<CreateNotificationChannelBody, CreateNotificationChannelParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        CreateNotificationChannelSchema,
        CreateNotificationChannelData,
        CreateNotificationChannelParameters,
        TVariables,
        CreateNotificationChannelError | Error,
        TContext
      >
    ): UseMutationResult<CreateNotificationChannelData, CreateNotificationChannelError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const createNotificationChannelTotal = qraft.v1Service.createNotificationChannel.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const createNotificationChannelTotal = qraft.v1Service.createNotificationChannel.useIsMutating({
     *     parameters: {
     *         header: {
     *             Authorization: authorization
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<
            CreateNotificationChannelBody,
            CreateNotificationChannelData,
            CreateNotificationChannelParameters,
            CreateNotificationChannelError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            CreateNotificationChannelSchema,
            CreateNotificationChannelBody,
            CreateNotificationChannelData,
            CreateNotificationChannelParameters,
            CreateNotificationChannelError | Error,
            TContext
          >
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<
            CreateNotificationChannelBody,
            CreateNotificationChannelData,
            CreateNotificationChannelParameters,
            CreateNotificationChannelError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            CreateNotificationChannelSchema,
            CreateNotificationChannelBody,
            CreateNotificationChannelData,
            CreateNotificationChannelParameters,
            CreateNotificationChannelError | Error,
            TContext
          >
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<CreateNotificationChannelBody, CreateNotificationChannelParameters>,
      client?: (
        schema: CreateNotificationChannelSchema,
        options: ServiceOperationMutationFnOptions<CreateNotificationChannelBody, CreateNotificationChannelParameters>
      ) => Promise<RequestFnResponse<CreateNotificationChannelData, CreateNotificationChannelError>>
    ): Promise<RequestFnResponse<CreateNotificationChannelData, CreateNotificationChannelError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const createNotificationChannelPendingMutationVariables = qraft.v1Service.createNotificationChannel.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const createNotificationChannelMutationData = qraft.v1Service.createNotificationChannel.useMutationState({
     *     filters: {
     *         parameters: {
     *             header: {
     *                 Authorization: authorization
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        CreateNotificationChannelData,
        CreateNotificationChannelError | Error,
        MutationVariables<CreateNotificationChannelBody, CreateNotificationChannelParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<
            CreateNotificationChannelBody,
            CreateNotificationChannelData,
            CreateNotificationChannelParameters,
            CreateNotificationChannelError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            CreateNotificationChannelSchema,
            CreateNotificationChannelBody,
            CreateNotificationChannelData,
            CreateNotificationChannelParameters,
            CreateNotificationChannelError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          CreateNotificationChannelData,
          CreateNotificationChannelError | Error,
          MutationVariables<CreateNotificationChannelBody, CreateNotificationChannelParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: CreateNotificationChannelSchema;
    types: {
      parameters: CreateNotificationChannelParameters;
      data: CreateNotificationChannelData;
      error: CreateNotificationChannelError;
      body: CreateNotificationChannelBody;
    };
  };
  getNotificationChannels: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(
      parameters: DeepReadonly<GetNotificationChannelsParameters> | void
    ): ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNotificationChannels.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNotificationChannels.useQuery({
     *     query: {
     *         limit: limit
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetNotificationChannelsData>(
      parameters:
        | ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        | (DeepReadonly<GetNotificationChannelsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetNotificationChannelsData,
          GetNotificationChannelsError,
          TData,
          ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetNotificationChannelsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNotificationChannels.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNotificationChannels.useQuery({
     *     query: {
     *         limit: limit
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetNotificationChannelsData>(
      parameters:
        | ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        | (DeepReadonly<GetNotificationChannelsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetNotificationChannelsData,
          GetNotificationChannelsError,
          TData,
          ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetNotificationChannelsError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetNotificationChannelsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetNotificationChannelsSchema,
        GetNotificationChannelsData,
        GetNotificationChannelsParameters,
        DeepReadonly<TPageParam>,
        GetNotificationChannelsError
      > | void
    ): Promise<OperationInfiniteData<GetNotificationChannelsData, GetNotificationChannelsParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetNotificationChannelsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetNotificationChannelsSchema,
        GetNotificationChannelsData,
        GetNotificationChannelsParameters,
        DeepReadonly<TPageParam>,
        GetNotificationChannelsError
      > | void
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetNotificationChannelsParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetNotificationChannelsSchema,
        GetNotificationChannelsData,
        GetNotificationChannelsParameters,
        DeepReadonly<TPageParam>,
        GetNotificationChannelsError
      > | void
    ): Promise<OperationInfiniteData<GetNotificationChannelsData, GetNotificationChannelsParameters>>;
    /**/
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetNotificationChannelsSchema,
        GetNotificationChannelsData,
        GetNotificationChannelsParameters,
        GetNotificationChannelsError
      > | void
    ): Promise<GetNotificationChannelsData>;
    /**/
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetNotificationChannelsSchema,
        GetNotificationChannelsData,
        GetNotificationChannelsParameters,
        GetNotificationChannelsError
      > | void
    ): Promise<void>;
    /**/
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetNotificationChannelsSchema,
        GetNotificationChannelsData,
        GetNotificationChannelsParameters,
        GetNotificationChannelsError
      > | void
    ): Promise<GetNotificationChannelsData>;
    /**/
    getInfiniteQueryData(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        | (DeepReadonly<GetNotificationChannelsParameters> | void)
    ): OperationInfiniteData<GetNotificationChannelsData, GetNotificationChannelsParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>,
            data: NoInfer<OperationInfiniteData<GetNotificationChannelsData, GetNotificationChannelsParameters>> | undefined
          ]
        >
      : Array<
          [queryKey: ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>, data: GetNotificationChannelsData | undefined]
        >;
    /**/
    getQueryData(
      parameters:
        | ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        | (DeepReadonly<GetNotificationChannelsParameters> | void)
    ): GetNotificationChannelsData | undefined;
    /**/
    getQueryState(
      parameters:
        | ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        | (DeepReadonly<GetNotificationChannelsParameters> | void)
    ): QueryState<GetNotificationChannelsData, GetNotificationChannelsError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters:
        | DeepReadonly<GetNotificationChannelsParameters>
        | ServiceOperationInfiniteQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        | void
    ): QueryState<OperationInfiniteData<GetNotificationChannelsData, GetNotificationChannelsParameters>, GetNotificationChannelsError> | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<
        GetNotificationChannelsSchema,
        GetNotificationChannelsData,
        TInfinite,
        GetNotificationChannelsParameters,
        GetNotificationChannelsError
      >,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters, TMeta, TSignal>
        | (QueryFnOptionsByParameters<GetNotificationChannelsParameters, TMeta, TSignal> | void),
      client?: (
        schema: GetNotificationChannelsSchema,
        options: {
          parameters: GetNotificationChannelsParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetNotificationChannelsData, GetNotificationChannelsError>>
    ): Promise<RequestFnResponse<GetNotificationChannelsData, GetNotificationChannelsError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters:
        | (DeepReadonly<GetNotificationChannelsParameters> | undefined)
        | ServiceOperationInfiniteQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetNotificationChannelsData, GetNotificationChannelsParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetNotificationChannelsData, GetNotificationChannelsParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetNotificationChannelsData, GetNotificationChannelsParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >,
      updater: Updater<NoInfer<GetNotificationChannelsData> | undefined, NoInfer<GetNotificationChannelsData> | undefined>,
      options?: SetDataOptions
    ): Array<GetNotificationChannelsData | undefined>;
    /**/
    setQueryData(
      parameters:
        | (DeepReadonly<GetNotificationChannelsParameters> | undefined)
        | ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>,
      updater: Updater<NoInfer<GetNotificationChannelsData> | undefined, NoInfer<DeepReadonly<GetNotificationChannelsData>> | undefined>,
      options?: SetDataOptions
    ): GetNotificationChannelsData | undefined;
    /**/
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetNotificationChannelsParameters> | void
    ): ServiceOperationInfiniteQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getNotificationChannels.useInfiniteQuery({
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             limit: initialLimit
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetNotificationChannelsParameters,
      TQueryFnData = GetNotificationChannelsData,
      TData = OperationInfiniteData<TQueryFnData, GetNotificationChannelsParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        | (DeepReadonly<GetNotificationChannelsParameters> | void),
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetNotificationChannelsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetNotificationChannelsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getNotificationChannels.useInfiniteQuery({
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             limit: initialLimit
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetNotificationChannelsParameters,
      TQueryFnData = GetNotificationChannelsData,
      TData = OperationInfiniteData<TQueryFnData, GetNotificationChannelsParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        | (DeepReadonly<GetNotificationChannelsParameters> | void),
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetNotificationChannelsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetNotificationChannelsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetNotificationChannelsError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getNotificationChannelsTotal = qraft.v1Service.getNotificationChannels.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getNotificationChannelsByParametersTotal = qraft.v1Service.getNotificationChannels.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         query: {
     *             limit: limit
     *         },
     *         header: {
     *             Authorization: authorization
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelsSchema,
            GetNotificationChannelsData,
            TInfinite,
            GetNotificationChannelsParameters,
            GetNotificationChannelsError
          >
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getNotificationChannelsResults = qraft.v1Service.getNotificationChannels.useQueries({
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getNotificationChannelsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getNotificationChannelsCombinedResults = qraft.v1Service.getNotificationChannels.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getNotificationChannelsCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<
          GetNotificationChannelsSchema,
          GetNotificationChannelsParameters,
          GetNotificationChannelsData,
          GetNotificationChannelsError
        >
      >,
      TCombinedResult = Array<UseQueryResult<GetNotificationChannelsData, GetNotificationChannelsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetNotificationChannelsData, GetNotificationChannelsError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(
      parameters: DeepReadonly<GetNotificationChannelsParameters> | void
    ): ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNotificationChannels.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNotificationChannels.useQuery({
     *     query: {
     *         limit: limit
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetNotificationChannelsData>(
      parameters:
        | ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        | (DeepReadonly<GetNotificationChannelsParameters> | void),
      options?: Omit<
        UndefinedInitialDataOptions<
          GetNotificationChannelsData,
          GetNotificationChannelsError,
          TData,
          ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetNotificationChannelsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query without parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNotificationChannels.useQuery()
     * ```
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNotificationChannels.useQuery({
     *     query: {
     *         limit: limit
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetNotificationChannelsData>(
      parameters:
        | ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        | (DeepReadonly<GetNotificationChannelsParameters> | void),
      options: Omit<
        DefinedInitialDataOptions<
          GetNotificationChannelsData,
          GetNotificationChannelsError,
          TData,
          ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetNotificationChannelsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getNotificationChannels.useSuspenseInfiniteQuery({
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {
     *         query: {
     *             limit: initialLimit
     *         }
     *     },
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetNotificationChannelsParameters, TData = GetNotificationChannelsData>(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        | (DeepReadonly<GetNotificationChannelsParameters> | void),
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetNotificationChannelsData,
          GetNotificationChannelsError,
          OperationInfiniteData<TData, GetNotificationChannelsParameters>,
          GetNotificationChannelsData,
          ServiceOperationInfiniteQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetNotificationChannelsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetNotificationChannelsParameters>, GetNotificationChannelsError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getNotificationChannelsData = qraft.v1Service.getNotificationChannels.useSuspenseQueries({
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getNotificationChannelsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getNotificationChannelsCombinedData = qraft.v1Service.getNotificationChannels.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             query: {
     *                 limit: limit1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             query: {
     *                 limit: limit2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getNotificationChannelsCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<
          GetNotificationChannelsSchema,
          GetNotificationChannelsParameters,
          GetNotificationChannelsData,
          GetNotificationChannelsError
        >
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetNotificationChannelsData, GetNotificationChannelsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetNotificationChannelsData, GetNotificationChannelsError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query without parameters
     * ```ts
     * const data = qraft.v1Service.getNotificationChannels.useSuspenseQuery()
     * ```
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getNotificationChannels.useSuspenseQuery({
     *     query: {
     *         limit: limit
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetNotificationChannelsData>(
      parameters:
        | ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        | (DeepReadonly<GetNotificationChannelsParameters> | void),
      options?: Omit<
        UseSuspenseQueryOptions<
          GetNotificationChannelsData,
          GetNotificationChannelsError,
          TData,
          ServiceOperationQueryKey<GetNotificationChannelsSchema, GetNotificationChannelsParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetNotificationChannelsError | Error>;
    schema: GetNotificationChannelsSchema;
    types: {
      parameters: GetNotificationChannelsParameters;
      data: GetNotificationChannelsData;
      error: GetNotificationChannelsError;
    };
  };
  createDefaultChannel: {
    /**/
    getMutationKey(
      parameters: DeepReadonly<CreateDefaultChannelParameters> | void
    ): ServiceOperationMutationKey<CreateDefaultChannelSchema, CreateDefaultChannelParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createDefaultChannel.useMutation({
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createDefaultChannel.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends CreateDefaultChannelBody, TContext = unknown>(
      parameters: DeepReadonly<CreateDefaultChannelParameters>,
      options?: ServiceOperationUseMutationOptions<
        CreateDefaultChannelSchema,
        CreateDefaultChannelData,
        CreateDefaultChannelParameters,
        TVariables,
        CreateDefaultChannelError | Error,
        TContext
      >
    ): UseMutationResult<CreateDefaultChannelData, CreateDefaultChannelError | Error, TVariables, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createDefaultChannel.useMutation({
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createDefaultChannel.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<CreateDefaultChannelBody, CreateDefaultChannelParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        CreateDefaultChannelSchema,
        CreateDefaultChannelData,
        CreateDefaultChannelParameters,
        TVariables,
        CreateDefaultChannelError | Error,
        TContext
      >
    ): UseMutationResult<CreateDefaultChannelData, CreateDefaultChannelError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const createDefaultChannelTotal = qraft.v1Service.createDefaultChannel.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const createDefaultChannelTotal = qraft.v1Service.createDefaultChannel.useIsMutating({
     *     parameters: {
     *         header: {
     *             Authorization: authorization
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<
            CreateDefaultChannelBody,
            CreateDefaultChannelData,
            CreateDefaultChannelParameters,
            CreateDefaultChannelError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            CreateDefaultChannelSchema,
            CreateDefaultChannelBody,
            CreateDefaultChannelData,
            CreateDefaultChannelParameters,
            CreateDefaultChannelError | Error,
            TContext
          >
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<
            CreateDefaultChannelBody,
            CreateDefaultChannelData,
            CreateDefaultChannelParameters,
            CreateDefaultChannelError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            CreateDefaultChannelSchema,
            CreateDefaultChannelBody,
            CreateDefaultChannelData,
            CreateDefaultChannelParameters,
            CreateDefaultChannelError | Error,
            TContext
          >
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<CreateDefaultChannelBody, CreateDefaultChannelParameters>,
      client?: (
        schema: CreateDefaultChannelSchema,
        options: ServiceOperationMutationFnOptions<CreateDefaultChannelBody, CreateDefaultChannelParameters>
      ) => Promise<RequestFnResponse<CreateDefaultChannelData, CreateDefaultChannelError>>
    ): Promise<RequestFnResponse<CreateDefaultChannelData, CreateDefaultChannelError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const createDefaultChannelPendingMutationVariables = qraft.v1Service.createDefaultChannel.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const createDefaultChannelMutationData = qraft.v1Service.createDefaultChannel.useMutationState({
     *     filters: {
     *         parameters: {
     *             header: {
     *                 Authorization: authorization
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        CreateDefaultChannelData,
        CreateDefaultChannelError | Error,
        MutationVariables<CreateDefaultChannelBody, CreateDefaultChannelParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<
            CreateDefaultChannelBody,
            CreateDefaultChannelData,
            CreateDefaultChannelParameters,
            CreateDefaultChannelError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            CreateDefaultChannelSchema,
            CreateDefaultChannelBody,
            CreateDefaultChannelData,
            CreateDefaultChannelParameters,
            CreateDefaultChannelError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          CreateDefaultChannelData,
          CreateDefaultChannelError | Error,
          MutationVariables<CreateDefaultChannelBody, CreateDefaultChannelParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: CreateDefaultChannelSchema;
    types: {
      parameters: CreateDefaultChannelParameters;
      data: CreateDefaultChannelData;
      error: CreateDefaultChannelError;
      body: CreateDefaultChannelBody;
    };
  };
  getNotificationChannel: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(
      parameters: DeepReadonly<GetNotificationChannelParameters>
    ): ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNotificationChannel.useQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetNotificationChannelData>(
      parameters: ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters> | DeepReadonly<GetNotificationChannelParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetNotificationChannelData,
          GetNotificationChannelError,
          TData,
          ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetNotificationChannelError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNotificationChannel.useQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetNotificationChannelData>(
      parameters: ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters> | DeepReadonly<GetNotificationChannelParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetNotificationChannelData,
          GetNotificationChannelError,
          TData,
          ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetNotificationChannelError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetNotificationChannelParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetNotificationChannelSchema,
        GetNotificationChannelData,
        GetNotificationChannelParameters,
        DeepReadonly<TPageParam>,
        GetNotificationChannelError
      >
    ): Promise<OperationInfiniteData<GetNotificationChannelData, GetNotificationChannelParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetNotificationChannelParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetNotificationChannelSchema,
        GetNotificationChannelData,
        GetNotificationChannelParameters,
        DeepReadonly<TPageParam>,
        GetNotificationChannelError
      >
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetNotificationChannelParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetNotificationChannelSchema,
        GetNotificationChannelData,
        GetNotificationChannelParameters,
        DeepReadonly<TPageParam>,
        GetNotificationChannelError
      >
    ): Promise<OperationInfiniteData<GetNotificationChannelData, GetNotificationChannelParameters>>;
    /**/
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetNotificationChannelSchema,
        GetNotificationChannelData,
        GetNotificationChannelParameters,
        GetNotificationChannelError
      >
    ): Promise<GetNotificationChannelData>;
    /**/
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<
        GetNotificationChannelSchema,
        GetNotificationChannelData,
        GetNotificationChannelParameters,
        GetNotificationChannelError
      >
    ): Promise<void>;
    /**/
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetNotificationChannelSchema,
        GetNotificationChannelData,
        GetNotificationChannelParameters,
        GetNotificationChannelError
      >
    ): Promise<GetNotificationChannelData>;
    /**/
    getInfiniteQueryData(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>
        | DeepReadonly<GetNotificationChannelParameters>
    ): OperationInfiniteData<GetNotificationChannelData, GetNotificationChannelParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>,
            data: NoInfer<OperationInfiniteData<GetNotificationChannelData, GetNotificationChannelParameters>> | undefined
          ]
        >
      : Array<
          [queryKey: ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>, data: GetNotificationChannelData | undefined]
        >;
    /**/
    getQueryData(
      parameters: ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters> | DeepReadonly<GetNotificationChannelParameters>
    ): GetNotificationChannelData | undefined;
    /**/
    getQueryState(
      parameters: ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters> | DeepReadonly<GetNotificationChannelParameters>
    ): QueryState<GetNotificationChannelData, GetNotificationChannelError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters:
        | DeepReadonly<GetNotificationChannelParameters>
        | ServiceOperationInfiniteQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>
    ): QueryState<OperationInfiniteData<GetNotificationChannelData, GetNotificationChannelParameters>, GetNotificationChannelError> | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<
        GetNotificationChannelSchema,
        GetNotificationChannelData,
        TInfinite,
        GetNotificationChannelParameters,
        GetNotificationChannelError
      >,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetNotificationChannelParameters, TMeta, TSignal>,
      client?: (
        schema: GetNotificationChannelSchema,
        options: {
          parameters: GetNotificationChannelParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetNotificationChannelData, GetNotificationChannelError>>
    ): Promise<RequestFnResponse<GetNotificationChannelData, GetNotificationChannelError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters:
        | DeepReadonly<GetNotificationChannelParameters>
        | ServiceOperationInfiniteQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetNotificationChannelData, GetNotificationChannelParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetNotificationChannelData, GetNotificationChannelParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetNotificationChannelData, GetNotificationChannelParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >,
      updater: Updater<NoInfer<GetNotificationChannelData> | undefined, NoInfer<GetNotificationChannelData> | undefined>,
      options?: SetDataOptions
    ): Array<GetNotificationChannelData | undefined>;
    /**/
    setQueryData(
      parameters: DeepReadonly<GetNotificationChannelParameters> | ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>,
      updater: Updater<NoInfer<GetNotificationChannelData> | undefined, NoInfer<DeepReadonly<GetNotificationChannelData>> | undefined>,
      options?: SetDataOptions
    ): GetNotificationChannelData | undefined;
    /**/
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetNotificationChannelParameters>
    ): ServiceOperationInfiniteQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getNotificationChannel.useInfiniteQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetNotificationChannelParameters,
      TQueryFnData = GetNotificationChannelData,
      TData = OperationInfiniteData<TQueryFnData, GetNotificationChannelParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>
        | DeepReadonly<GetNotificationChannelParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetNotificationChannelError,
          TData,
          ServiceOperationInfiniteQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetNotificationChannelError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getNotificationChannel.useInfiniteQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetNotificationChannelParameters,
      TQueryFnData = GetNotificationChannelData,
      TData = OperationInfiniteData<TQueryFnData, GetNotificationChannelParameters>
    >(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>
        | DeepReadonly<GetNotificationChannelParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetNotificationChannelError,
          TData,
          ServiceOperationInfiniteQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetNotificationChannelData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetNotificationChannelError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getNotificationChannelTotal = qraft.v1Service.getNotificationChannel.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getNotificationChannelByParametersTotal = qraft.v1Service.getNotificationChannel.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             id: id
     *         },
     *         header: {
     *             Authorization: authorization
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >
        | QueryFiltersByQueryKey<
            GetNotificationChannelSchema,
            GetNotificationChannelData,
            TInfinite,
            GetNotificationChannelParameters,
            GetNotificationChannelError
          >
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getNotificationChannelResults = qraft.v1Service.getNotificationChannel.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getNotificationChannelResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getNotificationChannelCombinedResults = qraft.v1Service.getNotificationChannel.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getNotificationChannelCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<GetNotificationChannelSchema, GetNotificationChannelParameters, GetNotificationChannelData, GetNotificationChannelError>
      >,
      TCombinedResult = Array<UseQueryResult<GetNotificationChannelData, GetNotificationChannelError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetNotificationChannelData, GetNotificationChannelError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(
      parameters: DeepReadonly<GetNotificationChannelParameters>
    ): ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNotificationChannel.useQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetNotificationChannelData>(
      parameters: ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters> | DeepReadonly<GetNotificationChannelParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetNotificationChannelData,
          GetNotificationChannelError,
          TData,
          ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetNotificationChannelError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getNotificationChannel.useQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetNotificationChannelData>(
      parameters: ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters> | DeepReadonly<GetNotificationChannelParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetNotificationChannelData,
          GetNotificationChannelError,
          TData,
          ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetNotificationChannelError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getNotificationChannel.useSuspenseInfiniteQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetNotificationChannelParameters, TData = GetNotificationChannelData>(
      parameters:
        | ServiceOperationInfiniteQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>
        | DeepReadonly<GetNotificationChannelParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetNotificationChannelData,
          GetNotificationChannelError,
          OperationInfiniteData<TData, GetNotificationChannelParameters>,
          GetNotificationChannelData,
          ServiceOperationInfiniteQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetNotificationChannelData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetNotificationChannelParameters>, GetNotificationChannelError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getNotificationChannelData = qraft.v1Service.getNotificationChannel.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getNotificationChannelResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getNotificationChannelCombinedData = qraft.v1Service.getNotificationChannel.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getNotificationChannelCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<
          GetNotificationChannelSchema,
          GetNotificationChannelParameters,
          GetNotificationChannelData,
          GetNotificationChannelError
        >
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetNotificationChannelData, GetNotificationChannelError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetNotificationChannelData, GetNotificationChannelError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getNotificationChannel.useSuspenseQuery({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetNotificationChannelData>(
      parameters: ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters> | DeepReadonly<GetNotificationChannelParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<
          GetNotificationChannelData,
          GetNotificationChannelError,
          TData,
          ServiceOperationQueryKey<GetNotificationChannelSchema, GetNotificationChannelParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetNotificationChannelError | Error>;
    schema: GetNotificationChannelSchema;
    types: {
      parameters: GetNotificationChannelParameters;
      data: GetNotificationChannelData;
      error: GetNotificationChannelError;
    };
  };
  patchNotificationChannel: {
    /**/
    getMutationKey(
      parameters: DeepReadonly<PatchNotificationChannelParameters> | void
    ): ServiceOperationMutationKey<PatchNotificationChannelSchema, PatchNotificationChannelParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchNotificationChannel.useMutation({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchNotificationChannel.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends PatchNotificationChannelBody, TContext = unknown>(
      parameters: DeepReadonly<PatchNotificationChannelParameters>,
      options?: ServiceOperationUseMutationOptions<
        PatchNotificationChannelSchema,
        PatchNotificationChannelData,
        PatchNotificationChannelParameters,
        TVariables,
        PatchNotificationChannelError | Error,
        TContext
      >
    ): UseMutationResult<PatchNotificationChannelData, PatchNotificationChannelError | Error, TVariables, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchNotificationChannel.useMutation({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchNotificationChannel.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PatchNotificationChannelBody, PatchNotificationChannelParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PatchNotificationChannelSchema,
        PatchNotificationChannelData,
        PatchNotificationChannelParameters,
        TVariables,
        PatchNotificationChannelError | Error,
        TContext
      >
    ): UseMutationResult<PatchNotificationChannelData, PatchNotificationChannelError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const patchNotificationChannelTotal = qraft.v1Service.patchNotificationChannel.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const patchNotificationChannelTotal = qraft.v1Service.patchNotificationChannel.useIsMutating({
     *     parameters: {
     *         path: {
     *             id: id
     *         },
     *         header: {
     *             Authorization: authorization
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<
            PatchNotificationChannelBody,
            PatchNotificationChannelData,
            PatchNotificationChannelParameters,
            PatchNotificationChannelError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PatchNotificationChannelSchema,
            PatchNotificationChannelBody,
            PatchNotificationChannelData,
            PatchNotificationChannelParameters,
            PatchNotificationChannelError | Error,
            TContext
          >
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<
            PatchNotificationChannelBody,
            PatchNotificationChannelData,
            PatchNotificationChannelParameters,
            PatchNotificationChannelError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PatchNotificationChannelSchema,
            PatchNotificationChannelBody,
            PatchNotificationChannelData,
            PatchNotificationChannelParameters,
            PatchNotificationChannelError | Error,
            TContext
          >
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<PatchNotificationChannelBody, PatchNotificationChannelParameters>,
      client?: (
        schema: PatchNotificationChannelSchema,
        options: ServiceOperationMutationFnOptions<PatchNotificationChannelBody, PatchNotificationChannelParameters>
      ) => Promise<RequestFnResponse<PatchNotificationChannelData, PatchNotificationChannelError>>
    ): Promise<RequestFnResponse<PatchNotificationChannelData, PatchNotificationChannelError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const patchNotificationChannelPendingMutationVariables = qraft.v1Service.patchNotificationChannel.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const patchNotificationChannelMutationData = qraft.v1Service.patchNotificationChannel.useMutationState({
     *     filters: {
     *         parameters: {
     *             path: {
     *                 id: id
     *             },
     *             header: {
     *                 Authorization: authorization
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        PatchNotificationChannelData,
        PatchNotificationChannelError | Error,
        MutationVariables<PatchNotificationChannelBody, PatchNotificationChannelParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<
            PatchNotificationChannelBody,
            PatchNotificationChannelData,
            PatchNotificationChannelParameters,
            PatchNotificationChannelError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            PatchNotificationChannelSchema,
            PatchNotificationChannelBody,
            PatchNotificationChannelData,
            PatchNotificationChannelParameters,
            PatchNotificationChannelError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          PatchNotificationChannelData,
          PatchNotificationChannelError | Error,
          MutationVariables<PatchNotificationChannelBody, PatchNotificationChannelParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: PatchNotificationChannelSchema;
    types: {
      parameters: PatchNotificationChannelParameters;
      data: PatchNotificationChannelData;
      error: PatchNotificationChannelError;
      body: PatchNotificationChannelBody;
    };
  };
  deleteNotificationChannel: {
    /**/
    getMutationKey(
      parameters: DeepReadonly<DeleteNotificationChannelParameters> | void
    ): ServiceOperationMutationKey<DeleteNotificationChannelSchema, DeleteNotificationChannelParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteNotificationChannel.useMutation({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteNotificationChannel.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends DeleteNotificationChannelBody, TContext = unknown>(
      parameters: DeepReadonly<DeleteNotificationChannelParameters>,
      options?: ServiceOperationUseMutationOptions<
        DeleteNotificationChannelSchema,
        DeleteNotificationChannelData,
        DeleteNotificationChannelParameters,
        TVariables,
        DeleteNotificationChannelError | Error,
        TContext
      >
    ): UseMutationResult<DeleteNotificationChannelData, DeleteNotificationChannelError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteNotificationChannel.useMutation({
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteNotificationChannel.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<DeleteNotificationChannelBody, DeleteNotificationChannelParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        DeleteNotificationChannelSchema,
        DeleteNotificationChannelData,
        DeleteNotificationChannelParameters,
        TVariables,
        DeleteNotificationChannelError | Error,
        TContext
      >
    ): UseMutationResult<DeleteNotificationChannelData, DeleteNotificationChannelError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const deleteNotificationChannelTotal = qraft.v1Service.deleteNotificationChannel.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const deleteNotificationChannelTotal = qraft.v1Service.deleteNotificationChannel.useIsMutating({
     *     parameters: {
     *         path: {
     *             id: id
     *         },
     *         header: {
     *             Authorization: authorization
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<
            DeleteNotificationChannelBody,
            DeleteNotificationChannelData,
            DeleteNotificationChannelParameters,
            DeleteNotificationChannelError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            DeleteNotificationChannelSchema,
            DeleteNotificationChannelBody,
            DeleteNotificationChannelData,
            DeleteNotificationChannelParameters,
            DeleteNotificationChannelError | Error,
            TContext
          >
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<
            DeleteNotificationChannelBody,
            DeleteNotificationChannelData,
            DeleteNotificationChannelParameters,
            DeleteNotificationChannelError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            DeleteNotificationChannelSchema,
            DeleteNotificationChannelBody,
            DeleteNotificationChannelData,
            DeleteNotificationChannelParameters,
            DeleteNotificationChannelError | Error,
            TContext
          >
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<DeleteNotificationChannelBody, DeleteNotificationChannelParameters>,
      client?: (
        schema: DeleteNotificationChannelSchema,
        options: ServiceOperationMutationFnOptions<DeleteNotificationChannelBody, DeleteNotificationChannelParameters>
      ) => Promise<RequestFnResponse<DeleteNotificationChannelData, DeleteNotificationChannelError>>
    ): Promise<RequestFnResponse<DeleteNotificationChannelData, DeleteNotificationChannelError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const deleteNotificationChannelPendingMutationVariables = qraft.v1Service.deleteNotificationChannel.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const deleteNotificationChannelMutationData = qraft.v1Service.deleteNotificationChannel.useMutationState({
     *     filters: {
     *         parameters: {
     *             path: {
     *                 id: id
     *             },
     *             header: {
     *                 Authorization: authorization
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        DeleteNotificationChannelData,
        DeleteNotificationChannelError | Error,
        MutationVariables<DeleteNotificationChannelBody, DeleteNotificationChannelParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<
            DeleteNotificationChannelBody,
            DeleteNotificationChannelData,
            DeleteNotificationChannelParameters,
            DeleteNotificationChannelError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            DeleteNotificationChannelSchema,
            DeleteNotificationChannelBody,
            DeleteNotificationChannelData,
            DeleteNotificationChannelParameters,
            DeleteNotificationChannelError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          DeleteNotificationChannelData,
          DeleteNotificationChannelError | Error,
          MutationVariables<DeleteNotificationChannelBody, DeleteNotificationChannelParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: DeleteNotificationChannelSchema;
    types: {
      parameters: DeleteNotificationChannelParameters;
      data: DeleteNotificationChannelData;
      error: DeleteNotificationChannelError;
      body: DeleteNotificationChannelBody;
    };
  };
  upsertDeploymentAlert: {
    /**/
    getMutationKey(
      parameters: DeepReadonly<UpsertDeploymentAlertParameters> | void
    ): ServiceOperationMutationKey<UpsertDeploymentAlertSchema, UpsertDeploymentAlertParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.upsertDeploymentAlert.useMutation({
     *     path: {
     *         dseq: dseq
     *     },
     *     header: {
     *         "x-owner-address": xOwnerAddress
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.upsertDeploymentAlert.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         dseq: dseq
     *     },
     *     header: {
     *         "x-owner-address": xOwnerAddress
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends UpsertDeploymentAlertBody, TContext = unknown>(
      parameters: DeepReadonly<UpsertDeploymentAlertParameters>,
      options?: ServiceOperationUseMutationOptions<
        UpsertDeploymentAlertSchema,
        UpsertDeploymentAlertData,
        UpsertDeploymentAlertParameters,
        TVariables,
        UpsertDeploymentAlertError | Error,
        TContext
      >
    ): UseMutationResult<UpsertDeploymentAlertData, UpsertDeploymentAlertError | Error, TVariables, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.upsertDeploymentAlert.useMutation({
     *     path: {
     *         dseq: dseq
     *     },
     *     header: {
     *         "x-owner-address": xOwnerAddress
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.upsertDeploymentAlert.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         dseq: dseq
     *     },
     *     header: {
     *         "x-owner-address": xOwnerAddress
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<UpsertDeploymentAlertBody, UpsertDeploymentAlertParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        UpsertDeploymentAlertSchema,
        UpsertDeploymentAlertData,
        UpsertDeploymentAlertParameters,
        TVariables,
        UpsertDeploymentAlertError | Error,
        TContext
      >
    ): UseMutationResult<UpsertDeploymentAlertData, UpsertDeploymentAlertError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const upsertDeploymentAlertTotal = qraft.v1Service.upsertDeploymentAlert.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const upsertDeploymentAlertTotal = qraft.v1Service.upsertDeploymentAlert.useIsMutating({
     *     parameters: {
     *         path: {
     *             dseq: dseq
     *         },
     *         header: {
     *             "x-owner-address": xOwnerAddress
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<
            UpsertDeploymentAlertBody,
            UpsertDeploymentAlertData,
            UpsertDeploymentAlertParameters,
            UpsertDeploymentAlertError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            UpsertDeploymentAlertSchema,
            UpsertDeploymentAlertBody,
            UpsertDeploymentAlertData,
            UpsertDeploymentAlertParameters,
            UpsertDeploymentAlertError | Error,
            TContext
          >
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<
            UpsertDeploymentAlertBody,
            UpsertDeploymentAlertData,
            UpsertDeploymentAlertParameters,
            UpsertDeploymentAlertError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            UpsertDeploymentAlertSchema,
            UpsertDeploymentAlertBody,
            UpsertDeploymentAlertData,
            UpsertDeploymentAlertParameters,
            UpsertDeploymentAlertError | Error,
            TContext
          >
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<UpsertDeploymentAlertBody, UpsertDeploymentAlertParameters>,
      client?: (
        schema: UpsertDeploymentAlertSchema,
        options: ServiceOperationMutationFnOptions<UpsertDeploymentAlertBody, UpsertDeploymentAlertParameters>
      ) => Promise<RequestFnResponse<UpsertDeploymentAlertData, UpsertDeploymentAlertError>>
    ): Promise<RequestFnResponse<UpsertDeploymentAlertData, UpsertDeploymentAlertError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const upsertDeploymentAlertPendingMutationVariables = qraft.v1Service.upsertDeploymentAlert.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const upsertDeploymentAlertMutationData = qraft.v1Service.upsertDeploymentAlert.useMutationState({
     *     filters: {
     *         parameters: {
     *             path: {
     *                 dseq: dseq
     *             },
     *             header: {
     *                 "x-owner-address": xOwnerAddress
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        UpsertDeploymentAlertData,
        UpsertDeploymentAlertError | Error,
        MutationVariables<UpsertDeploymentAlertBody, UpsertDeploymentAlertParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<
            UpsertDeploymentAlertBody,
            UpsertDeploymentAlertData,
            UpsertDeploymentAlertParameters,
            UpsertDeploymentAlertError | Error,
            TContext
          >
        | MutationFiltersByMutationKey<
            UpsertDeploymentAlertSchema,
            UpsertDeploymentAlertBody,
            UpsertDeploymentAlertData,
            UpsertDeploymentAlertParameters,
            UpsertDeploymentAlertError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          UpsertDeploymentAlertData,
          UpsertDeploymentAlertError | Error,
          MutationVariables<UpsertDeploymentAlertBody, UpsertDeploymentAlertParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: UpsertDeploymentAlertSchema;
    types: {
      parameters: UpsertDeploymentAlertParameters;
      data: UpsertDeploymentAlertData;
      error: UpsertDeploymentAlertError;
      body: UpsertDeploymentAlertBody;
    };
  };
  getDeploymentAlerts: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
        | QueryFiltersByQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(parameters: DeepReadonly<GetDeploymentAlertsParameters>): ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeploymentAlerts.useQuery({
     *     path: {
     *         dseq: dseq
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetDeploymentAlertsData>(
      parameters: ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters> | DeepReadonly<GetDeploymentAlertsParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetDeploymentAlertsData,
          GetDeploymentAlertsError,
          TData,
          ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetDeploymentAlertsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeploymentAlerts.useQuery({
     *     path: {
     *         dseq: dseq
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetDeploymentAlertsData>(
      parameters: ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters> | DeepReadonly<GetDeploymentAlertsParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetDeploymentAlertsData,
          GetDeploymentAlertsError,
          TData,
          ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetDeploymentAlertsError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetDeploymentAlertsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetDeploymentAlertsSchema,
        GetDeploymentAlertsData,
        GetDeploymentAlertsParameters,
        DeepReadonly<TPageParam>,
        GetDeploymentAlertsError
      >
    ): Promise<OperationInfiniteData<GetDeploymentAlertsData, GetDeploymentAlertsParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetDeploymentAlertsParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetDeploymentAlertsSchema,
        GetDeploymentAlertsData,
        GetDeploymentAlertsParameters,
        DeepReadonly<TPageParam>,
        GetDeploymentAlertsError
      >
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetDeploymentAlertsParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetDeploymentAlertsSchema,
        GetDeploymentAlertsData,
        GetDeploymentAlertsParameters,
        DeepReadonly<TPageParam>,
        GetDeploymentAlertsError
      >
    ): Promise<OperationInfiniteData<GetDeploymentAlertsData, GetDeploymentAlertsParameters>>;
    /**/
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetDeploymentAlertsSchema, GetDeploymentAlertsData, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
    ): Promise<GetDeploymentAlertsData>;
    /**/
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetDeploymentAlertsSchema, GetDeploymentAlertsData, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
    ): Promise<void>;
    /**/
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<
        GetDeploymentAlertsSchema,
        GetDeploymentAlertsData,
        GetDeploymentAlertsParameters,
        GetDeploymentAlertsError
      >
    ): Promise<GetDeploymentAlertsData>;
    /**/
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters> | DeepReadonly<GetDeploymentAlertsParameters>
    ): OperationInfiniteData<GetDeploymentAlertsData, GetDeploymentAlertsParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
        | QueryFiltersByQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>,
            data: NoInfer<OperationInfiniteData<GetDeploymentAlertsData, GetDeploymentAlertsParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>, data: GetDeploymentAlertsData | undefined]>;
    /**/
    getQueryData(
      parameters: ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters> | DeepReadonly<GetDeploymentAlertsParameters>
    ): GetDeploymentAlertsData | undefined;
    /**/
    getQueryState(
      parameters: ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters> | DeepReadonly<GetDeploymentAlertsParameters>
    ): QueryState<GetDeploymentAlertsData, GetDeploymentAlertsError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters: DeepReadonly<GetDeploymentAlertsParameters> | ServiceOperationInfiniteQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>
    ): QueryState<OperationInfiniteData<GetDeploymentAlertsData, GetDeploymentAlertsParameters>, GetDeploymentAlertsError> | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
        | QueryFiltersByQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetDeploymentAlertsParameters, TMeta, TSignal>,
      client?: (
        schema: GetDeploymentAlertsSchema,
        options: {
          parameters: GetDeploymentAlertsParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetDeploymentAlertsData, GetDeploymentAlertsError>>
    ): Promise<RequestFnResponse<GetDeploymentAlertsData, GetDeploymentAlertsError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
        | QueryFiltersByQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
        | QueryFiltersByQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
        | QueryFiltersByQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters: DeepReadonly<GetDeploymentAlertsParameters> | ServiceOperationInfiniteQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetDeploymentAlertsData, GetDeploymentAlertsParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetDeploymentAlertsData, GetDeploymentAlertsParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetDeploymentAlertsData, GetDeploymentAlertsParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
        | QueryFiltersByQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>,
      updater: Updater<NoInfer<GetDeploymentAlertsData> | undefined, NoInfer<GetDeploymentAlertsData> | undefined>,
      options?: SetDataOptions
    ): Array<GetDeploymentAlertsData | undefined>;
    /**/
    setQueryData(
      parameters: DeepReadonly<GetDeploymentAlertsParameters> | ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>,
      updater: Updater<NoInfer<GetDeploymentAlertsData> | undefined, NoInfer<DeepReadonly<GetDeploymentAlertsData>> | undefined>,
      options?: SetDataOptions
    ): GetDeploymentAlertsData | undefined;
    /**/
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetDeploymentAlertsParameters>
    ): ServiceOperationInfiniteQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getDeploymentAlerts.useInfiniteQuery({
     *     path: {
     *         dseq: dseq
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetDeploymentAlertsParameters,
      TQueryFnData = GetDeploymentAlertsData,
      TData = OperationInfiniteData<TQueryFnData, GetDeploymentAlertsParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters> | DeepReadonly<GetDeploymentAlertsParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetDeploymentAlertsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetDeploymentAlertsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getDeploymentAlerts.useInfiniteQuery({
     *     path: {
     *         dseq: dseq
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetDeploymentAlertsParameters,
      TQueryFnData = GetDeploymentAlertsData,
      TData = OperationInfiniteData<TQueryFnData, GetDeploymentAlertsParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters> | DeepReadonly<GetDeploymentAlertsParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetDeploymentAlertsError,
          TData,
          ServiceOperationInfiniteQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetDeploymentAlertsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetDeploymentAlertsError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getDeploymentAlertsTotal = qraft.v1Service.getDeploymentAlerts.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getDeploymentAlertsByParametersTotal = qraft.v1Service.getDeploymentAlerts.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             dseq: dseq
     *         },
     *         header: {
     *             Authorization: authorization
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
        | QueryFiltersByQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsData, TInfinite, GetDeploymentAlertsParameters, GetDeploymentAlertsError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getDeploymentAlertsResults = qraft.v1Service.getDeploymentAlerts.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 dseq: dseq1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             path: {
     *                 dseq: dseq2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getDeploymentAlertsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getDeploymentAlertsCombinedResults = qraft.v1Service.getDeploymentAlerts.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 dseq: dseq1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             path: {
     *                 dseq: dseq2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getDeploymentAlertsCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<
        UseQueryOptionsForUseQueries<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters, GetDeploymentAlertsData, GetDeploymentAlertsError>
      >,
      TCombinedResult = Array<UseQueryResult<GetDeploymentAlertsData, GetDeploymentAlertsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetDeploymentAlertsData, GetDeploymentAlertsError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(parameters: DeepReadonly<GetDeploymentAlertsParameters>): ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeploymentAlerts.useQuery({
     *     path: {
     *         dseq: dseq
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetDeploymentAlertsData>(
      parameters: ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters> | DeepReadonly<GetDeploymentAlertsParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetDeploymentAlertsData,
          GetDeploymentAlertsError,
          TData,
          ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetDeploymentAlertsError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getDeploymentAlerts.useQuery({
     *     path: {
     *         dseq: dseq
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useQuery<TData = GetDeploymentAlertsData>(
      parameters: ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters> | DeepReadonly<GetDeploymentAlertsParameters>,
      options: Omit<
        DefinedInitialDataOptions<
          GetDeploymentAlertsData,
          GetDeploymentAlertsError,
          TData,
          ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>
        >,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetDeploymentAlertsError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getDeploymentAlerts.useSuspenseInfiniteQuery({
     *     path: {
     *         dseq: dseq
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetDeploymentAlertsParameters, TData = GetDeploymentAlertsData>(
      parameters: ServiceOperationInfiniteQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters> | DeepReadonly<GetDeploymentAlertsParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetDeploymentAlertsData,
          GetDeploymentAlertsError,
          OperationInfiniteData<TData, GetDeploymentAlertsParameters>,
          GetDeploymentAlertsData,
          ServiceOperationInfiniteQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetDeploymentAlertsData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetDeploymentAlertsParameters>, GetDeploymentAlertsError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getDeploymentAlertsData = qraft.v1Service.getDeploymentAlerts.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 dseq: dseq1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             path: {
     *                 dseq: dseq2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getDeploymentAlertsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getDeploymentAlertsCombinedData = qraft.v1Service.getDeploymentAlerts.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 dseq: dseq1
     *             },
     *             header: {
     *                 Authorization: authorization1
     *             }
     *         },
     *         {
     *             path: {
     *                 dseq: dseq2
     *             },
     *             header: {
     *                 Authorization: authorization2
     *             }
     *         }
     *     ]
     * });
     * getDeploymentAlertsCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<
        UseQueryOptionsForUseSuspenseQuery<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters, GetDeploymentAlertsData, GetDeploymentAlertsError>
      >,
      TCombinedResult = Array<UseSuspenseQueryResult<GetDeploymentAlertsData, GetDeploymentAlertsError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetDeploymentAlertsData, GetDeploymentAlertsError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getDeploymentAlerts.useSuspenseQuery({
     *     path: {
     *         dseq: dseq
     *     },
     *     header: {
     *         Authorization: authorization
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetDeploymentAlertsData>(
      parameters: ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters> | DeepReadonly<GetDeploymentAlertsParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<
          GetDeploymentAlertsData,
          GetDeploymentAlertsError,
          TData,
          ServiceOperationQueryKey<GetDeploymentAlertsSchema, GetDeploymentAlertsParameters>
        >,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetDeploymentAlertsError | Error>;
    schema: GetDeploymentAlertsSchema;
    types: {
      parameters: GetDeploymentAlertsParameters;
      data: GetDeploymentAlertsData;
      error: GetDeploymentAlertsError;
    };
  };
}
export const createAlert = {
  schema: {
    method: "post",
    url: "/v1/alerts",
    mediaType: ["application/json"]
  }
} as {
  schema: CreateAlertSchema;
  [QraftServiceOperationsToken]: V1Service["createAlert"];
};
export const getAlerts = {
  schema: {
    method: "get",
    url: "/v1/alerts"
  }
} as {
  schema: GetAlertsSchema;
  [QraftServiceOperationsToken]: V1Service["getAlerts"];
};
export const getAlert = {
  schema: {
    method: "get",
    url: "/v1/alerts/{id}"
  }
} as {
  schema: GetAlertSchema;
  [QraftServiceOperationsToken]: V1Service["getAlert"];
};
export const patchAlert = {
  schema: {
    method: "patch",
    url: "/v1/alerts/{id}",
    mediaType: ["application/json"]
  }
} as {
  schema: PatchAlertSchema;
  [QraftServiceOperationsToken]: V1Service["patchAlert"];
};
export const deleteAlert = {
  schema: {
    method: "delete",
    url: "/v1/alerts/{id}"
  }
} as {
  schema: DeleteAlertSchema;
  [QraftServiceOperationsToken]: V1Service["deleteAlert"];
};
export const createNotificationChannel = {
  schema: {
    method: "post",
    url: "/v1/notification-channels",
    mediaType: ["application/json"]
  }
} as {
  schema: CreateNotificationChannelSchema;
  [QraftServiceOperationsToken]: V1Service["createNotificationChannel"];
};
export const getNotificationChannels = {
  schema: {
    method: "get",
    url: "/v1/notification-channels"
  }
} as {
  schema: GetNotificationChannelsSchema;
  [QraftServiceOperationsToken]: V1Service["getNotificationChannels"];
};
export const createDefaultChannel = {
  schema: {
    method: "post",
    url: "/v1/notification-channels/default",
    mediaType: ["application/json"]
  }
} as {
  schema: CreateDefaultChannelSchema;
  [QraftServiceOperationsToken]: V1Service["createDefaultChannel"];
};
export const getNotificationChannel = {
  schema: {
    method: "get",
    url: "/v1/notification-channels/{id}"
  }
} as {
  schema: GetNotificationChannelSchema;
  [QraftServiceOperationsToken]: V1Service["getNotificationChannel"];
};
export const patchNotificationChannel = {
  schema: {
    method: "patch",
    url: "/v1/notification-channels/{id}",
    mediaType: ["application/json"]
  }
} as {
  schema: PatchNotificationChannelSchema;
  [QraftServiceOperationsToken]: V1Service["patchNotificationChannel"];
};
export const deleteNotificationChannel = {
  schema: {
    method: "delete",
    url: "/v1/notification-channels/{id}"
  }
} as {
  schema: DeleteNotificationChannelSchema;
  [QraftServiceOperationsToken]: V1Service["deleteNotificationChannel"];
};
export const upsertDeploymentAlert = {
  schema: {
    method: "post",
    url: "/v1/deployment-alerts/{dseq}",
    mediaType: ["application/json"]
  }
} as {
  schema: UpsertDeploymentAlertSchema;
  [QraftServiceOperationsToken]: V1Service["upsertDeploymentAlert"];
};
export const getDeploymentAlerts = {
  schema: {
    method: "get",
    url: "/v1/deployment-alerts/{dseq}"
  }
} as {
  schema: GetDeploymentAlertsSchema;
  [QraftServiceOperationsToken]: V1Service["getDeploymentAlerts"];
};
export const v1Service = {
  createAlert,
  getAlerts,
  getAlert,
  patchAlert,
  deleteAlert,
  createNotificationChannel,
  getNotificationChannels,
  createDefaultChannel,
  getNotificationChannel,
  patchNotificationChannel,
  deleteNotificationChannel,
  upsertDeploymentAlert,
  getDeploymentAlerts
} as const;
type CreateAlertSchema = {
  method: "post";
  url: "/v1/alerts";
  mediaType: ["application/json"];
};
type CreateAlertParameters = paths["/v1/alerts"]["post"]["parameters"];
type CreateAlertData = paths["/v1/alerts"]["post"]["responses"]["201"]["content"]["application/json"];
type CreateAlertError =
  | paths["/v1/alerts"]["post"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/alerts"]["post"]["responses"]["401"]["content"]["application/json"]
  | paths["/v1/alerts"]["post"]["responses"]["403"]["content"]["application/json"]
  | paths["/v1/alerts"]["post"]["responses"]["500"]["content"]["application/json"];
type CreateAlertBody = paths["/v1/alerts"]["post"]["requestBody"]["content"]["application/json"];
type GetAlertsSchema = {
  method: "get";
  url: "/v1/alerts";
};
type GetAlertsParameters = paths["/v1/alerts"]["get"]["parameters"];
type GetAlertsData = paths["/v1/alerts"]["get"]["responses"]["200"]["content"]["application/json"];
type GetAlertsError =
  | paths["/v1/alerts"]["get"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/alerts"]["get"]["responses"]["401"]["content"]["application/json"]
  | paths["/v1/alerts"]["get"]["responses"]["403"]["content"]["application/json"]
  | paths["/v1/alerts"]["get"]["responses"]["500"]["content"]["application/json"];
type GetAlertSchema = {
  method: "get";
  url: "/v1/alerts/{id}";
};
type GetAlertParameters = paths["/v1/alerts/{id}"]["get"]["parameters"];
type GetAlertData = paths["/v1/alerts/{id}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetAlertError =
  | paths["/v1/alerts/{id}"]["get"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/alerts/{id}"]["get"]["responses"]["401"]["content"]["application/json"]
  | paths["/v1/alerts/{id}"]["get"]["responses"]["403"]["content"]["application/json"]
  | paths["/v1/alerts/{id}"]["get"]["responses"]["500"]["content"]["application/json"];
type PatchAlertSchema = {
  method: "patch";
  url: "/v1/alerts/{id}";
  mediaType: ["application/json"];
};
type PatchAlertParameters = paths["/v1/alerts/{id}"]["patch"]["parameters"];
type PatchAlertData = paths["/v1/alerts/{id}"]["patch"]["responses"]["200"]["content"]["application/json"];
type PatchAlertError =
  | paths["/v1/alerts/{id}"]["patch"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/alerts/{id}"]["patch"]["responses"]["401"]["content"]["application/json"]
  | paths["/v1/alerts/{id}"]["patch"]["responses"]["403"]["content"]["application/json"]
  | paths["/v1/alerts/{id}"]["patch"]["responses"]["500"]["content"]["application/json"];
type PatchAlertBody = paths["/v1/alerts/{id}"]["patch"]["requestBody"]["content"]["application/json"];
type DeleteAlertSchema = {
  method: "delete";
  url: "/v1/alerts/{id}";
};
type DeleteAlertParameters = paths["/v1/alerts/{id}"]["delete"]["parameters"];
type DeleteAlertData = paths["/v1/alerts/{id}"]["delete"]["responses"]["200"]["content"]["application/json"];
type DeleteAlertError =
  | paths["/v1/alerts/{id}"]["delete"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/alerts/{id}"]["delete"]["responses"]["401"]["content"]["application/json"]
  | paths["/v1/alerts/{id}"]["delete"]["responses"]["403"]["content"]["application/json"]
  | paths["/v1/alerts/{id}"]["delete"]["responses"]["500"]["content"]["application/json"];
type DeleteAlertBody = undefined;
type CreateNotificationChannelSchema = {
  method: "post";
  url: "/v1/notification-channels";
  mediaType: ["application/json"];
};
type CreateNotificationChannelParameters = paths["/v1/notification-channels"]["post"]["parameters"];
type CreateNotificationChannelData = paths["/v1/notification-channels"]["post"]["responses"]["201"]["content"]["application/json"];
type CreateNotificationChannelError =
  | paths["/v1/notification-channels"]["post"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/notification-channels"]["post"]["responses"]["401"]["content"]["application/json"]
  | paths["/v1/notification-channels"]["post"]["responses"]["403"]["content"]["application/json"]
  | paths["/v1/notification-channels"]["post"]["responses"]["500"]["content"]["application/json"];
type CreateNotificationChannelBody = paths["/v1/notification-channels"]["post"]["requestBody"]["content"]["application/json"];
type GetNotificationChannelsSchema = {
  method: "get";
  url: "/v1/notification-channels";
};
type GetNotificationChannelsParameters = paths["/v1/notification-channels"]["get"]["parameters"];
type GetNotificationChannelsData = paths["/v1/notification-channels"]["get"]["responses"]["200"]["content"]["application/json"];
type GetNotificationChannelsError =
  | paths["/v1/notification-channels"]["get"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/notification-channels"]["get"]["responses"]["401"]["content"]["application/json"]
  | paths["/v1/notification-channels"]["get"]["responses"]["403"]["content"]["application/json"]
  | paths["/v1/notification-channels"]["get"]["responses"]["500"]["content"]["application/json"];
type CreateDefaultChannelSchema = {
  method: "post";
  url: "/v1/notification-channels/default";
  mediaType: ["application/json"];
};
type CreateDefaultChannelParameters = paths["/v1/notification-channels/default"]["post"]["parameters"];
type CreateDefaultChannelData = paths["/v1/notification-channels/default"]["post"]["responses"]["204"]["content"]["application/json"];
type CreateDefaultChannelError =
  | paths["/v1/notification-channels/default"]["post"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/notification-channels/default"]["post"]["responses"]["401"]["content"]["application/json"]
  | paths["/v1/notification-channels/default"]["post"]["responses"]["403"]["content"]["application/json"]
  | paths["/v1/notification-channels/default"]["post"]["responses"]["500"]["content"]["application/json"];
type CreateDefaultChannelBody = paths["/v1/notification-channels/default"]["post"]["requestBody"]["content"]["application/json"];
type GetNotificationChannelSchema = {
  method: "get";
  url: "/v1/notification-channels/{id}";
};
type GetNotificationChannelParameters = paths["/v1/notification-channels/{id}"]["get"]["parameters"];
type GetNotificationChannelData = paths["/v1/notification-channels/{id}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetNotificationChannelError =
  | paths["/v1/notification-channels/{id}"]["get"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/notification-channels/{id}"]["get"]["responses"]["401"]["content"]["application/json"]
  | paths["/v1/notification-channels/{id}"]["get"]["responses"]["403"]["content"]["application/json"]
  | paths["/v1/notification-channels/{id}"]["get"]["responses"]["404"]["content"]["application/json"]
  | paths["/v1/notification-channels/{id}"]["get"]["responses"]["500"]["content"]["application/json"];
type PatchNotificationChannelSchema = {
  method: "patch";
  url: "/v1/notification-channels/{id}";
  mediaType: ["application/json"];
};
type PatchNotificationChannelParameters = paths["/v1/notification-channels/{id}"]["patch"]["parameters"];
type PatchNotificationChannelData = paths["/v1/notification-channels/{id}"]["patch"]["responses"]["200"]["content"]["application/json"];
type PatchNotificationChannelError =
  | paths["/v1/notification-channels/{id}"]["patch"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/notification-channels/{id}"]["patch"]["responses"]["401"]["content"]["application/json"]
  | paths["/v1/notification-channels/{id}"]["patch"]["responses"]["403"]["content"]["application/json"]
  | paths["/v1/notification-channels/{id}"]["patch"]["responses"]["404"]["content"]["application/json"]
  | paths["/v1/notification-channels/{id}"]["patch"]["responses"]["500"]["content"]["application/json"];
type PatchNotificationChannelBody = paths["/v1/notification-channels/{id}"]["patch"]["requestBody"]["content"]["application/json"];
type DeleteNotificationChannelSchema = {
  method: "delete";
  url: "/v1/notification-channels/{id}";
};
type DeleteNotificationChannelParameters = paths["/v1/notification-channels/{id}"]["delete"]["parameters"];
type DeleteNotificationChannelData = paths["/v1/notification-channels/{id}"]["delete"]["responses"]["200"]["content"]["application/json"];
type DeleteNotificationChannelError =
  | paths["/v1/notification-channels/{id}"]["delete"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/notification-channels/{id}"]["delete"]["responses"]["401"]["content"]["application/json"]
  | paths["/v1/notification-channels/{id}"]["delete"]["responses"]["403"]["content"]["application/json"]
  | paths["/v1/notification-channels/{id}"]["delete"]["responses"]["404"]["content"]["application/json"]
  | paths["/v1/notification-channels/{id}"]["delete"]["responses"]["500"]["content"]["application/json"];
type DeleteNotificationChannelBody = undefined;
type UpsertDeploymentAlertSchema = {
  method: "post";
  url: "/v1/deployment-alerts/{dseq}";
  mediaType: ["application/json"];
};
type UpsertDeploymentAlertParameters = paths["/v1/deployment-alerts/{dseq}"]["post"]["parameters"];
type UpsertDeploymentAlertData = paths["/v1/deployment-alerts/{dseq}"]["post"]["responses"]["201"]["content"]["application/json"];
type UpsertDeploymentAlertError =
  | paths["/v1/deployment-alerts/{dseq}"]["post"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/deployment-alerts/{dseq}"]["post"]["responses"]["401"]["content"]["application/json"]
  | paths["/v1/deployment-alerts/{dseq}"]["post"]["responses"]["403"]["content"]["application/json"]
  | paths["/v1/deployment-alerts/{dseq}"]["post"]["responses"]["500"]["content"]["application/json"];
type UpsertDeploymentAlertBody = paths["/v1/deployment-alerts/{dseq}"]["post"]["requestBody"]["content"]["application/json"];
type GetDeploymentAlertsSchema = {
  method: "get";
  url: "/v1/deployment-alerts/{dseq}";
};
type GetDeploymentAlertsParameters = paths["/v1/deployment-alerts/{dseq}"]["get"]["parameters"];
type GetDeploymentAlertsData = paths["/v1/deployment-alerts/{dseq}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetDeploymentAlertsError =
  | paths["/v1/deployment-alerts/{dseq}"]["get"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/deployment-alerts/{dseq}"]["get"]["responses"]["401"]["content"]["application/json"]
  | paths["/v1/deployment-alerts/{dseq}"]["get"]["responses"]["403"]["content"]["application/json"]
  | paths["/v1/deployment-alerts/{dseq}"]["get"]["responses"]["500"]["content"]["application/json"];
