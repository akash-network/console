/**
 * This file was auto-generated by @openapi-qraft/cli.
 * Do not make direct changes to the file.
 */

import type {
  DeepReadonly,
  InvalidateQueryFilters,
  MutationFiltersByMutationKey,
  MutationFiltersByParameters,
  MutationVariables,
  OperationInfiniteData,
  PartialParameters,
  QraftServiceOperationsToken,
  QueryFiltersByParameters,
  QueryFiltersByQueryKey,
  QueryFnOptionsByParameters,
  QueryFnOptionsByQueryKey,
  RequestFnResponse,
  ServiceOperationEnsureInfiniteQueryDataOptions,
  ServiceOperationEnsureQueryDataOptions,
  ServiceOperationFetchInfiniteQueryOptions,
  ServiceOperationFetchQueryOptions,
  ServiceOperationInfiniteQueryKey,
  ServiceOperationMutationFnOptions,
  ServiceOperationMutationKey,
  ServiceOperationQueryKey,
  ServiceOperationUseMutationOptions,
  UseQueryOptionsForUseQueries,
  UseQueryOptionsForUseSuspenseQuery,
  WithOptional
} from "@openapi-qraft/tanstack-query-react-types";
import type {
  CancelOptions,
  InfiniteQueryPageParamsOptions,
  InvalidateOptions,
  Mutation,
  MutationState,
  NoInfer,
  QueryState,
  RefetchOptions,
  ResetOptions,
  SetDataOptions,
  Updater
} from "@tanstack/query-core";
import type {
  DefinedInitialDataInfiniteOptions,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  UndefinedInitialDataInfiniteOptions,
  UndefinedInitialDataOptions,
  UseInfiniteQueryResult,
  UseMutationResult,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from "@tanstack/react-query";

import type { paths } from "../schema";
export interface V1Service {
  createAlert: {
    /**/
    getMutationKey(parameters: DeepReadonly<CreateAlertParameters> | void): ServiceOperationMutationKey<CreateAlertSchema, CreateAlertParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createAlert.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createAlert.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends CreateAlertBody, TContext = unknown>(
      parameters: DeepReadonly<CreateAlertParameters>,
      options?: ServiceOperationUseMutationOptions<CreateAlertSchema, CreateAlertData, CreateAlertParameters, TVariables, CreateAlertError | Error, TContext>
    ): UseMutationResult<CreateAlertData, CreateAlertError | Error, TVariables, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createAlert.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createAlert.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<CreateAlertBody, CreateAlertParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<CreateAlertSchema, CreateAlertData, CreateAlertParameters, TVariables, CreateAlertError | Error, TContext>
    ): UseMutationResult<CreateAlertData, CreateAlertError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const createAlertTotal = qraft.v1Service.createAlert.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const createAlertTotal = qraft.v1Service.createAlert.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<CreateAlertBody, CreateAlertData, CreateAlertParameters, CreateAlertError | Error, TContext>
        | MutationFiltersByMutationKey<CreateAlertSchema, CreateAlertBody, CreateAlertData, CreateAlertParameters, CreateAlertError | Error, TContext>
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<CreateAlertBody, CreateAlertData, CreateAlertParameters, CreateAlertError | Error, TContext>
        | MutationFiltersByMutationKey<CreateAlertSchema, CreateAlertBody, CreateAlertData, CreateAlertParameters, CreateAlertError | Error, TContext>
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<CreateAlertBody, CreateAlertParameters>,
      client?: (
        schema: CreateAlertSchema,
        options: ServiceOperationMutationFnOptions<CreateAlertBody, CreateAlertParameters>
      ) => Promise<RequestFnResponse<CreateAlertData, CreateAlertError>>
    ): Promise<RequestFnResponse<CreateAlertData, CreateAlertError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const createAlertPendingMutationVariables = qraft.v1Service.createAlert.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const createAlertMutationData = qraft.v1Service.createAlert.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<CreateAlertData, CreateAlertError | Error, MutationVariables<CreateAlertBody, CreateAlertParameters>, TContext>
    >(options?: {
      filters?:
        | MutationFiltersByParameters<CreateAlertBody, CreateAlertData, CreateAlertParameters, CreateAlertError | Error, TContext>
        | MutationFiltersByMutationKey<CreateAlertSchema, CreateAlertBody, CreateAlertData, CreateAlertParameters, CreateAlertError | Error, TContext>;
      select?: (mutation: Mutation<CreateAlertData, CreateAlertError | Error, MutationVariables<CreateAlertBody, CreateAlertParameters>, TContext>) => TResult;
    }): Array<TResult>;
    schema: CreateAlertSchema;
    types: {
      parameters: CreateAlertParameters;
      data: CreateAlertData;
      error: CreateAlertError;
      body: CreateAlertBody;
    };
  };
  getAlert: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(parameters: DeepReadonly<GetAlertParameters>): ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlert.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAlertData>(
      parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options?: Omit<UndefinedInitialDataOptions<GetAlertData, GetAlertError, TData, ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>>, "queryKey">
    ): UseQueryResult<TData, GetAlertError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlert.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAlertData>(
      parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options: Omit<DefinedInitialDataOptions<GetAlertData, GetAlertError, TData, ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>>, "queryKey">
    ): DefinedUseQueryResult<TData, GetAlertError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetAlertParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<GetAlertSchema, GetAlertData, GetAlertParameters, DeepReadonly<TPageParam>, GetAlertError>
    ): Promise<OperationInfiniteData<GetAlertData, GetAlertParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetAlertParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<GetAlertSchema, GetAlertData, GetAlertParameters, DeepReadonly<TPageParam>, GetAlertError>
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetAlertParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<GetAlertSchema, GetAlertData, GetAlertParameters, DeepReadonly<TPageParam>, GetAlertError>
    ): Promise<OperationInfiniteData<GetAlertData, GetAlertParameters>>;
    /**/
    fetchQuery(options: ServiceOperationFetchQueryOptions<GetAlertSchema, GetAlertData, GetAlertParameters, GetAlertError>): Promise<GetAlertData>;
    /**/
    prefetchQuery(options: ServiceOperationFetchQueryOptions<GetAlertSchema, GetAlertData, GetAlertParameters, GetAlertError>): Promise<void>;
    /**/
    ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetAlertSchema, GetAlertData, GetAlertParameters, GetAlertError>): Promise<GetAlertData>;
    /**/
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>
    ): OperationInfiniteData<GetAlertData, GetAlertParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>,
            data: NoInfer<OperationInfiniteData<GetAlertData, GetAlertParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>, data: GetAlertData | undefined]>;
    /**/
    getQueryData(parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>): GetAlertData | undefined;
    /**/
    getQueryState(
      parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>
    ): QueryState<GetAlertData, GetAlertError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters: DeepReadonly<GetAlertParameters> | ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>
    ): QueryState<OperationInfiniteData<GetAlertData, GetAlertParameters>, GetAlertError> | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options: QueryFnOptionsByQueryKey<GetAlertSchema, GetAlertParameters, TMeta, TSignal> | QueryFnOptionsByParameters<GetAlertParameters, TMeta, TSignal>,
      client?: (
        schema: GetAlertSchema,
        options: {
          parameters: GetAlertParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetAlertData, GetAlertError>>
    ): Promise<RequestFnResponse<GetAlertData, GetAlertError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters: DeepReadonly<GetAlertParameters> | ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetAlertData, GetAlertParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetAlertData, GetAlertParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetAlertData, GetAlertParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>,
      updater: Updater<NoInfer<GetAlertData> | undefined, NoInfer<GetAlertData> | undefined>,
      options?: SetDataOptions
    ): Array<GetAlertData | undefined>;
    /**/
    setQueryData(
      parameters: DeepReadonly<GetAlertParameters> | ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>,
      updater: Updater<NoInfer<GetAlertData> | undefined, NoInfer<DeepReadonly<GetAlertData>> | undefined>,
      options?: SetDataOptions
    ): GetAlertData | undefined;
    /**/
    getInfiniteQueryKey(parameters: DeepReadonly<GetAlertParameters>): ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAlert.useInfiniteQuery({
     *     path: {
     *         id: id
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<TPageParam extends GetAlertParameters, TQueryFnData = GetAlertData, TData = OperationInfiniteData<TQueryFnData, GetAlertParameters>>(
      parameters: ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetAlertError,
          TData,
          ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetAlertError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAlert.useInfiniteQuery({
     *     path: {
     *         id: id
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<TPageParam extends GetAlertParameters, TQueryFnData = GetAlertData, TData = OperationInfiniteData<TQueryFnData, GetAlertParameters>>(
      parameters: ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetAlertError,
          TData,
          ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetAlertData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetAlertError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getAlertTotal = qraft.v1Service.getAlert.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getAlertByParametersTotal = qraft.v1Service.getAlert.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             id: id
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getAlertResults = qraft.v1Service.getAlert.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getAlertResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getAlertCombinedResults = qraft.v1Service.getAlert.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getAlertCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetAlertSchema, GetAlertParameters, GetAlertData, GetAlertError>>,
      TCombinedResult = Array<UseQueryResult<GetAlertData, GetAlertError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetAlertData, GetAlertError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(parameters: DeepReadonly<GetAlertParameters>): ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlert.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAlertData>(
      parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options?: Omit<UndefinedInitialDataOptions<GetAlertData, GetAlertError, TData, ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>>, "queryKey">
    ): UseQueryResult<TData, GetAlertError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getAlert.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAlertData>(
      parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options: Omit<DefinedInitialDataOptions<GetAlertData, GetAlertError, TData, ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>>, "queryKey">
    ): DefinedUseQueryResult<TData, GetAlertError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getAlert.useSuspenseInfiniteQuery({
     *     path: {
     *         id: id
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetAlertParameters, TData = GetAlertData>(
      parameters: ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetAlertData,
          GetAlertError,
          OperationInfiniteData<TData, GetAlertParameters>,
          GetAlertData,
          ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetAlertData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetAlertParameters>, GetAlertError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getAlertData = qraft.v1Service.getAlert.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getAlertResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getAlertCombinedData = qraft.v1Service.getAlert.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getAlertCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetAlertSchema, GetAlertParameters, GetAlertData, GetAlertError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetAlertData, GetAlertError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetAlertData, GetAlertError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getAlert.useSuspenseQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetAlertData>(
      parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options?: Omit<UseSuspenseQueryOptions<GetAlertData, GetAlertError, TData, ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>>, "queryKey">
    ): UseSuspenseQueryResult<TData, GetAlertError | Error>;
    schema: GetAlertSchema;
    types: {
      parameters: GetAlertParameters;
      data: GetAlertData;
      error: GetAlertError;
    };
  };
  patchAlert: {
    /**/
    getMutationKey(parameters: DeepReadonly<PatchAlertParameters> | void): ServiceOperationMutationKey<PatchAlertSchema, PatchAlertParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchAlert.useMutation({
     *     path: {
     *         id: id
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchAlert.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends PatchAlertBody, TContext = unknown>(
      parameters: DeepReadonly<PatchAlertParameters>,
      options?: ServiceOperationUseMutationOptions<PatchAlertSchema, PatchAlertData, PatchAlertParameters, TVariables, PatchAlertError | Error, TContext>
    ): UseMutationResult<PatchAlertData, PatchAlertError | Error, TVariables, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchAlert.useMutation({
     *     path: {
     *         id: id
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchAlert.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PatchAlertBody, PatchAlertParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<PatchAlertSchema, PatchAlertData, PatchAlertParameters, TVariables, PatchAlertError | Error, TContext>
    ): UseMutationResult<PatchAlertData, PatchAlertError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const patchAlertTotal = qraft.v1Service.patchAlert.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const patchAlertTotal = qraft.v1Service.patchAlert.useIsMutating({
     *     parameters: {
     *         path: {
     *             id: id
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<PatchAlertBody, PatchAlertData, PatchAlertParameters, PatchAlertError | Error, TContext>
        | MutationFiltersByMutationKey<PatchAlertSchema, PatchAlertBody, PatchAlertData, PatchAlertParameters, PatchAlertError | Error, TContext>
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<PatchAlertBody, PatchAlertData, PatchAlertParameters, PatchAlertError | Error, TContext>
        | MutationFiltersByMutationKey<PatchAlertSchema, PatchAlertBody, PatchAlertData, PatchAlertParameters, PatchAlertError | Error, TContext>
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<PatchAlertBody, PatchAlertParameters>,
      client?: (
        schema: PatchAlertSchema,
        options: ServiceOperationMutationFnOptions<PatchAlertBody, PatchAlertParameters>
      ) => Promise<RequestFnResponse<PatchAlertData, PatchAlertError>>
    ): Promise<RequestFnResponse<PatchAlertData, PatchAlertError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const patchAlertPendingMutationVariables = qraft.v1Service.patchAlert.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const patchAlertMutationData = qraft.v1Service.patchAlert.useMutationState({
     *     filters: {
     *         parameters: {
     *             path: {
     *                 id: id
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<PatchAlertData, PatchAlertError | Error, MutationVariables<PatchAlertBody, PatchAlertParameters>, TContext>
    >(options?: {
      filters?:
        | MutationFiltersByParameters<PatchAlertBody, PatchAlertData, PatchAlertParameters, PatchAlertError | Error, TContext>
        | MutationFiltersByMutationKey<PatchAlertSchema, PatchAlertBody, PatchAlertData, PatchAlertParameters, PatchAlertError | Error, TContext>;
      select?: (mutation: Mutation<PatchAlertData, PatchAlertError | Error, MutationVariables<PatchAlertBody, PatchAlertParameters>, TContext>) => TResult;
    }): Array<TResult>;
    schema: PatchAlertSchema;
    types: {
      parameters: PatchAlertParameters;
      data: PatchAlertData;
      error: PatchAlertError;
      body: PatchAlertBody;
    };
  };
  deleteAlert: {
    /**/
    getMutationKey(parameters: DeepReadonly<DeleteAlertParameters> | void): ServiceOperationMutationKey<DeleteAlertSchema, DeleteAlertParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteAlert.useMutation({
     *     path: {
     *         id: id
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteAlert.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends DeleteAlertBody, TContext = unknown>(
      parameters: DeepReadonly<DeleteAlertParameters>,
      options?: ServiceOperationUseMutationOptions<DeleteAlertSchema, DeleteAlertData, DeleteAlertParameters, TVariables, DeleteAlertError | Error, TContext>
    ): UseMutationResult<DeleteAlertData, DeleteAlertError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteAlert.useMutation({
     *     path: {
     *         id: id
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteAlert.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<DeleteAlertBody, DeleteAlertParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<DeleteAlertSchema, DeleteAlertData, DeleteAlertParameters, TVariables, DeleteAlertError | Error, TContext>
    ): UseMutationResult<DeleteAlertData, DeleteAlertError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const deleteAlertTotal = qraft.v1Service.deleteAlert.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const deleteAlertTotal = qraft.v1Service.deleteAlert.useIsMutating({
     *     parameters: {
     *         path: {
     *             id: id
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<DeleteAlertBody, DeleteAlertData, DeleteAlertParameters, DeleteAlertError | Error, TContext>
        | MutationFiltersByMutationKey<DeleteAlertSchema, DeleteAlertBody, DeleteAlertData, DeleteAlertParameters, DeleteAlertError | Error, TContext>
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<DeleteAlertBody, DeleteAlertData, DeleteAlertParameters, DeleteAlertError | Error, TContext>
        | MutationFiltersByMutationKey<DeleteAlertSchema, DeleteAlertBody, DeleteAlertData, DeleteAlertParameters, DeleteAlertError | Error, TContext>
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<DeleteAlertBody, DeleteAlertParameters>,
      client?: (
        schema: DeleteAlertSchema,
        options: ServiceOperationMutationFnOptions<DeleteAlertBody, DeleteAlertParameters>
      ) => Promise<RequestFnResponse<DeleteAlertData, DeleteAlertError>>
    ): Promise<RequestFnResponse<DeleteAlertData, DeleteAlertError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const deleteAlertPendingMutationVariables = qraft.v1Service.deleteAlert.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const deleteAlertMutationData = qraft.v1Service.deleteAlert.useMutationState({
     *     filters: {
     *         parameters: {
     *             path: {
     *                 id: id
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<DeleteAlertData, DeleteAlertError | Error, MutationVariables<DeleteAlertBody, DeleteAlertParameters>, TContext>
    >(options?: {
      filters?:
        | MutationFiltersByParameters<DeleteAlertBody, DeleteAlertData, DeleteAlertParameters, DeleteAlertError | Error, TContext>
        | MutationFiltersByMutationKey<DeleteAlertSchema, DeleteAlertBody, DeleteAlertData, DeleteAlertParameters, DeleteAlertError | Error, TContext>;
      select?: (mutation: Mutation<DeleteAlertData, DeleteAlertError | Error, MutationVariables<DeleteAlertBody, DeleteAlertParameters>, TContext>) => TResult;
    }): Array<TResult>;
    schema: DeleteAlertSchema;
    types: {
      parameters: DeleteAlertParameters;
      data: DeleteAlertData;
      error: DeleteAlertError;
      body: DeleteAlertBody;
    };
  };
  createContactPoint: {
    /**/
    getMutationKey(
      parameters: DeepReadonly<CreateContactPointParameters> | void
    ): ServiceOperationMutationKey<CreateContactPointSchema, CreateContactPointParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createContactPoint.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createContactPoint.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends CreateContactPointBody, TContext = unknown>(
      parameters: DeepReadonly<CreateContactPointParameters>,
      options?: ServiceOperationUseMutationOptions<
        CreateContactPointSchema,
        CreateContactPointData,
        CreateContactPointParameters,
        TVariables,
        CreateContactPointError | Error,
        TContext
      >
    ): UseMutationResult<CreateContactPointData, CreateContactPointError | Error, TVariables, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createContactPoint.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.createContactPoint.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<CreateContactPointBody, CreateContactPointParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        CreateContactPointSchema,
        CreateContactPointData,
        CreateContactPointParameters,
        TVariables,
        CreateContactPointError | Error,
        TContext
      >
    ): UseMutationResult<CreateContactPointData, CreateContactPointError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const createContactPointTotal = qraft.v1Service.createContactPoint.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const createContactPointTotal = qraft.v1Service.createContactPoint.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<CreateContactPointBody, CreateContactPointData, CreateContactPointParameters, CreateContactPointError | Error, TContext>
        | MutationFiltersByMutationKey<
            CreateContactPointSchema,
            CreateContactPointBody,
            CreateContactPointData,
            CreateContactPointParameters,
            CreateContactPointError | Error,
            TContext
          >
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<CreateContactPointBody, CreateContactPointData, CreateContactPointParameters, CreateContactPointError | Error, TContext>
        | MutationFiltersByMutationKey<
            CreateContactPointSchema,
            CreateContactPointBody,
            CreateContactPointData,
            CreateContactPointParameters,
            CreateContactPointError | Error,
            TContext
          >
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<CreateContactPointBody, CreateContactPointParameters>,
      client?: (
        schema: CreateContactPointSchema,
        options: ServiceOperationMutationFnOptions<CreateContactPointBody, CreateContactPointParameters>
      ) => Promise<RequestFnResponse<CreateContactPointData, CreateContactPointError>>
    ): Promise<RequestFnResponse<CreateContactPointData, CreateContactPointError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const createContactPointPendingMutationVariables = qraft.v1Service.createContactPoint.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const createContactPointMutationData = qraft.v1Service.createContactPoint.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        CreateContactPointData,
        CreateContactPointError | Error,
        MutationVariables<CreateContactPointBody, CreateContactPointParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<CreateContactPointBody, CreateContactPointData, CreateContactPointParameters, CreateContactPointError | Error, TContext>
        | MutationFiltersByMutationKey<
            CreateContactPointSchema,
            CreateContactPointBody,
            CreateContactPointData,
            CreateContactPointParameters,
            CreateContactPointError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          CreateContactPointData,
          CreateContactPointError | Error,
          MutationVariables<CreateContactPointBody, CreateContactPointParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: CreateContactPointSchema;
    types: {
      parameters: CreateContactPointParameters;
      data: CreateContactPointData;
      error: CreateContactPointError;
      body: CreateContactPointBody;
    };
  };
  getContactPoint: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>
        | QueryFiltersByQueryKey<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(parameters: DeepReadonly<GetContactPointParameters>): ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getContactPoint.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetContactPointData>(
      parameters: ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters> | DeepReadonly<GetContactPointParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetContactPointData,
          GetContactPointError,
          TData,
          ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetContactPointError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getContactPoint.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetContactPointData>(
      parameters: ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters> | DeepReadonly<GetContactPointParameters>,
      options: Omit<
        DefinedInitialDataOptions<GetContactPointData, GetContactPointError, TData, ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetContactPointError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetContactPointParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetContactPointSchema,
        GetContactPointData,
        GetContactPointParameters,
        DeepReadonly<TPageParam>,
        GetContactPointError
      >
    ): Promise<OperationInfiniteData<GetContactPointData, GetContactPointParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetContactPointParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<
        GetContactPointSchema,
        GetContactPointData,
        GetContactPointParameters,
        DeepReadonly<TPageParam>,
        GetContactPointError
      >
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetContactPointParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<
        GetContactPointSchema,
        GetContactPointData,
        GetContactPointParameters,
        DeepReadonly<TPageParam>,
        GetContactPointError
      >
    ): Promise<OperationInfiniteData<GetContactPointData, GetContactPointParameters>>;
    /**/
    fetchQuery(
      options: ServiceOperationFetchQueryOptions<GetContactPointSchema, GetContactPointData, GetContactPointParameters, GetContactPointError>
    ): Promise<GetContactPointData>;
    /**/
    prefetchQuery(
      options: ServiceOperationFetchQueryOptions<GetContactPointSchema, GetContactPointData, GetContactPointParameters, GetContactPointError>
    ): Promise<void>;
    /**/
    ensureQueryData(
      options: ServiceOperationEnsureQueryDataOptions<GetContactPointSchema, GetContactPointData, GetContactPointParameters, GetContactPointError>
    ): Promise<GetContactPointData>;
    /**/
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetContactPointSchema, GetContactPointParameters> | DeepReadonly<GetContactPointParameters>
    ): OperationInfiniteData<GetContactPointData, GetContactPointParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>
        | QueryFiltersByQueryKey<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetContactPointSchema, GetContactPointParameters>,
            data: NoInfer<OperationInfiniteData<GetContactPointData, GetContactPointParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters>, data: GetContactPointData | undefined]>;
    /**/
    getQueryData(
      parameters: ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters> | DeepReadonly<GetContactPointParameters>
    ): GetContactPointData | undefined;
    /**/
    getQueryState(
      parameters: ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters> | DeepReadonly<GetContactPointParameters>
    ): QueryState<GetContactPointData, GetContactPointError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters: DeepReadonly<GetContactPointParameters> | ServiceOperationInfiniteQueryKey<GetContactPointSchema, GetContactPointParameters>
    ): QueryState<OperationInfiniteData<GetContactPointData, GetContactPointParameters>, GetContactPointError> | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>
        | QueryFiltersByQueryKey<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options:
        | QueryFnOptionsByQueryKey<GetContactPointSchema, GetContactPointParameters, TMeta, TSignal>
        | QueryFnOptionsByParameters<GetContactPointParameters, TMeta, TSignal>,
      client?: (
        schema: GetContactPointSchema,
        options: {
          parameters: GetContactPointParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetContactPointData, GetContactPointError>>
    ): Promise<RequestFnResponse<GetContactPointData, GetContactPointError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>
        | QueryFiltersByQueryKey<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>
        | QueryFiltersByQueryKey<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>
        | QueryFiltersByQueryKey<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters: DeepReadonly<GetContactPointParameters> | ServiceOperationInfiniteQueryKey<GetContactPointSchema, GetContactPointParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetContactPointData, GetContactPointParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetContactPointData, GetContactPointParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetContactPointData, GetContactPointParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>
        | QueryFiltersByQueryKey<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>,
      updater: Updater<NoInfer<GetContactPointData> | undefined, NoInfer<GetContactPointData> | undefined>,
      options?: SetDataOptions
    ): Array<GetContactPointData | undefined>;
    /**/
    setQueryData(
      parameters: DeepReadonly<GetContactPointParameters> | ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters>,
      updater: Updater<NoInfer<GetContactPointData> | undefined, NoInfer<DeepReadonly<GetContactPointData>> | undefined>,
      options?: SetDataOptions
    ): GetContactPointData | undefined;
    /**/
    getInfiniteQueryKey(
      parameters: DeepReadonly<GetContactPointParameters>
    ): ServiceOperationInfiniteQueryKey<GetContactPointSchema, GetContactPointParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getContactPoint.useInfiniteQuery({
     *     path: {
     *         id: id
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetContactPointParameters,
      TQueryFnData = GetContactPointData,
      TData = OperationInfiniteData<TQueryFnData, GetContactPointParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetContactPointSchema, GetContactPointParameters> | DeepReadonly<GetContactPointParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetContactPointError,
          TData,
          ServiceOperationInfiniteQueryKey<GetContactPointSchema, GetContactPointParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetContactPointError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getContactPoint.useInfiniteQuery({
     *     path: {
     *         id: id
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<
      TPageParam extends GetContactPointParameters,
      TQueryFnData = GetContactPointData,
      TData = OperationInfiniteData<TQueryFnData, GetContactPointParameters>
    >(
      parameters: ServiceOperationInfiniteQueryKey<GetContactPointSchema, GetContactPointParameters> | DeepReadonly<GetContactPointParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetContactPointError,
          TData,
          ServiceOperationInfiniteQueryKey<GetContactPointSchema, GetContactPointParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetContactPointData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetContactPointError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getContactPointTotal = qraft.v1Service.getContactPoint.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getContactPointByParametersTotal = qraft.v1Service.getContactPoint.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             id: id
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>
        | QueryFiltersByQueryKey<GetContactPointSchema, GetContactPointData, TInfinite, GetContactPointParameters, GetContactPointError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getContactPointResults = qraft.v1Service.getContactPoint.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getContactPointResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getContactPointCombinedResults = qraft.v1Service.getContactPoint.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getContactPointCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetContactPointSchema, GetContactPointParameters, GetContactPointData, GetContactPointError>>,
      TCombinedResult = Array<UseQueryResult<GetContactPointData, GetContactPointError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetContactPointData, GetContactPointError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(parameters: DeepReadonly<GetContactPointParameters>): ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getContactPoint.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetContactPointData>(
      parameters: ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters> | DeepReadonly<GetContactPointParameters>,
      options?: Omit<
        UndefinedInitialDataOptions<
          GetContactPointData,
          GetContactPointError,
          TData,
          ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters>
        >,
        "queryKey"
      >
    ): UseQueryResult<TData, GetContactPointError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.v1Service.getContactPoint.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetContactPointData>(
      parameters: ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters> | DeepReadonly<GetContactPointParameters>,
      options: Omit<
        DefinedInitialDataOptions<GetContactPointData, GetContactPointError, TData, ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters>>,
        "queryKey"
      >
    ): DefinedUseQueryResult<TData, GetContactPointError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.v1Service.getContactPoint.useSuspenseInfiniteQuery({
     *     path: {
     *         id: id
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetContactPointParameters, TData = GetContactPointData>(
      parameters: ServiceOperationInfiniteQueryKey<GetContactPointSchema, GetContactPointParameters> | DeepReadonly<GetContactPointParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetContactPointData,
          GetContactPointError,
          OperationInfiniteData<TData, GetContactPointParameters>,
          GetContactPointData,
          ServiceOperationInfiniteQueryKey<GetContactPointSchema, GetContactPointParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetContactPointData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetContactPointParameters>, GetContactPointError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getContactPointData = qraft.v1Service.getContactPoint.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getContactPointResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getContactPointCombinedData = qraft.v1Service.getContactPoint.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getContactPointCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetContactPointSchema, GetContactPointParameters, GetContactPointData, GetContactPointError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetContactPointData, GetContactPointError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetContactPointData, GetContactPointError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.v1Service.getContactPoint.useSuspenseQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetContactPointData>(
      parameters: ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters> | DeepReadonly<GetContactPointParameters>,
      options?: Omit<
        UseSuspenseQueryOptions<GetContactPointData, GetContactPointError, TData, ServiceOperationQueryKey<GetContactPointSchema, GetContactPointParameters>>,
        "queryKey"
      >
    ): UseSuspenseQueryResult<TData, GetContactPointError | Error>;
    schema: GetContactPointSchema;
    types: {
      parameters: GetContactPointParameters;
      data: GetContactPointData;
      error: GetContactPointError;
    };
  };
  patchContactPoint: {
    /**/
    getMutationKey(
      parameters: DeepReadonly<PatchContactPointParameters> | void
    ): ServiceOperationMutationKey<PatchContactPointSchema, PatchContactPointParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchContactPoint.useMutation({
     *     path: {
     *         id: id
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchContactPoint.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends PatchContactPointBody, TContext = unknown>(
      parameters: DeepReadonly<PatchContactPointParameters>,
      options?: ServiceOperationUseMutationOptions<
        PatchContactPointSchema,
        PatchContactPointData,
        PatchContactPointParameters,
        TVariables,
        PatchContactPointError | Error,
        TContext
      >
    ): UseMutationResult<PatchContactPointData, PatchContactPointError | Error, TVariables, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchContactPoint.useMutation({
     *     path: {
     *         id: id
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.patchContactPoint.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PatchContactPointBody, PatchContactPointParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        PatchContactPointSchema,
        PatchContactPointData,
        PatchContactPointParameters,
        TVariables,
        PatchContactPointError | Error,
        TContext
      >
    ): UseMutationResult<PatchContactPointData, PatchContactPointError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const patchContactPointTotal = qraft.v1Service.patchContactPoint.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const patchContactPointTotal = qraft.v1Service.patchContactPoint.useIsMutating({
     *     parameters: {
     *         path: {
     *             id: id
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<PatchContactPointBody, PatchContactPointData, PatchContactPointParameters, PatchContactPointError | Error, TContext>
        | MutationFiltersByMutationKey<
            PatchContactPointSchema,
            PatchContactPointBody,
            PatchContactPointData,
            PatchContactPointParameters,
            PatchContactPointError | Error,
            TContext
          >
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<PatchContactPointBody, PatchContactPointData, PatchContactPointParameters, PatchContactPointError | Error, TContext>
        | MutationFiltersByMutationKey<
            PatchContactPointSchema,
            PatchContactPointBody,
            PatchContactPointData,
            PatchContactPointParameters,
            PatchContactPointError | Error,
            TContext
          >
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<PatchContactPointBody, PatchContactPointParameters>,
      client?: (
        schema: PatchContactPointSchema,
        options: ServiceOperationMutationFnOptions<PatchContactPointBody, PatchContactPointParameters>
      ) => Promise<RequestFnResponse<PatchContactPointData, PatchContactPointError>>
    ): Promise<RequestFnResponse<PatchContactPointData, PatchContactPointError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const patchContactPointPendingMutationVariables = qraft.v1Service.patchContactPoint.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const patchContactPointMutationData = qraft.v1Service.patchContactPoint.useMutationState({
     *     filters: {
     *         parameters: {
     *             path: {
     *                 id: id
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        PatchContactPointData,
        PatchContactPointError | Error,
        MutationVariables<PatchContactPointBody, PatchContactPointParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<PatchContactPointBody, PatchContactPointData, PatchContactPointParameters, PatchContactPointError | Error, TContext>
        | MutationFiltersByMutationKey<
            PatchContactPointSchema,
            PatchContactPointBody,
            PatchContactPointData,
            PatchContactPointParameters,
            PatchContactPointError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          PatchContactPointData,
          PatchContactPointError | Error,
          MutationVariables<PatchContactPointBody, PatchContactPointParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: PatchContactPointSchema;
    types: {
      parameters: PatchContactPointParameters;
      data: PatchContactPointData;
      error: PatchContactPointError;
      body: PatchContactPointBody;
    };
  };
  deleteContactPoint: {
    /**/
    getMutationKey(
      parameters: DeepReadonly<DeleteContactPointParameters> | void
    ): ServiceOperationMutationKey<DeleteContactPointSchema, DeleteContactPointParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteContactPoint.useMutation({
     *     path: {
     *         id: id
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteContactPoint.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends DeleteContactPointBody, TContext = unknown>(
      parameters: DeepReadonly<DeleteContactPointParameters>,
      options?: ServiceOperationUseMutationOptions<
        DeleteContactPointSchema,
        DeleteContactPointData,
        DeleteContactPointParameters,
        TVariables,
        DeleteContactPointError | Error,
        TContext
      >
    ): UseMutationResult<DeleteContactPointData, DeleteContactPointError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteContactPoint.useMutation({
     *     path: {
     *         id: id
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.v1Service.deleteContactPoint.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<DeleteContactPointBody, DeleteContactPointParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<
        DeleteContactPointSchema,
        DeleteContactPointData,
        DeleteContactPointParameters,
        TVariables,
        DeleteContactPointError | Error,
        TContext
      >
    ): UseMutationResult<DeleteContactPointData, DeleteContactPointError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const deleteContactPointTotal = qraft.v1Service.deleteContactPoint.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const deleteContactPointTotal = qraft.v1Service.deleteContactPoint.useIsMutating({
     *     parameters: {
     *         path: {
     *             id: id
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<DeleteContactPointBody, DeleteContactPointData, DeleteContactPointParameters, DeleteContactPointError | Error, TContext>
        | MutationFiltersByMutationKey<
            DeleteContactPointSchema,
            DeleteContactPointBody,
            DeleteContactPointData,
            DeleteContactPointParameters,
            DeleteContactPointError | Error,
            TContext
          >
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<DeleteContactPointBody, DeleteContactPointData, DeleteContactPointParameters, DeleteContactPointError | Error, TContext>
        | MutationFiltersByMutationKey<
            DeleteContactPointSchema,
            DeleteContactPointBody,
            DeleteContactPointData,
            DeleteContactPointParameters,
            DeleteContactPointError | Error,
            TContext
          >
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<DeleteContactPointBody, DeleteContactPointParameters>,
      client?: (
        schema: DeleteContactPointSchema,
        options: ServiceOperationMutationFnOptions<DeleteContactPointBody, DeleteContactPointParameters>
      ) => Promise<RequestFnResponse<DeleteContactPointData, DeleteContactPointError>>
    ): Promise<RequestFnResponse<DeleteContactPointData, DeleteContactPointError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const deleteContactPointPendingMutationVariables = qraft.v1Service.deleteContactPoint.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const deleteContactPointMutationData = qraft.v1Service.deleteContactPoint.useMutationState({
     *     filters: {
     *         parameters: {
     *             path: {
     *                 id: id
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<
        DeleteContactPointData,
        DeleteContactPointError | Error,
        MutationVariables<DeleteContactPointBody, DeleteContactPointParameters>,
        TContext
      >
    >(options?: {
      filters?:
        | MutationFiltersByParameters<DeleteContactPointBody, DeleteContactPointData, DeleteContactPointParameters, DeleteContactPointError | Error, TContext>
        | MutationFiltersByMutationKey<
            DeleteContactPointSchema,
            DeleteContactPointBody,
            DeleteContactPointData,
            DeleteContactPointParameters,
            DeleteContactPointError | Error,
            TContext
          >;
      select?: (
        mutation: Mutation<
          DeleteContactPointData,
          DeleteContactPointError | Error,
          MutationVariables<DeleteContactPointBody, DeleteContactPointParameters>,
          TContext
        >
      ) => TResult;
    }): Array<TResult>;
    schema: DeleteContactPointSchema;
    types: {
      parameters: DeleteContactPointParameters;
      data: DeleteContactPointData;
      error: DeleteContactPointError;
      body: DeleteContactPointBody;
    };
  };
}
export const createAlert = {
  schema: {
    method: "post",
    url: "/v1/alerts",
    mediaType: ["application/json"]
  }
} as {
  schema: CreateAlertSchema;
  [QraftServiceOperationsToken]: V1Service["createAlert"];
};
export const getAlert = {
  schema: {
    method: "get",
    url: "/v1/alerts/{id}"
  }
} as {
  schema: GetAlertSchema;
  [QraftServiceOperationsToken]: V1Service["getAlert"];
};
export const patchAlert = {
  schema: {
    method: "patch",
    url: "/v1/alerts/{id}",
    mediaType: ["application/json"]
  }
} as {
  schema: PatchAlertSchema;
  [QraftServiceOperationsToken]: V1Service["patchAlert"];
};
export const deleteAlert = {
  schema: {
    method: "delete",
    url: "/v1/alerts/{id}"
  }
} as {
  schema: DeleteAlertSchema;
  [QraftServiceOperationsToken]: V1Service["deleteAlert"];
};
export const createContactPoint = {
  schema: {
    method: "post",
    url: "/v1/contact-points",
    mediaType: ["application/json"]
  }
} as {
  schema: CreateContactPointSchema;
  [QraftServiceOperationsToken]: V1Service["createContactPoint"];
};
export const getContactPoint = {
  schema: {
    method: "get",
    url: "/v1/contact-points/{id}"
  }
} as {
  schema: GetContactPointSchema;
  [QraftServiceOperationsToken]: V1Service["getContactPoint"];
};
export const patchContactPoint = {
  schema: {
    method: "patch",
    url: "/v1/contact-points/{id}",
    mediaType: ["application/json"]
  }
} as {
  schema: PatchContactPointSchema;
  [QraftServiceOperationsToken]: V1Service["patchContactPoint"];
};
export const deleteContactPoint = {
  schema: {
    method: "delete",
    url: "/v1/contact-points/{id}"
  }
} as {
  schema: DeleteContactPointSchema;
  [QraftServiceOperationsToken]: V1Service["deleteContactPoint"];
};
export const v1Service = {
  createAlert,
  getAlert,
  patchAlert,
  deleteAlert,
  createContactPoint,
  getContactPoint,
  patchContactPoint,
  deleteContactPoint
} as const;
type CreateAlertSchema = {
  method: "post";
  url: "/v1/alerts";
  mediaType: ["application/json"];
};
type CreateAlertParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type CreateAlertData = paths["/v1/alerts"]["post"]["responses"]["201"]["content"]["application/json"];
type CreateAlertError =
  | paths["/v1/alerts"]["post"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/alerts"]["post"]["responses"]["500"]["content"]["application/json"];
type CreateAlertBody = paths["/v1/alerts"]["post"]["requestBody"]["content"]["application/json"];
type GetAlertSchema = {
  method: "get";
  url: "/v1/alerts/{id}";
};
type GetAlertParameters = paths["/v1/alerts/{id}"]["get"]["parameters"];
type GetAlertData = paths["/v1/alerts/{id}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetAlertError =
  | paths["/v1/alerts/{id}"]["get"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/alerts/{id}"]["get"]["responses"]["500"]["content"]["application/json"];
type PatchAlertSchema = {
  method: "patch";
  url: "/v1/alerts/{id}";
  mediaType: ["application/json"];
};
type PatchAlertParameters = paths["/v1/alerts/{id}"]["patch"]["parameters"];
type PatchAlertData = paths["/v1/alerts/{id}"]["patch"]["responses"]["200"]["content"]["application/json"];
type PatchAlertError =
  | paths["/v1/alerts/{id}"]["patch"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/alerts/{id}"]["patch"]["responses"]["500"]["content"]["application/json"];
type PatchAlertBody = paths["/v1/alerts/{id}"]["patch"]["requestBody"]["content"]["application/json"];
type DeleteAlertSchema = {
  method: "delete";
  url: "/v1/alerts/{id}";
};
type DeleteAlertParameters = paths["/v1/alerts/{id}"]["delete"]["parameters"];
type DeleteAlertData = paths["/v1/alerts/{id}"]["delete"]["responses"]["200"]["content"]["application/json"];
type DeleteAlertError =
  | paths["/v1/alerts/{id}"]["delete"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/alerts/{id}"]["delete"]["responses"]["500"]["content"]["application/json"];
type DeleteAlertBody = undefined;
type CreateContactPointSchema = {
  method: "post";
  url: "/v1/contact-points";
  mediaType: ["application/json"];
};
type CreateContactPointParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type CreateContactPointData = paths["/v1/contact-points"]["post"]["responses"]["201"]["content"]["application/json"];
type CreateContactPointError =
  | paths["/v1/contact-points"]["post"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/contact-points"]["post"]["responses"]["500"]["content"]["application/json"];
type CreateContactPointBody = paths["/v1/contact-points"]["post"]["requestBody"]["content"]["application/json"];
type GetContactPointSchema = {
  method: "get";
  url: "/v1/contact-points/{id}";
};
type GetContactPointParameters = paths["/v1/contact-points/{id}"]["get"]["parameters"];
type GetContactPointData = paths["/v1/contact-points/{id}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetContactPointError =
  | paths["/v1/contact-points/{id}"]["get"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/contact-points/{id}"]["get"]["responses"]["404"]["content"]["application/json"]
  | paths["/v1/contact-points/{id}"]["get"]["responses"]["500"]["content"]["application/json"];
type PatchContactPointSchema = {
  method: "patch";
  url: "/v1/contact-points/{id}";
  mediaType: ["application/json"];
};
type PatchContactPointParameters = paths["/v1/contact-points/{id}"]["patch"]["parameters"];
type PatchContactPointData = paths["/v1/contact-points/{id}"]["patch"]["responses"]["200"]["content"]["application/json"];
type PatchContactPointError =
  | paths["/v1/contact-points/{id}"]["patch"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/contact-points/{id}"]["patch"]["responses"]["404"]["content"]["application/json"]
  | paths["/v1/contact-points/{id}"]["patch"]["responses"]["500"]["content"]["application/json"];
type PatchContactPointBody = paths["/v1/contact-points/{id}"]["patch"]["requestBody"]["content"]["application/json"];
type DeleteContactPointSchema = {
  method: "delete";
  url: "/v1/contact-points/{id}";
};
type DeleteContactPointParameters = paths["/v1/contact-points/{id}"]["delete"]["parameters"];
type DeleteContactPointData = paths["/v1/contact-points/{id}"]["delete"]["responses"]["200"]["content"]["application/json"];
type DeleteContactPointError =
  | paths["/v1/contact-points/{id}"]["delete"]["responses"]["400"]["content"]["application/json"]
  | paths["/v1/contact-points/{id}"]["delete"]["responses"]["404"]["content"]["application/json"]
  | paths["/v1/contact-points/{id}"]["delete"]["responses"]["500"]["content"]["application/json"];
type DeleteContactPointBody = undefined;
