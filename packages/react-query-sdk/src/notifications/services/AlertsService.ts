/**
 * This file was auto-generated by @openapi-qraft/cli.
 * Do not make direct changes to the file.
 */

import type {
  DeepReadonly,
  InvalidateQueryFilters,
  MutationFiltersByMutationKey,
  MutationFiltersByParameters,
  MutationVariables,
  OperationInfiniteData,
  PartialParameters,
  QueryFiltersByParameters,
  QueryFiltersByQueryKey,
  QueryFnOptionsByParameters,
  QueryFnOptionsByQueryKey,
  RequestFnResponse,
  ServiceOperationEnsureInfiniteQueryDataOptions,
  ServiceOperationEnsureQueryDataOptions,
  ServiceOperationFetchInfiniteQueryOptions,
  ServiceOperationFetchQueryOptions,
  ServiceOperationInfiniteQueryKey,
  ServiceOperationMutationFnOptions,
  ServiceOperationMutationKey,
  ServiceOperationQueryKey,
  ServiceOperationUseMutationOptions,
  UseQueryOptionsForUseQueries,
  UseQueryOptionsForUseSuspenseQuery,
  WithOptional
} from "@openapi-qraft/tanstack-query-react-types";
import type {
  CancelOptions,
  InfiniteQueryPageParamsOptions,
  InvalidateOptions,
  Mutation,
  MutationState,
  NoInfer,
  QueryState,
  RefetchOptions,
  ResetOptions,
  SetDataOptions,
  Updater
} from "@tanstack/query-core";
import type {
  DefinedInitialDataInfiniteOptions,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  UndefinedInitialDataInfiniteOptions,
  UndefinedInitialDataOptions,
  UseInfiniteQueryResult,
  UseMutationResult,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from "@tanstack/react-query";

import type { paths } from "../schema";
export interface AlertsService {
  createAlert: {
    /**/
    getMutationKey(parameters: DeepReadonly<CreateAlertParameters> | void): ServiceOperationMutationKey<CreateAlertSchema, CreateAlertParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.alertsService.createAlert.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.alertsService.createAlert.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends CreateAlertBody, TContext = unknown>(
      parameters: DeepReadonly<CreateAlertParameters>,
      options?: ServiceOperationUseMutationOptions<CreateAlertSchema, CreateAlertData, CreateAlertParameters, TVariables, CreateAlertError | Error, TContext>
    ): UseMutationResult<CreateAlertData, CreateAlertError | Error, TVariables, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.alertsService.createAlert.useMutation({})
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.alertsService.createAlert.useMutation()
     * mutate({
     *     body: bodyPayload
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<CreateAlertBody, CreateAlertParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<CreateAlertSchema, CreateAlertData, CreateAlertParameters, TVariables, CreateAlertError | Error, TContext>
    ): UseMutationResult<CreateAlertData, CreateAlertError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const createAlertTotal = qraft.alertsService.createAlert.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const createAlertTotal = qraft.alertsService.createAlert.useIsMutating({
     *     parameters: {}
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<CreateAlertBody, CreateAlertData, CreateAlertParameters, CreateAlertError | Error, TContext>
        | MutationFiltersByMutationKey<CreateAlertSchema, CreateAlertBody, CreateAlertData, CreateAlertParameters, CreateAlertError | Error, TContext>
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<CreateAlertBody, CreateAlertData, CreateAlertParameters, CreateAlertError | Error, TContext>
        | MutationFiltersByMutationKey<CreateAlertSchema, CreateAlertBody, CreateAlertData, CreateAlertParameters, CreateAlertError | Error, TContext>
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<CreateAlertBody, CreateAlertParameters>,
      client?: (
        schema: CreateAlertSchema,
        options: ServiceOperationMutationFnOptions<CreateAlertBody, CreateAlertParameters>
      ) => Promise<RequestFnResponse<CreateAlertData, CreateAlertError>>
    ): Promise<RequestFnResponse<CreateAlertData, CreateAlertError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const createAlertPendingMutationVariables = qraft.alertsService.createAlert.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const createAlertMutationData = qraft.alertsService.createAlert.useMutationState({
     *     filters: {
     *         parameters: {}
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<CreateAlertData, CreateAlertError | Error, MutationVariables<CreateAlertBody, CreateAlertParameters>, TContext>
    >(options?: {
      filters?:
        | MutationFiltersByParameters<CreateAlertBody, CreateAlertData, CreateAlertParameters, CreateAlertError | Error, TContext>
        | MutationFiltersByMutationKey<CreateAlertSchema, CreateAlertBody, CreateAlertData, CreateAlertParameters, CreateAlertError | Error, TContext>;
      select?: (mutation: Mutation<CreateAlertData, CreateAlertError | Error, MutationVariables<CreateAlertBody, CreateAlertParameters>, TContext>) => TResult;
    }): Array<TResult>;
    schema: CreateAlertSchema;
    types: {
      parameters: CreateAlertParameters;
      data: CreateAlertData;
      error: CreateAlertError;
      body: CreateAlertBody;
    };
  };
  getAlert: {
    /**/
    cancelQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>,
      options?: CancelOptions
    ): Promise<void>;
    /**/
    getQueryKey(parameters: DeepReadonly<GetAlertParameters>): ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.alertsService.getAlert.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAlertData>(
      parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options?: Omit<UndefinedInitialDataOptions<GetAlertData, GetAlertError, TData, ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>>, "queryKey">
    ): UseQueryResult<TData, GetAlertError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.alertsService.getAlert.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAlertData>(
      parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options: Omit<DefinedInitialDataOptions<GetAlertData, GetAlertError, TData, ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>>, "queryKey">
    ): DefinedUseQueryResult<TData, GetAlertError | Error>;
    /**/
    fetchInfiniteQuery<TPageParam extends GetAlertParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<GetAlertSchema, GetAlertData, GetAlertParameters, DeepReadonly<TPageParam>, GetAlertError>
    ): Promise<OperationInfiniteData<GetAlertData, GetAlertParameters>>;
    /**/
    prefetchInfiniteQuery<TPageParam extends GetAlertParameters>(
      options: ServiceOperationFetchInfiniteQueryOptions<GetAlertSchema, GetAlertData, GetAlertParameters, DeepReadonly<TPageParam>, GetAlertError>
    ): Promise<void>;
    /**/
    ensureInfiniteQueryData<TPageParam extends GetAlertParameters>(
      options: ServiceOperationEnsureInfiniteQueryDataOptions<GetAlertSchema, GetAlertData, GetAlertParameters, DeepReadonly<TPageParam>, GetAlertError>
    ): Promise<OperationInfiniteData<GetAlertData, GetAlertParameters>>;
    /**/
    fetchQuery(options: ServiceOperationFetchQueryOptions<GetAlertSchema, GetAlertData, GetAlertParameters, GetAlertError>): Promise<GetAlertData>;
    /**/
    prefetchQuery(options: ServiceOperationFetchQueryOptions<GetAlertSchema, GetAlertData, GetAlertParameters, GetAlertError>): Promise<void>;
    /**/
    ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetAlertSchema, GetAlertData, GetAlertParameters, GetAlertError>): Promise<GetAlertData>;
    /**/
    getInfiniteQueryData(
      parameters: ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>
    ): OperationInfiniteData<GetAlertData, GetAlertParameters> | undefined;
    /**/
    getQueriesData<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
    ): TInfinite extends true
      ? Array<
          [
            queryKey: ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>,
            data: NoInfer<OperationInfiniteData<GetAlertData, GetAlertParameters>> | undefined
          ]
        >
      : Array<[queryKey: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>, data: GetAlertData | undefined]>;
    /**/
    getQueryData(parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>): GetAlertData | undefined;
    /**/
    getQueryState(
      parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>
    ): QueryState<GetAlertData, GetAlertError> | undefined;
    /**/
    getInfiniteQueryState(
      parameters: DeepReadonly<GetAlertParameters> | ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>
    ): QueryState<OperationInfiniteData<GetAlertData, GetAlertParameters>, GetAlertError> | undefined;
    /**/
    invalidateQueries<TInfinite extends boolean = false>(
      filters?: InvalidateQueryFilters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>,
      options?: InvalidateOptions
    ): Promise<void>;
    /**/
    isFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
    ): number;
    /**/
    <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(
      options: QueryFnOptionsByQueryKey<GetAlertSchema, GetAlertParameters, TMeta, TSignal> | QueryFnOptionsByParameters<GetAlertParameters, TMeta, TSignal>,
      client?: (
        schema: GetAlertSchema,
        options: {
          parameters: GetAlertParameters;
          signal?: TSignal;
          meta?: TMeta;
        }
      ) => Promise<RequestFnResponse<GetAlertData, GetAlertError>>
    ): Promise<RequestFnResponse<GetAlertData, GetAlertError>>;
    /**/
    refetchQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>,
      options?: RefetchOptions
    ): Promise<void>;
    /**/
    removeQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
    ): void;
    /**/
    resetQueries<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>,
      options?: ResetOptions
    ): Promise<void>;
    /**/
    setInfiniteQueryData(
      parameters: DeepReadonly<GetAlertParameters> | ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>,
      updater: Updater<
        NoInfer<OperationInfiniteData<GetAlertData, GetAlertParameters>> | undefined,
        NoInfer<DeepReadonly<OperationInfiniteData<GetAlertData, GetAlertParameters>>> | undefined
      >,
      options?: SetDataOptions
    ): OperationInfiniteData<GetAlertData, GetAlertParameters> | undefined;
    /**/
    setQueriesData<TInfinite extends boolean = false>(
      filters:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>,
      updater: Updater<NoInfer<GetAlertData> | undefined, NoInfer<GetAlertData> | undefined>,
      options?: SetDataOptions
    ): Array<GetAlertData | undefined>;
    /**/
    setQueryData(
      parameters: DeepReadonly<GetAlertParameters> | ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>,
      updater: Updater<NoInfer<GetAlertData> | undefined, NoInfer<DeepReadonly<GetAlertData>> | undefined>,
      options?: SetDataOptions
    ): GetAlertData | undefined;
    /**/
    getInfiniteQueryKey(parameters: DeepReadonly<GetAlertParameters>): ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.alertsService.getAlert.useInfiniteQuery({
     *     path: {
     *         id: id
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<TPageParam extends GetAlertParameters, TQueryFnData = GetAlertData, TData = OperationInfiniteData<TQueryFnData, GetAlertParameters>>(
      parameters: ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options: Omit<
        UndefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetAlertError,
          TData,
          ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseInfiniteQueryResult<TData, GetAlertError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
     *
     * @example Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.alertsService.getAlert.useInfiniteQuery({
     *     path: {
     *         id: id
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useInfiniteQuery<TPageParam extends GetAlertParameters, TQueryFnData = GetAlertData, TData = OperationInfiniteData<TQueryFnData, GetAlertParameters>>(
      parameters: ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options: Omit<
        DefinedInitialDataInfiniteOptions<
          TQueryFnData,
          GetAlertError,
          TData,
          ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetAlertData, PartialParameters<DeepReadonly<TPageParam>>>
    ): DefinedUseInfiniteQueryResult<TData, GetAlertError | Error>;
    /**
     * Monitors the number of queries currently fetching, matching the provided filters.
     * Useful for creating loading indicators or performing actions based on active requests.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
     * @example Checks the total number of queries fetching from the specified service method,
     * both normal and infinite. If no parameters are provided, no filtering is applied.
     * ```ts
     * const getAlertTotal = qraft.alertsService.getAlert.useIsFetching()
     * ```
     * @example Checks the number of normal queries fetching with the specified parameters.
     * ```ts
     * const getAlertByParametersTotal = qraft.alertsService.getAlert.useIsFetching({
     *     infinite: false,
     *     parameters: {
     *         path: {
     *             id: id
     *         }
     *     }
     * })
     * ```
     */
    useIsFetching<TInfinite extends boolean = false>(
      filters?:
        | QueryFiltersByParameters<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
        | QueryFiltersByQueryKey<GetAlertSchema, GetAlertData, TInfinite, GetAlertParameters, GetAlertError>
    ): number;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
     * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
     * ```ts
     * const getAlertResults = qraft.alertsService.getAlert.useQueries({
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getAlertResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example Combined results. Only the data will be returned.
     * ```ts
     * const getAlertCombinedResults = qraft.alertsService.getAlert.useQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getAlertCombinedResults.forEach(data => console.log({ data }));
     * ```
     */
    useQueries<
      T extends Array<UseQueryOptionsForUseQueries<GetAlertSchema, GetAlertParameters, GetAlertData, GetAlertError>>,
      TCombinedResult = Array<UseQueryResult<GetAlertData, GetAlertError>>
    >(options: {
      queries: T;
      combine?: (results: Array<UseQueryResult<GetAlertData, GetAlertError>>) => TCombinedResult;
    }): TCombinedResult;
    /**/
    getQueryKey(parameters: DeepReadonly<GetAlertParameters>): ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.alertsService.getAlert.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAlertData>(
      parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options?: Omit<UndefinedInitialDataOptions<GetAlertData, GetAlertError, TData, ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>>, "queryKey">
    ): UseQueryResult<TData, GetAlertError | Error>;
    /**
     * Performs asynchronous data fetching, manages loading states and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
     * @example Query with parameters
     * ```ts
     * const { data, isLoading } = qraft.alertsService.getAlert.useQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useQuery<TData = GetAlertData>(
      parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options: Omit<DefinedInitialDataOptions<GetAlertData, GetAlertError, TData, ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>>, "queryKey">
    ): DefinedUseQueryResult<TData, GetAlertError | Error>;
    /**
     * Performs asynchronous data fetching with support for infinite scrolling scenarios.
     * Manages paginated data and provides utilities for fetching additional pages.
     * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
     *
     * @example Suspense Infinite Query
     * ```ts
     * const { data, isLoading, fetchNextPage } = qraft.alertsService.getAlert.useSuspenseInfiniteQuery({
     *     path: {
     *         id: id
     *     }
     * }, {
     *     initialPageParam: {},
     *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
     * })
     *
     * console.log(data);
     * fetchNextPage(); // Fetch the next page
     * ```
     */
    useSuspenseInfiniteQuery<TPageParam extends GetAlertParameters, TData = GetAlertData>(
      parameters: ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options: Omit<
        UseSuspenseInfiniteQueryOptions<
          GetAlertData,
          GetAlertError,
          OperationInfiniteData<TData, GetAlertParameters>,
          GetAlertData,
          ServiceOperationInfiniteQueryKey<GetAlertSchema, GetAlertParameters>,
          PartialParameters<DeepReadonly<TPageParam>>
        >,
        "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"
      > &
        InfiniteQueryPageParamsOptions<GetAlertData, PartialParameters<DeepReadonly<TPageParam>>>
    ): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetAlertParameters>, GetAlertError | Error>;
    /**
     * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
     * Similar to useQueries but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
     * @example Basic usage with Suspense
     * ```ts
     * const getAlertData = qraft.alertsService.getAlert.useSuspenseQueries({
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getAlertResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
     * ```
     * @example With data transformation using combine
     * ```ts
     * const getAlertCombinedData = qraft.alertsService.getAlert.useSuspenseQueries({
     *     combine: results => results.map(result => result.data),
     *     queries: [
     *         {
     *             path: {
     *                 id: id1
     *             }
     *         },
     *         {
     *             path: {
     *                 id: id2
     *             }
     *         }
     *     ]
     * });
     * getAlertCombinedData.forEach(data => console.log({ data }));
     * ```
     */
    useSuspenseQueries<
      T extends Array<UseQueryOptionsForUseSuspenseQuery<GetAlertSchema, GetAlertParameters, GetAlertData, GetAlertError>>,
      TCombinedResult = Array<UseSuspenseQueryResult<GetAlertData, GetAlertError>>
    >(options: {
      queries: T;
      combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetAlertData, GetAlertError>, "data">>) => TCombinedResult;
    }): TCombinedResult;
    /**
     * Performs asynchronous data fetching with Suspense support.
     * Similar to useQuery but integrates with React Suspense for loading states.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
     * @example Suspense Query with parameters
     * ```ts
     * const data = qraft.alertsService.getAlert.useSuspenseQuery({
     *     path: {
     *         id: id
     *     }
     * })
     * ```
     */
    useSuspenseQuery<TData = GetAlertData>(
      parameters: ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters> | DeepReadonly<GetAlertParameters>,
      options?: Omit<UseSuspenseQueryOptions<GetAlertData, GetAlertError, TData, ServiceOperationQueryKey<GetAlertSchema, GetAlertParameters>>, "queryKey">
    ): UseSuspenseQueryResult<TData, GetAlertError | Error>;
    schema: GetAlertSchema;
    types: {
      parameters: GetAlertParameters;
      data: GetAlertData;
      error: GetAlertError;
    };
  };
  patchAlert: {
    /**/
    getMutationKey(parameters: DeepReadonly<PatchAlertParameters> | void): ServiceOperationMutationKey<PatchAlertSchema, PatchAlertParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.alertsService.patchAlert.useMutation({
     *     path: {
     *         id: id
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.alertsService.patchAlert.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends PatchAlertBody, TContext = unknown>(
      parameters: DeepReadonly<PatchAlertParameters>,
      options?: ServiceOperationUseMutationOptions<PatchAlertSchema, PatchAlertData, PatchAlertParameters, TVariables, PatchAlertError | Error, TContext>
    ): UseMutationResult<PatchAlertData, PatchAlertError | Error, TVariables, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.alertsService.patchAlert.useMutation({
     *     path: {
     *         id: id
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.alertsService.patchAlert.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<PatchAlertBody, PatchAlertParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<PatchAlertSchema, PatchAlertData, PatchAlertParameters, TVariables, PatchAlertError | Error, TContext>
    ): UseMutationResult<PatchAlertData, PatchAlertError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const patchAlertTotal = qraft.alertsService.patchAlert.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const patchAlertTotal = qraft.alertsService.patchAlert.useIsMutating({
     *     parameters: {
     *         path: {
     *             id: id
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<PatchAlertBody, PatchAlertData, PatchAlertParameters, PatchAlertError | Error, TContext>
        | MutationFiltersByMutationKey<PatchAlertSchema, PatchAlertBody, PatchAlertData, PatchAlertParameters, PatchAlertError | Error, TContext>
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<PatchAlertBody, PatchAlertData, PatchAlertParameters, PatchAlertError | Error, TContext>
        | MutationFiltersByMutationKey<PatchAlertSchema, PatchAlertBody, PatchAlertData, PatchAlertParameters, PatchAlertError | Error, TContext>
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<PatchAlertBody, PatchAlertParameters>,
      client?: (
        schema: PatchAlertSchema,
        options: ServiceOperationMutationFnOptions<PatchAlertBody, PatchAlertParameters>
      ) => Promise<RequestFnResponse<PatchAlertData, PatchAlertError>>
    ): Promise<RequestFnResponse<PatchAlertData, PatchAlertError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const patchAlertPendingMutationVariables = qraft.alertsService.patchAlert.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const patchAlertMutationData = qraft.alertsService.patchAlert.useMutationState({
     *     filters: {
     *         parameters: {
     *             path: {
     *                 id: id
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<PatchAlertData, PatchAlertError | Error, MutationVariables<PatchAlertBody, PatchAlertParameters>, TContext>
    >(options?: {
      filters?:
        | MutationFiltersByParameters<PatchAlertBody, PatchAlertData, PatchAlertParameters, PatchAlertError | Error, TContext>
        | MutationFiltersByMutationKey<PatchAlertSchema, PatchAlertBody, PatchAlertData, PatchAlertParameters, PatchAlertError | Error, TContext>;
      select?: (mutation: Mutation<PatchAlertData, PatchAlertError | Error, MutationVariables<PatchAlertBody, PatchAlertParameters>, TContext>) => TResult;
    }): Array<TResult>;
    schema: PatchAlertSchema;
    types: {
      parameters: PatchAlertParameters;
      data: PatchAlertData;
      error: PatchAlertError;
      body: PatchAlertBody;
    };
  };
  deleteAlert: {
    /**/
    getMutationKey(parameters: DeepReadonly<DeleteAlertParameters> | void): ServiceOperationMutationKey<DeleteAlertSchema, DeleteAlertParameters>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.alertsService.deleteAlert.useMutation({
     *     path: {
     *         id: id
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.alertsService.deleteAlert.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends DeleteAlertBody, TContext = unknown>(
      parameters: DeepReadonly<DeleteAlertParameters>,
      options?: ServiceOperationUseMutationOptions<DeleteAlertSchema, DeleteAlertData, DeleteAlertParameters, TVariables, DeleteAlertError | Error, TContext>
    ): UseMutationResult<DeleteAlertData, DeleteAlertError | Error, TVariables | void, TContext>;
    /**
     * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
     * Handles loading state, optimistic updates, and error handling.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
     * @example Mutation with predefined parameters, e.g., for updating
     * ```ts
     * const { mutate, isPending } = qraft.alertsService.deleteAlert.useMutation({
     *     path: {
     *         id: id
     *     }
     * })
     * mutate(body);
     * ```
     * @example Mutation without predefined parameters, e.g., for creating
     * ```ts
     * const { mutate, isPending } = qraft.alertsService.deleteAlert.useMutation()
     * mutate({
     *     body: bodyPayload,
     *     path: {
     *         id: id
     *     }
     * });
     * ```
     */
    useMutation<TVariables extends MutationVariables<DeleteAlertBody, DeleteAlertParameters>, TContext = unknown>(
      parameters: void,
      options?: ServiceOperationUseMutationOptions<DeleteAlertSchema, DeleteAlertData, DeleteAlertParameters, TVariables, DeleteAlertError | Error, TContext>
    ): UseMutationResult<DeleteAlertData, DeleteAlertError | Error, TVariables, TContext>;
    /**
     * Returns the count of currently in-progress mutations.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
     * @example Check how many mutations are currently in progress for the specified service method.
     * ```ts
     * const deleteAlertTotal = qraft.alertsService.deleteAlert.useIsMutating()
     * ```
     * @example Check how many mutations are currently in progress with the specified parameters.
     * ```ts
     * const deleteAlertTotal = qraft.alertsService.deleteAlert.useIsMutating({
     *     parameters: {
     *         path: {
     *             id: id
     *         }
     *     }
     * })
     * ```
     */
    useIsMutating<TContext = unknown>(
      filters?:
        | MutationFiltersByParameters<DeleteAlertBody, DeleteAlertData, DeleteAlertParameters, DeleteAlertError | Error, TContext>
        | MutationFiltersByMutationKey<DeleteAlertSchema, DeleteAlertBody, DeleteAlertData, DeleteAlertParameters, DeleteAlertError | Error, TContext>
    ): number;
    /**/
    isMutating<TContext>(
      filters?:
        | MutationFiltersByParameters<DeleteAlertBody, DeleteAlertData, DeleteAlertParameters, DeleteAlertError | Error, TContext>
        | MutationFiltersByMutationKey<DeleteAlertSchema, DeleteAlertBody, DeleteAlertData, DeleteAlertParameters, DeleteAlertError | Error, TContext>
    ): number;
    /**/
    (
      options: ServiceOperationMutationFnOptions<DeleteAlertBody, DeleteAlertParameters>,
      client?: (
        schema: DeleteAlertSchema,
        options: ServiceOperationMutationFnOptions<DeleteAlertBody, DeleteAlertParameters>
      ) => Promise<RequestFnResponse<DeleteAlertData, DeleteAlertError>>
    ): Promise<RequestFnResponse<DeleteAlertData, DeleteAlertError>>;
    /**
     * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
     *
     * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
     * @example Get all variables of all running mutations.
     * ```ts
     * const deleteAlertPendingMutationVariables = qraft.alertsService.deleteAlert.useMutationState({
     *     filters: {
     *         status: "pending"
     *     },
     *     select: mutation => mutation.state.variables
     * })
     * ```
     * @example Get all data for specific mutations via the `parameters`.
     * ```ts
     * const deleteAlertMutationData = qraft.alertsService.deleteAlert.useMutationState({
     *     filters: {
     *         parameters: {
     *             path: {
     *                 id: id
     *             }
     *         }
     *     },
     *     select: mutation => mutation.state.data
     * })
     * ```
     */
    useMutationState<
      TContext = unknown,
      TResult = MutationState<DeleteAlertData, DeleteAlertError | Error, MutationVariables<DeleteAlertBody, DeleteAlertParameters>, TContext>
    >(options?: {
      filters?:
        | MutationFiltersByParameters<DeleteAlertBody, DeleteAlertData, DeleteAlertParameters, DeleteAlertError | Error, TContext>
        | MutationFiltersByMutationKey<DeleteAlertSchema, DeleteAlertBody, DeleteAlertData, DeleteAlertParameters, DeleteAlertError | Error, TContext>;
      select?: (mutation: Mutation<DeleteAlertData, DeleteAlertError | Error, MutationVariables<DeleteAlertBody, DeleteAlertParameters>, TContext>) => TResult;
    }): Array<TResult>;
    schema: DeleteAlertSchema;
    types: {
      parameters: DeleteAlertParameters;
      data: DeleteAlertData;
      error: DeleteAlertError;
      body: DeleteAlertBody;
    };
  };
}
export const alertsService: {
  createAlert: {
    schema: CreateAlertSchema;
  };
  getAlert: {
    schema: GetAlertSchema;
  };
  patchAlert: {
    schema: PatchAlertSchema;
  };
  deleteAlert: {
    schema: DeleteAlertSchema;
  };
} = {
  createAlert: {
    schema: {
      method: "post",
      url: "/alerts",
      mediaType: ["application/json"]
    }
  },
  getAlert: {
    schema: {
      method: "get",
      url: "/alerts/{id}"
    }
  },
  patchAlert: {
    schema: {
      method: "patch",
      url: "/alerts/{id}",
      mediaType: ["application/json"]
    }
  },
  deleteAlert: {
    schema: {
      method: "delete",
      url: "/alerts/{id}"
    }
  }
};
type CreateAlertSchema = {
  method: "post";
  url: "/alerts";
  mediaType: ["application/json"];
};
type CreateAlertParameters = {
  query?: never;
  header?: never;
  path?: never;
};
type CreateAlertData = paths["/alerts"]["post"]["responses"]["201"]["content"]["application/json"];
type CreateAlertError = unknown;
type CreateAlertBody = paths["/alerts"]["post"]["requestBody"]["content"]["application/json"];
type GetAlertSchema = {
  method: "get";
  url: "/alerts/{id}";
};
type GetAlertParameters = paths["/alerts/{id}"]["get"]["parameters"];
type GetAlertData = paths["/alerts/{id}"]["get"]["responses"]["201"]["content"]["application/json"];
type GetAlertError = unknown;
type PatchAlertSchema = {
  method: "patch";
  url: "/alerts/{id}";
  mediaType: ["application/json"];
};
type PatchAlertParameters = paths["/alerts/{id}"]["patch"]["parameters"];
type PatchAlertData = paths["/alerts/{id}"]["patch"]["responses"]["201"]["content"]["application/json"];
type PatchAlertError = unknown;
type PatchAlertBody = paths["/alerts/{id}"]["patch"]["requestBody"]["content"]["application/json"];
type DeleteAlertSchema = {
  method: "delete";
  url: "/alerts/{id}";
};
type DeleteAlertParameters = paths["/alerts/{id}"]["delete"]["parameters"];
type DeleteAlertData = paths["/alerts/{id}"]["delete"]["responses"]["201"]["content"]["application/json"];
type DeleteAlertError = unknown;
type DeleteAlertBody = undefined;
