name: Deploy k8s

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "The environment to deploy to"
        required: true
        type: choice
        options:
          - staging
          - prod
      app:
        description: "The app to deploy"
        required: true
        type: choice
        options:
          - console-web
          - console-web-testnet
          - console-api
          - tx-signer
          - indexer
          - notifications
          - provider-proxy
          - provider-console
          - provider-console-api
          - provider-console-security
          - stats-web
      appVersion:
        description: "The version of the app to deploy"
        required: true
        type: string
      chain:
        description: "The chain to deploy to"
        required: false
        type: choice
        default: NA
        options:
          - NA
          - mainnet
          - sandbox
          - testnet
      force-rollout:
        type: boolean
        required: false
        default: false
        description: >-
          Force a Kubernetes rollout restart even if the Deployment spec is unchanged.
      approve:
        type: boolean
        required: false
        default: false
        description: >-
          Whether to require manual approval before proceeding with the deployment.
      linked-workflow-run-id:
        description: "The ID of the workflow run that triggered this deployment"
        required: false
        type: string

  workflow_call:
    inputs:
      environment:
        description: "The environment to deploy to"
        required: true
        type: string
      app:
        description: "The app to deploy"
        required: true
        type: string
      appVersion:
        description: "The version of the app to deploy"
        required: true
        type: string
      chain:
        description: "The chain to deploy to"
        required: false
        type: string
        default: NA
      force-rollout:
        type: boolean
        required: false
        default: false
        description: >-
          Force a Kubernetes rollout restart even if the Deployment spec is unchanged.
      approve:
        type: boolean
        required: false
        default: false
        description: >-
          Whether to require manual approval before proceeding with the deployment.

# 1 pending + 1 in-progress workflows
concurrency:
  group: deploy-${{ inputs.app }}-${{ inputs.environment }}-${{ inputs.chain || 'NA' }}

jobs:
  deployment-prerequisites:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.determine-environment.outputs.environment }}
      require_approval: ${{ steps.approval-status.outputs.require_approval }}
    permissions:
      contents: read
      pull-requests: read
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Display linked workflow run ID
        if: ${{ inputs.linked-workflow-run-id }}
        run: |
          echo "Linked workflow run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" >> "$GITHUB_STEP_SUMMARY"

      - name: Determine environment
        id: determine-environment
        env:
          BLOCKCHAIN_NAME: ${{ inputs.chain != 'NA' && inputs.chain || '' }}
          DEPLOYMENT_ENVIRONMENT: ${{ inputs.environment == 'prod' && 'production' || 'beta' }}
        run: |
          environment_suffix=""
          if [[ -n "$BLOCKCHAIN_NAME" ]]; then
            environment_suffix="-$BLOCKCHAIN_NAME"
          fi
          echo "environment=$DEPLOYMENT_ENVIRONMENT$environment_suffix" >> "$GITHUB_OUTPUT"

      - name: Check if approval is required
        id: approval-status
        env:
          DEPLOYMENT_ENVIRONMENT: ${{ steps.determine-environment.outputs.environment }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          env="${{ inputs.environment }}-${{ inputs.chain }}"
          require_approval=$([[ "$env" == "prod-NA" || "$env" == "prod" ]] && echo "true" || echo "false")
          echo "require_approval=$require_approval" >> "$GITHUB_OUTPUT"
      - name: Notify in Slack about pending deployment
        if: steps.approval-status.outputs.require_approval == 'true'
        uses: ./.github/actions/slack-pending-deployment-approval
        with:
          url: ${{ vars.CONSOLE_WEB_BETA_URL }}
          slack-webhook-url: ${{ secrets.FAILED_E2E_TESTS_SLACK_WEBHOOK_URL }}
          gh-user-to-slack-user: ${{ vars.GH_USER_TO_SLACK_USER }}
          app: ${{ inputs.app }}
          new-version: ${{ inputs.appVersion }}
          environment: ${{ inputs.environment }}
          chain: ${{ inputs.chain != 'NA' && inputs.chain || '' }}
          linked-workflow-run-id: ${{ github.run_id }}

  deploy:
    runs-on: ubuntu-latest
    needs: deployment-prerequisites
    if: >-
      needs.deployment-prerequisites.outputs.require_approval != 'true' || inputs.approve == 'true' || inputs.approve == true
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Load kubeconfig
        id: op-load-secret
        uses: 1password/load-secrets-action@v2
        with:
          export-env: true
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}
          KUBECONFIG: ${{ vars.OP_KUBECONFIG_URI }}
          TS_OAUTH_CLIENT_ID: ${{ vars.OP_TS_OAUTH_CLIENT_ID_URI }}
          TS_OAUTH_SECRET: ${{ vars.OP_TS_OAUTH_CLIENT_SECRET_URI }}

      - name: Tailscale
        uses: tailscale/github-action@v3
        with:
          oauth-client-id: ${{ env.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ env.TS_OAUTH_SECRET }}
          tags: tag:ci
          timeout: 5m
          use-cache: true

      - name: Check tailscale connection
        run: |
          tlrunning=$(tailscale status --json | jq -r '.BackendState')
          if [[ $tlrunning != "Running" ]]; then
              exit 1
          fi

          tlstatus=$(tailscale status --json | jq -r '.CurrentTailnet.Name')

          if [[ $tlstatus != "${{ vars.TAILSCALE_ORG }}" ]]; then
              exit 1
          fi

      - name: Wait for node1-console-akash-network node to be online
        run: |
          echo "Waiting for node1-console-akash-network to be online..."
          for i in {1..30}; do
            ONLINE=$(tailscale status --json | jq -e '.Peer[] | select(.DNSName | contains("node1-console-akash-network")) | .Online')
            if [[ "$ONLINE" == "true" ]]; then
              echo "✅ Peer is online."
              exit 0
            fi
            echo "⏳ Still waiting... ($i)"
            sleep 5
          done

          echo "❌ Timed out waiting for peer node to be online."
          tailscale status
          exit 1

      - name: Set up Helm
        uses: azure/setup-helm@v4.3.0
        with:
          version: "latest"

      - name: Deploy with Helm
        run: |
          echo "$KUBECONFIG" > kubeconfig

          release_name="${{ inputs.app }}"

          values_file_path=".helm/${{ inputs.app }}-${{ inputs.environment }}"

          if [ -n "${{ inputs.chain }}" ] && [ "${{ inputs.chain }}" != "NA" ]; then
            release_name="${release_name}-${{ inputs.chain }}"
            values_file_path="${values_file_path}-${{ inputs.chain }}"
          fi

          echo "release_name=$release_name" >> "$GITHUB_ENV"

          values_file_path="${values_file_path}-values.yaml"

          if [ -f "$values_file_path" ]; then
            values_file_arg="--values $values_file_path"
          fi

          chart_name="akash/${{ inputs.app }}"

          helm repo add akash https://akash-network.github.io/helm-charts

          echo "executing: helm upgrade $release_name $chart_name --install --atomic -n ${{ inputs.environment }} --set appVersion=${{ inputs.appVersion }} --debug --kubeconfig kubeconfig $values_file_arg"
          # shellcheck disable=SC2086
          helm upgrade "$release_name" "$chart_name" --install --atomic -n "${{ inputs.environment }}" --set "appVersion=${{ inputs.appVersion }}" --debug --kubeconfig kubeconfig $values_file_arg

      - name: Force rollout (restart pods even if spec unchanged)
        if: success() && inputs.force-rollout
        run: |
          kubectl --kubeconfig kubeconfig -n "${{ inputs.environment }}" rollout restart deploy "${{ env.release_name }}"

      - name: Create deployment
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPOSITORY: ${{ github.repository }}
          APP_ENV: ${{ needs.deployment-prerequisites.outputs.environment }}
          GH_REF: ${{ inputs.app }}/v${{ inputs.appVersion }}
        run: |
          DEPLOYMENT_ID=$(
            gh api -X POST "repos/$REPOSITORY/deployments" \
              -f ref="$GH_REF" \
              -f environment="$APP_ENV" \
              -f auto_merge=false \
              -f required_contexts='[]' \
              --jq '.id'
          )
          echo "Deployment: $DEPLOYMENT_ID"

          gh api -X POST "repos/$REPOSITORY/deployments/$DEPLOYMENT_ID/statuses" \
            -f state="success" \
            -f description="Deploy finished"
